HOW TO DRIVE A DATABASE FRONT DID USING GENERAL SEMANTIC INFORMATION 
~ Boguraev and K. Sparck Jones 
Computer Laborator~ U.iversity of  CambridKe 
Corn Exchange Street, Cambridge CB2 3QG, England 
ABSTRACT 
This paper describes a f ront  end fo r  natura l  
language access to databases making extens ive  use o f  
genera l ,  l~ .  domain- independent,  semantic 
information for question interpretation. In the 
interests of  por tab i l i ty ,  initial syntactic and 
semantic processing of a question is carried out 
without  any re ference  to the database domain, and 
domain-dependent operat ions  are conf ined  to  
subsequent,  comparat ive ly  s t ra ight fo rward .  
process ing  o? the initial i n te rpretat ion .  The 
d i f fe rent  modules o f  the f ront  end are descr ibed ,  and 
the system's performance i s  illustrated by examples. 
I I~TRODUC'TION 
Following the developmemt 0? various front ends 
for natural language access to databases, it is now 
generally agreed that such a front end must utillse 
at leas t  three  d i f fe rent  k inds  o f  knowledge to 
accomplish its task: linguistic k~owledge, knowledge 
o f  the domain o f  d i scourse ,  and knowledge o f  the 
organlsational structure of the database. Thus 
broadly speaking, a user request to the database goes 
through three conceptually different forms: the 
output  of linguistic analysis o? the question, its 
representation in terms of the domain's conceptual 
schema, and its interpretation in the database 
access language. Ear ly  natura l  language front ends 
usua l ly  d id  not have a c learcut  separat ion  between 
the different stages of the process: for example 
LUNAR (Woods 1972) merged the domain model and the 
database model into one, and systems such as the 
early incarnation of LADDER (Hendrix et al1978) and 
PLANES (Waltz 1978) made heavy use of semantic 
grammars with their domain-dependent lexicons 
ccmbinin8 l ingu is t i c  kncwledge with domain knowledge 
and so merging the first two stages. None 0? these 
systems, moreover, made any significant use of 
~eneral, as opposed to domain-specific, semantic 
information. 
In an attempt to achieve portability from one 
database to another, mcst current systems adhere to a 
~eneral framework (Konolige 1979), which makes a 
clear distinction between the different processing 
phases and distinguishes the domain-dependent from 
the domaln-independent parts of the front end, and 
also domain operations from database management 
cperatlons. However semantic processing is still 
This work is supported by the U.K. Science and 
Engineering Research Council. 
8t 
essent ia l l y  d r iven  by domain-dependent semantics.  
Linguistic processing is therefore primarily 
syntactic parsing, and relating general linguistic 
to specific domain knowledge within the framework of 
a modular f ront  end takes the form o f  app ly ing  
domain-dependent semantic processing to the output 
of  the syntactic parser. This may be done in a 
slmple, minded way as in PHLIQAI (Bronnenberg et al
1979) and T~ (Damerau 1980), or  by prov id ing  hooks 
in the syntactic representation (domain-independent 
calls to semantic operators which will evaluate 
differently in  dl?ferent contexts), as in DIALOGIC 
(Grosz et ai 1982). In either case the usual unhappy 
consequence o? separating syntactic and semantic 
processing, namely the hassle of manipulating 
alternative syntactic trees, follows. Furthermore, 
changlngdomalns implies changing the definitions of 
the semantic operators, which are procedural in 
nature, while it may be preferable to keep the 
domain-dependent par ts  o f  the f ront  end in 
dec la ra t ive  form, as i s  indeed done in (Warren and 
Pere i ra  1981). 
Thus in systems of this by now conventional type, 
the 'portability' achieved by confining the necessary 
domain-dependent semantic processing to well- 
defined modules is purchased at the heavy price of 
limiting the early linguistic processing to syntax, 
and, perhaps, some very global and undiscriminating 
semantics (see for example the sccping algorithm of 
(Grosz et al 1982)).  
II SPECIFIC APPROACH 
Our objective is to do better than this by making 
more use of powerful, but still non-domain-dependent 
semantics in the front-end linguistic analysis. 
Doing th i s  should have two advantages: res t ra in ing  
syntax,  and prov id ing  a good p la t fo rm for  domain- 
dependent semantic processing. However, the overall 
architecture of the front end still follows the 
Konolige model in maintaining a clearcut separation 
between the different k inds  of knowledge to be 
utilised, keeping the bulk of the domain-dependent 
knowledge in declarative form, and attempting to 
minimlse the consequences of changes in the front 
end environmant, whether of domain or database model, 
to promote s~ooth transfers cf the front end from 
one back end database management system to another.  
We believe that there is a lot of mileage to be 
got from non-task-specific semantic analysis of user 
requests, because their resulting rich, exp l ic i t ,  and 
ncrmal ised meaning representat ions  are a ~ccd 
starting point for subsequent task-specific 
operations, and specificall~ are better than either 
syntax trees, or the actual input text of e.g. the 
PLANES approach. Furthermore, since the domain world 
is (in some sense) a subset of the real world, it is 
possible to interpret descriptions of it using the 
same semantic apparatus  and representation language 
as is used by the natural language analyser, which 
should allow easy and reliable linking of the 
natural language input words, domain world objects 
and re la t ionsh ips  and data language terms and 
express ions .  Since the connect ions  between these do 
not  appear hard -w i red  in the lex icon ,  but  are 
established on the basis of matching rich semantic 
patterns, no changes at all should be required in the 
lexicon as the application moves from one domain or 
database to another, only expansions to allow for the 
semantic definitions of  new words relevant to the 
new app l i ca t ion .  
The approach leads  to an overa l l  front end 
structure as  follows: 
: English question : 
ANALYSIS 
Ana l~er  I '  1 -~ 
i (uses linguistic knowledge) i 
: meaning representation : 
j Extractor 2 
(uses logico-linguistic knowledge) I 
I 
: logic representation : 
TRANSLATION ,L 
L--~---- _ __~- -_  3 
: Translator 
(uses domain world knowledge) ,: 
$ 
: query  representation : 
Convertor 
(uses database organisation 
~cwledge)  l 
$ 
: search rePresentation : 
Each process in the diagram above operates cn the 
output of the previous one. Processes I and 2 
constitute the analysis phase, and processes 3 and 
- the translation phase. Such a system has 
essentially been constructed, and is under active 
test; a detailed acccunt cf its components and 
operations follows. 
For the purposes of illustration we shall use 
questions addressed to the Suppliers and Parts 
relational database of (Date 1977). This has three 
relaticns with the following structure: 
Supplier(Snc, Shame, Status, Scity), Part(Pno, Pname, 
Colour, Weight, Pcity), and Shipments(Sno, Pnc, 
Quantity). 
82 
I I I  ANALYSIS 
A. The Anal)met 
The natura l  language anal  l met has been descr ibed  
in deta i l  e lsewhere (Boguraev 1979), (Boguraev and 
Sparck Jones 1982), and only a brief summary will be 
presented here. I t  has been designed as a genera l  
purpose,  domain-  and task - independent  language 
processor, driven by a fairly extensive 
llnguistlcally-motivated grammar and controlled in 
its operation by variegated application cf a rich 
and powerful semantic apparatus .  Syntactically- 
controlled constituent identification is coupled 
with the Judgemental application cf semantic 
specialists: following the evaluation of the 
semantic plausibility of the constituent at hand, 
the currently active processor either aborts the 
analysis path or constructs a meaning representation 
for the textual unit (noun phrase, ccmplementiSero 
embedded clause, etc.) for incorporation into any 
larger semantic construct. The philosophy behind the 
anal yser is that syntactlcally-drlven analysis 
(which is a major prerequisite for domain- and/or 
task-independence) is made efficient by frequent and 
timely calls to semantic specialists, which both 
control blind syntactic backtracking and construct 
meaning representations for input text without going 
through the potentiall y costly enumeration of 
intermediate syntactic trees. The analyser can 
therefore operate smoothly in environments which are 
syntactically or lexically hlghiy ambiguous. 
To achieve its objectives the program pursues a 
passive parsing strategy based on semantic pattern 
matching of the kind proposed by (Wilks 1975). Thus 
the semantic specialists work with a range of 
patterns referring to narrower or broader word 
classes, all defined using general semantic 
primitives and ultimately depending on formulae 
which use the primitives to characterise individual 
word senses. However the application of patterns in 
the search for input text meaning is mcre 
effectively controlled by syntax in this system than 
in Wilks'. 
The par t i cu la r  advantages o f  the approach in the 
database app l i ca t ion  context  are the power fu l  and 
f lex ib le  means o f  represent ing  l ingu is t i c  and world 
knowledge prov ided by the semantic p r imi t ives ,  and 
the ease wi th  which ' t raps  fo r  the unexpected'  can be 
procedura l ly  encoded. The la t te r  means that  the 
system can readily deal with the kinds cf problems 
generated by unconstrained natural language text 
which provoke untoward 'ripple' effects when large 
semantic grammars are mcdified. The semantic 
primitive foundatlcn for the analyser provides a 
good base fcr the whole front end, since the 
ccmprehensive inventory cf primitives can be 
exp lo i ted  to character i se  both natura l  language and 
data language terms and expressions, and to 
reconcile the user's view of the database domain with 
the actual administrative organisaticn of the 
database.  
For present  purposes,  the form and ccntent  c f  the 
outputs  o f  the natura l  language ana lyser  are more 
impor tant  than the means by which they are der ived  
( fo r  these see Boguraev and Sparck Jones 1982). The 
meaning representat ions  output  by the ana lyser  are 
dependency structures with clusters of case- labe l led  
components centred around main verb or noun 
elements. Apart from the structure of the dependency 
tree itself, and group identifying markers like 'ins' 
and 'modallty', the substantive information in the 
meaning representation is provided by the case 
l abe ls ,  which are  drawn from a la rge  set  of  semant ic  
relation primitives forming part of the overall 
inventory of primitives, and by the semantic 
category primitive characterisations of lexically- 
derived items. 
The formulae charaoterislng word senses may be 
quite rich. The fairly straightforward 
character i sa t ion  o f  ' supp l ie r1 ' ,  represent ing  one 
sense o f  "supp l ie r "  is  
(Supp l ie r  . . .  
( supp l ie r  1 
(~(ee~t obJe) give) (subJ CorK)) . . . ) ,  
meaning approx imate ly  that  some sor t  of organ isat ton  
(which may reduce to an ind iv idua l )  g ives  ent i t ies .  
The meaning representat ion  fo r  the whole sentence 
"Suppliers live in cities" (with the formulae for 
i nd iv idua l  un i t s  abbrev ia ted ,  for  space reasons ,  to 
the i r  head pr imi t ives )  i s  
( el ause . . . . . . . .  
(v 
( l i ve l  . . .  be 
I @@agent (n ( supp l ie r l  . . .  am)) )  ee~oca~ion (n (c i ty2  ... spread) ) ) ) ) ) ,  
where ~ and @locat ion are case labe ls .  "The 
parts are co loured red" will be analysed as 
( e l  ause . . . . . .  
(v 
(be2 . . .  be 
th in  in tpar t l  . . .  mennK)))yl (@@number 
(@~state 
~:~ <co lour l  ... s ign)  
(va l  (red1 ... sense) ) ) ) ) ) ) ,  
and "Who supp l ies  green parts?"  w i l l  g ive  r i se  to 
the structure: 
(clause ... (type question) 
(v 
(supplyl ... 81ve 
(@@agent (n (query (d~y) ) ) )  
~race  (clause V agent ) )  
(c lause 
(v 
(be2 . . .  be 
(@@@gent 
?n <part l  . . .  ~ InS) ) )  
(@@state (st  (eo lour l  . . .  sign) 
(gr, eenl . . .  , 
tsee ~.se) ) ) ) ) ) ) ) ) ) ) ) ) .  
As these examples sho~ the anal yser's 
representations combine expressive power with 
structural simplicity. Further, the power of the 
semantic category primitives used to identify text 
message patterns means that it is possible to 
achieve far mcre semantic analysis cf a question, far 
earlier in the frcnt end processing, than can be 
achieved with frcnt ends conforming tc the Koncllge 
model. The effectiveness cf the anal yser as a general 
natural-language prccesslng device has been 
demcnstrated by its successful application to a 
range o f  natura l  language process ing  tasks .  There i s ,  
however, a p r i ce  to pay, in the database context ,  fo r  
i t s  genera l i ty .  Natura l  language makes ocn=acn use o f  
vague concepts ( "have" ,  "do" ) ,  a lmost content -empty  
markers ("be e, "o f " ) ,  and opaque const ruct ions  such 
as compound nouns. C lear l~  f ront  ends where domain- 
spec i f i c  in fo rmat ion  can prov ide  leverage in 
i n te rpret ing  these input  text  i tems have advantages.  
and i t  i s  not c lear  how a pr inc ip led  so lu t ion  to the 
problems they present  can be achieved w i th in  the 
framework o f  a genera l -purpose  anal yser o f  the kind 
descr ibed .  To prov ide  a domain -spec i f i c  
in terpretat ion  of, for example, compounds like 
"supp l ie r  c i ty" ,  an in ter face  would have to be 
prov ided oharaeter i s ing  domain k~owledge in the 
semantic terms fami l ia r  to the parser ,  and 
guarantee ing  the prov is ion  o f  exp l i c i t  s t ruc tura l  
charaoterlsations of the text constituent which 
would be ava i lab le  fo r  fu r ther  exp lo i ta t ion  by the 
parser. 
To avoid  invok ing  domain knowledge in th i s  way in 
ana lys i s  we have been ob l iged  to accept quest icn  
in terpretat ions  which are incomplete in l im i ted  
respects .  That is, we push the ord inary  semantic 
ana lys i s  procedures as fa r  as they w i l l  go, accept ing  
that  they  may leave 'dummy' markers in the dependency 
structure and compound nominals with ambiguous 
member words and no explicit extracted structure. 
B. The Ext rac tor  
n i le  the meaning representat ions  const ructed  by 
the natura l  language ana lyser  are genera l  and 
in fo rmat ive  enough to be able to support  dlfferent 
tasks  in d i f fe rent  app l i ca t ions  fo r  d i f fe rent  
domains, they  are not necessar i l y  the best fcrm cf 
representat ion  for  quest ion  answering, and 
spec i f i ca l ly  for address ing a coded database.  After 
the initial determination of question meaning. 
there fore ,  the quest ion  i s  subjected to task -  
o r iented ,  though not yet domain- and database-  
o r iented ,  process ing.  Imposing domain world and 
database organ isat lon  res t r i c t ions  on the quest ion  
at  this stage would be premature, since it cculd 
ecmplloate or even inhibit possible later inference 
operations. The idea cf providing a system ccmponent 
address ing a genera l  linguistic task, withcut 
throwing away any detailed information not in fact 
needed for scme specific instance cf that task, like 
natural language distinctions between quantifiers 
ignored by the database system, is  a lso  an a t t rac t ive  
one. 
The extractor thus emphasises the fact that the 
input text is a questicn, but carries the detailed 
semantic information provided by the analyser 
forward fcr exploitation in the translation phase cf 
the process ing.  
A gccd way to achieve a question formulation 
abstracted from the low-level crganisaticn cf the 
database is to interpret the user's input as a formal 
quer~ However our extractor, unlike the equivalent 
processors described by (Wocds 1972). (Warren and 
Pereira 1981) and (Grcsz et al1982), does not make 
any use cf domain-dependent in f c rmat icn ,  but 
constructs a icgic expression whose variable ranges 
and pred icate  relaticnships are defined in terms cf 
83 
the general semantic primitives used for 
ccnstructlng the input question meaning 
representation. The logic representation of the 
question which is output by the extractor highlights 
the search aspects cf the input, formalising them so 
that the subsequent processes which will eventually 
generate the search specification for the database 
management system can locate and focus on them 
easily; at the same time, the semantic richness of 
the original meaning representation is maintained to 
facilitate the later domain-crlented translation 
operations. 
The syntax of the logic representation closely 
fo l l c~ that defined by (Wocds 1978): 
(For <quantifier> <variable> / <range> 
: <restrictions on variable> 
- <prcpcslticn> ), 
where each cf the restrictions, or the proposition, 
can themselves be quantified expressions. The 
rationale for such quantified expressions as media 
for questions addressed towards an abstract database 
has been discussed by Woods. As we accept this, we 
have developed a transformation procedure which 
takes the meaning representation of an input  
question and ccnstructs a corresponding logic 
representation in the form just described. Thus for 
the question "Who supplies green parts?" analysed in 
Section A, we obtain 
(For Every SVarl / query 
: (For Every $Var2 / part1 
: ( cc lour l  $Var2 8reenl)  
- ( supp ly1SVar l  SVar2)) 
(D isp lay  SVar l ) ) .  
where the lexically-derived items indicating the 
ranges of the quantified variables ('query', 'part1'), 
the relationships between the variables ('supply1') 
and the predicates and predicate values ('cclcur1', 
'green I') in fact carry along wltb them their 
semantic formulae: these are omitted here, and in the 
rest cf  the paper, to save space. 
The extractor is geared to seek, in the analyser's 
dependent y structures, the simple prc positicns 
(atomic predications) which make up the logic 
representaticn. Follcwing the phi lcscphy cf the 
semantic thecry underlying the analyser design, 
these simple prcpositicns are identified wlth the 
basic messages, i.e. semantic patterns, which drive 
the parser and are expressed in the meaning 
representations it produces as verb and noun group 
clusters of case-related elements. In order to 
'unpack' these, the extractor iccks for the sources 
cf atomic predicates as 'SVO' triples, identifiable 
by a verb (cr ncun) and its case rcle fillers, which 
can be extracted quite naturally in a 
straightforward way from the dependency structure. 
Depending bcth cn the semantic characterisaticn 
cf the verb and its case arguments, and cn the 
semantic context as defined by the dependency tree, 
the triples are categcrised as belcnging to cne cf 
two types: \[$ObJ SLink $ObJ\]. or \[$Obj SPoss SPrcp\]. 
where the $Obj, SLink. or $Prcp items are further 
characterised in semantic terms. It is clear that the 
'basic messages' that the extractor seeks to identify 
as a preliminary step tc ccnstructing the logic 
representation define either primitive 
relationships between objects, cr properties of 
those same cb jec ts .  Thus the meaning representat ion  
for  "par t  supp l ie rs"  will be unpicked as a 'dummy' 
relationship between "suppliers" and "parts", i.e. as 
\[$ObJ1(supplierl) $Link1(dummy) $Obj2(partl)\]. 
while "green parts" will be interpreted as 
\ [$Ob j2(par t  1) $Poss(be2) SProp(co lour l  =green 1) \ ] .  
Larger constructs can be similarly deocmpcsed: thus 
"Where do the status 32 red parts suppliers live?" 
will be broken down into the following set of 
triples: 
\ [$Ob J l ( supp l ie r l )  SL ink l ( l i ve l )  $ObJS(query)\]  
& \ [$Ob j l ( supp l ie r l )  SLink2(dummy) $Ob~2(par t l ) \ ]  
& \ [$Ob j l ( supp l ie r l )  SPossl(be2) $Prcp l ( s ta tus=32)  \] 
& \ [$Ob j2(par t l )  SPcss2(be2) $Prcp2(cc lcur l=red l ) J .  
I t  must be empbasised that  wh i le  there are para l le l s  
between these s t ruc tures  and those of  the ent i ty -  
a t t r ibute  approach to data mode l l ing ,  the forms c f  
triple were chosen without any reference to 
databases. As noted earlier, they naturally reflect 
the form of the 'atomic propositions', i.e. basic 
messages, used as semantic patterns by the natural 
language anal yser. 
For completeness, the triples underlying the 
earlier question "Who supplies green parts?" are 
\[$Obj1(query=identity) 
$L lnk l ( supp ly l )  $Ob32(partl)\] 
& \ [$Obj2(par t  1) 
$Possl(be2) $Prcp l (cc lcur l=green l ) \ ]  
The sets cf interconnected triples are derived 
from the meaning representations by a fairly simple 
recursive prccedure. The next stage o~ the 
extraction process restructures the triples tree 
into a skeleton quantified structure, the icgic 
representation, to be passed fcrward tc the 
translator generating the formal query 
representaticn. Whenever mcre explicit information 
regarding the interpretat ion of the input as a 
question can be extracted frcm the meaning 
representaticn, this is inccrpcrated into the logic 
representation. Thus the processing includes 
identification and sccping of quantifiers following 
the approach adopted by Wccds, and es tab l i sh ing  the 
aspect, mcdaiity and focus cf the questicn. Like 
anyone e lse,  we do not c la im tc prov ide  a 
ccmprehensive treatment cf natura l  language 
quantifiers, and indeed in practice have not 
implemented prccesses for all the quantifiers 
handled by LUNAR. 
The icgic representaticn defines the logical 
content and structure cf the information the user is 
seeking. It may, as ncted, be inccmplete at pcints 
where domain reference is required, e.g. in the 
interpretation cf compound ~cuns; but it carries 
along, tc the translator, the very large amcunt cf 
semantic information provided by the case labels and 
formulae of  the meaning representation, which should 
be adequate to pinpoint the items sought by the user 
and tc describe them in terms suited to the database 
management system, so they may be accessed and 
retrieved. 
84 
IV TRAMSLATIOM 
A. The translator 
In the process of transforming the semantic 
content of the user's question into a low-level 
search representation geared to the administrative 
structure of the target database, it is necessary to 
reconcile the user's view of the world with the 
domain model. Before even attempting to construct, 
Say, a re la t iona l  a lgebra  express ion  to be 
interpreted by the back-end database management 
system, we must try to interpret the semantic content 
of the loKlc representation with reference to the 
se~emt cr variant of the real world modelled by the 
database.  
An obvious possibility here is to proceed 
directly from the variables and predications of  the 
Icglc representation to their database counterparts. 
For example, 
( su~p.lyl (give) 
svar l / supp l ie r l  (B in)  SVar2 /par t l  ( t~t~) )  
can be mapped d i rec t ly  onto a re la t ion  Shipments in 
the Supp l ie rs  and Parts database.  The mapping could 
be established by reference to the lexicon and to a 
schedule of  equivalences between logical and 
database structures. 
This approach suffers, however, from severe 
problems: the most important is that end users do not 
necessarily constrain their natural language to a 
highly limited vocabulary. Even in the simple 
context of the ~,ppliers and Parts database, it is 
possible to refer to "firms", "goods", "buyers", 
"sellers", "provisions", "customers", etc. In fact, it 
was precisely in order  to b r ing  variants under a 
common denominator that semantic grammars were 
employed. We, in contrast, have a more powerful, 
because more flexible, semantic apparatus at our 
d isposa l ,  capable of drawing out the similarities 
between "firms", "sellers", and "suppllers", as 
opposed to taking them as read. Thus a general 
semantic pattern which will match the dictionary 
definitions cf all of these words is (((neat obJm) 
give) (~b J  |org) ). Furthermore, if instead of 
attempting to define any sort of direct mapping 
between the natural language terms and expressions 
of the user and corresponding domain terms and 
expressions, we concentrate on finding the common 
links between them, we can see that even though the 
domain and, in turn,  database terms and express ion= 
may not mean exactly the same as their natural 
language relatives or sources, we should be able to 
detect overlaps in their semantic characterlsatlons. 
It is unlikely that the same cr similar words will be 
used in both natural and data languages if their 
meanings have ncth ing in ccmmcn, even i f  they are not 
ident ica l ,  so character i s ing  each using the same 
repertoire of semantic primitives shculd serve to 
establish the link~ between the two.  Thus, for 
example, one sense o f  the natura l  language word 
"iccaticn" will have the formula (this (where 
spread) ) and the data language word "&c i ty"  
referring to the domain object &city will have the 
formula (((man fo lk )  wrap) (wl~re spread) ) ,  which 
can be connected by the common constituent (~re  
spread) .  
85 
One d is t inc t ive  feature  o f  our f ront  end des ign,  
the use o f  genera l  semantics fo r  in i t ia l  quest ion  
in terpretat ion ,  iS thus  connected  w i th  ancther :  the 
more s t r ingent  requ i rements  imposed on natura l  
lanKusge to data language t rans la t ion  by the in i t ia l  
unconst ra ined  quest ion  in terpretat ion  can be met by 
exp lo i t ing  the resources  fo r  language meaning 
representat ion  in i t ia l l y  u t i l i sed  fo r  the natura l  
language quest ion  in terpretat ion .  We def ine  the 
domain world model led by the database using the same 
semantic apparatus  as the one used by the natura l  
language f ront  end processor ,  and invoke a f lex ib le  
and soph is t i ca ted  semantic pat tern  marcher tc 
es tab l i sh  the connect ion between the semantic 
content  o f  the  user  quest ion  (which i s  car r ied  over  
in  the log ic  representat ion)  and re la ted  ccncepts in 
the domain wor ld.  Taking the next  step from a domain 
wor ld  concept or re la t ionsh ip  between domain world 
ob Jants  to the i r  d i rec t  model in the  admin is t ra t ive  
s t ructure  o f  the database is  then re la t ive ly  easy. 
Since the domain wor ld  i s  essent ia l l y  a c losed 
wor ld  res t r i c ted  in sets  i f  not  in the i r  members, i t  
is possible to describe it in terms of a limited set 
of concepts and relationships: we have possible 
properties of objects and potential relationships 
between them. We can talk about &suppliers and &parts 
and the important relationship between them, namely 
that &suppliers &supply &parts. We can also specify 
that &suppliers &llve in &cities, &parts can be 
&n,-bered, and so on. 
We can thus utillse, either explicitly or 
implicitly, a description of the domain world which 
could be represented by dependency structures llke 
those used for natura l  language. The important  point 
about these is the way they express the semantic 
content of whole statememts about the domain, rather 
than the way they label individual domaln-referrlng 
terms as, e.g. "&supplier" or "&part". It is then easy 
to see how the logic representation for the question 
"What are the numbers of the status 30 suppliers?", 
name1 y 
(For Every Syar l . / supp l le r l  : (statusl $Varl  30) 
- (Dlap~ay tnum~rl $Varl))), 
can be unpacked by semantic pattern matching 
routines to establish the ccnnecticn between 
"supp l ie r  1" and "&supp l ie r " ,  "number 1" and 
"&number", and so on. In the same way the l cg ic  
representations for "From where does Blake operate?" 
and "Where are screws found?" can be analysed for 
semantic content which will establish that "Blake" 
is a &supplier, "operate" in the context cf the 
database domain means &supply, and "where" is a query 
marker acting fcr &city from which the &supplier 
Blake &supplies (as opposed to street corner, bucket 
shop, or crafts market); similarly, "screW' is an 
instance of &part and the cn ly  iccational 
information associated with &parts in the database 
in question is the &city where they are stored. All 
this becomes clear simply by matching the underlying 
semantic primitive definitions of the natural 
language and domain world words, in their 
propositional contexts. 
The translator is alac the module where domain 
reference is brought in tc complete the 
interpretation cf the input question where this 
cannot be fully interpreted by the analyser alcne. 
The semantic pattern-matchlnK potential cf the 
translation module can be exploited to determine the 
nature of the unresolved domain-specific 
predications (both 'dummy' relationships and those 
implicit in compound nominals), and vacuously 
defined objects ('query' variables). Thus the 
fragment of logical form for "... London suppliers of 
parts ..", namely 
(For <quant> $Varl/supplierl 
: (AND 
(For <quant> iVar2 /par t l  
- (dummy $Varl  $Var2))  
(For <quant> iYar3/London 
- (dummy SVarl SVar3) ) )  
i s  brcken down in to  the cor respond ing  domain 
predications 
(&supply  $Var l (&supp l ie r )  $Var2(&par t ) )  
and 
(&live $Var1(&supplier) $Var3(&clty)), 
while translating the logic representation for the 
example question "Who supplies green parts?" gives 
the query representation 
(For Every SVar l /&supp l le r  
: (For Every $Var2/&part  
: (&cclour iVar2Kreen) 
- (&supp ly  $Var l  SVar2)) 
- (D isp lay  $Var l ) ) .  
Apart from the fact that semantic pattern 
matching seems to cope quite successfully with 
unexpected inputs ('unexpected' in the sense that in 
the alternative approach nc mapping funct ion  would 
have been defined for them, thus implying a failure 
to parse and/or  interpret the input question), 
having a general natural language analyser at our 
disposal offers an additional bonus: the description 
of the domain world in terms of semantic primitives 
and primitive patterns can be generated largely 
automatically, since the domain world can be 
described in natural language (assuming, of course, 
an apprcpriate lexicon of domain world Words and 
definitions) and the descriptions simply analysed as 
utterances, producing a set of semantic structures 
which can subsequently be prccessed to cbtaln a 
repertoire of domain-relevant forms to be exploited 
fcr the matching procedures. 
B. The Convertor 
Having ident i f ied  the domain . terms and 
express ions ,  we have a h igh- leve l  database 
equ iva lent  c f  the or ig ina l  Eng l i sh  quest ion .  A 
substantial amcunt cf processing has pinpointed the 
question focus, has eliminated potential 
ambiguities, has resolved domain-dependent language 
ccnstructicns, and has provided fillers for 'dummy' 
or 'query' items. Further, the system has established 
that "London" is a &city, for example, cr that 
"Clark" is a specific instance of &supplier. The 
processing now has to make the final transition to 
the specific fcrm in which questions are addressed 
to the actual database management system. The 
semantic patterns cn which the translator relies, 
for example defining a domain word "&supplier" as 
(((cent obje) give) (subJ IorK)), while adequate 
encugh tc deduce that Clark is a &supplier, are not 
i n fo rmat ive  enough to suggest how &supp l ie rs  are 
model led in the ac tua l  database.  
Again,  the  cbv ious  approach  to adopt  here  i s  the  
mapping one, so that ,  fo r  i ns tance ,  we have: 
&supp l ie r  :=> re la t ion  Supp l ie r  
C la rk  ==> 
tup le  o f  re la t ion  Supp l ie r  
such that  Shames"Clark" 
But th i s  approach su f fe rs  from the same l imi ta t ions  
as d i rec t  mapping from log ic  representat ion  tc 
search representat ion ;  and a mcre f lex ib le  apprcach 
using the way the database mcdels the domain world 
has been adopted.  
In the previous section we discussed how the 
translator uses an inventory of semantic patterns to 
estab l i sh  the connect ion  between natura l  language 
and domain wor ld words. This  inventory  i s  not ,  
however, a f la t  s t ruc ture  with  no in terna l  
o rgan isat lon .  On the ccnt rar~ the semantic 
in fo rmat ion  about the domain wor ld  is  c rgan ised  in 
such a way that  i t  can natura l ly  be assoc ia ted  w i th  
the admin is t ra t ive  s t ruc ture  c f  the ta rget  database,  
For example in a re la t iona l  database,  a re la t ion  w i th  
tup les  over domains represents  proper t ies  o f .  c r  
relationships between, the objects in the domain 
world. The objects, properties and relationships are 
described by the semantic apparatus used for the 
translator, and as they also underlie, at not toc 
great remove, the database structure, the domain 
world concepts or predications of the query 
representation act as pointers into the data 
structures cf the database administrative 
crganlsatlon. 
For example, given the relation supplier over the 
domains S~ame, Snc. Status and Scity. the semantic 
patterns which describe the facts that in the domain 
wor ld  &supp l ie rs  &have &status ,  &numbers, &names and 
&live in &cities are crcsslinked, in the sense that 
they have the superstructure cf the database 
relation .Supplier imposed over them. We can thus use 
them to avoid explicit mapping between query data 
references and template relaticnal structures for 
the database. From the initial meaning 
representation for the question fragment "... Clark, 
who has status 30 ..." through to the query 
representation, the semantic pattern matching has 
established that Clark is an instance cf &supplier, 
that the relationship between the generic &supplier 
and the specific instance of &supplier (i.e. Clark) 
is that cf &name, and that the query is focussed cn 
his &status (whose value is supplied explicitly). 
Now from the position of the query predication 
(&status &supplier 30) in the characterisaticn cf 
the relaticn Supplier, the system will be able tc 
deduce that the way the target database 
administrative structure models the question's 
semantic ccntent is as a relation derived from 
Supplier with "Clark" and "30" as values in the 
columns Shame and Status respectlvely. 
The convertor thus employs declarative knowledge 
about the database organisaticn and the 
correspondence between this and the domain world 
structure to derive a generalised relational algebra 
expression which is an interpretation cf the formal 
86 
query in the context  o f  the re la t iona l  database 
model o f  the domain. We have chosen to gear the 
conver tor  towards a genera l l sed  re la t iona l  a lgebra  
express ion ,  because both  its simple under ly ing  
definition and the generality of its data structures 
within the relational model allow easy generat ion  of 
final low-level search representations for different 
specific database access systems. 
To der ive  the genera l l sed  re la t iona l  a lgebra  form 
of the question from the query representation, the 
conver tor  uses i t s  k~owledge o f  the way domain 
objects and predications are modelled in the 
database to establish a primary or derivable 
re la t ion  for each of the'quantifled variables of the 
query  representation. These constituents of  the 
a lgebra  express ion  are then combined, with  an 
appropr ia te  sequence of re la t iona l  operators, to 
obta in  the  complete express ion .  
The basic premise of the convertor is that every 
quantified variable in the formal representation can 
be associated with some primary or computable 
relation in the target database; restrictions on the 
quantified variables specify how, with that relation 
as a s tar t ing  point, fu r ther  re la t iona l  a lgebra  
computations can be performed to mcdel the 
restricted variable; the process is recurslve, and as 
the query representation is scanned by the 
conver tor ,  var iab les  and their assoc ia ted  re la t iona l  
a lgebra  express ions  are bound by an 'environmemt- 
type' mechanism which provides all the necessary 
i n fo rmat ion  to 'eva luate '  the propos i t ions  o f  the 
quer~ Thus ccnverslon is evaluating a predicate 
expression in the context of its semantic 
i n te rpretat ion  in the domain ~r ld  and the 
envlronmemt of the database ? models for its 
variables. 
For example, g iven the query representat ion  
fragment fo r  the phrase "... a l l  London supp l ie rs  who 
supply  red parts . . " ,  namely 
(For Every SVar l /&supp l ie r  
:(AND 
(For The $Var3/London - (& l ive  SVarl SVar3)) 
(For Every SVar2/&part : (&cc lcur  SVar2 red) 
- (&supply $Var lSVar2) ) )  .... 
SVarl w i l l  i n i t ia l l y  be bound to the pr imary  
relation .Supplier, which will be subsequent ly  
res t r i c ted  to those tup les  Where Sct ty  is  equal to 
"London". S lml la r l~  $Var2 w i l l  be assoc ia ted  with a 
partial relation derived from Part, fo r  which the 
value of Colcur is " red" .  Evaluating the prcposltion 
(&supply SVarl $Var2). whose dcmain relationship Is 
mcdelled in the database by Shipments, will in the 
envlrcnment of $Varl and SVar2 yield the relational 
expression 
(jcin 
I select .Suppller where Seity equals "London") j91n Shlpmen~s 
~select Part where Colcur equals "red"))). 
At this point, the information that the user wants 
has been described in terms of the target relational 
database: names cf files, fields and columns. The 
search description has, however, still to be given 
the specific form required by the back-end database 
management system. This is achieved by a fairly 
straightforward app l i ca t ion  of standard ccmplling 
techniques, and does not deserve deta i led  discussicn 
here. At present we can generate search 
specifications in three different relational search 
languages. Thus the final form in the local search 
language Salt of the example question "Who supplies 
green parts?" is 
list (Part:Colour="green" 
? (Supplier ? Shipments)) 
87 
V IMPLEMENTATION 
Al l  o f  the modules have been implemented ( in  
LISP). The conver tor  i s  at  present  res t r i c ted  to 
re la t iona l  databases,  and we would l i ke  to extend i t  
to o ther  models .  The system has so fa r  been tes ted  cn 
Supp l ie rs  and Par ts ,  which i s  a toy  database  from the 
po int  o f  v iew o f  sca le  and complex i ty ,  but  which i s  
rich enough to allow questions presenting challenges 
tO the genera l  semantics approach to quest ion  
in terpretat ion .  To i l l us t ra te  the performance of  the 
f ront  end. we show below the query  representat ions  
and f ina l  search representat ions  fo r  some quest ions  
addressed to th i s  database.  Work is cur rent ly  in 
p rogress  to app ly  the f ront  end to a d i f fe rent  
( re la t iona l )  database conta in ing  p lann ing  
information: this simulates IBM's TQA database 
(Damerau 1980). Most of the work in this is likely to 
come in writing the lexical entries needed for the 
new vocabulary .  Longer term developments inc lude  
va l idat ing  each step o f  the t rans la t ion  by 
generat ing  back in to  Engl ish,  and extend ing  the 
f ront  end, and spec i f i ca l ly  the t rans la tor ,  w i th  an 
in fe rence  engine. 
C lear ly .  in the longer  term, database f ront  ends 
will have to be prov ided with an in ference  
capab i l i ty .  As Konol ige po in ts  out ,  in a t tempt ing  tc 
insu la te  users,  w i th  the i r  par t i cu la r  and var ied  
views o f  the domain c f  d i scourse ,  from the actua l  
admin is t ra t ive  organ isat lon  c f  the database,  i t  may 
be necessary to do an arb i t ra ry  amcunt c f  
inferenclng exploiting domain informaticn to connect 
the user 's  quest ion  wi th  the database. An obvious 
problem ~r~th f ront  ends not c lear ly  separat ing  
d i f fe rent  process ing stages is  that  i t  may be 
d i f f i cu l t  to handle in fe rence  in a coherent  and 
ccnt rc l led  way. Inso far  as i n fe rence  is  p r imar i l y  
domain-based, i t  seems natura l  in a modular f ront  end 
to prov ide  an in fe rence  capab i l i ty  as an extens ion  
of the translator. This should serve bcth tc Iccaliae 
inference operations and to facilitate them because 
they can work on the partially-processed input 
question, However the inference engine requires an 
ex pllclt and well-crganised domain model, and 
specifically one which is rather more comprehensive 
than current data models, or than the rather infcrmal 
nonce ptual schema we have used tc dr i ve the 
translator. 
We hope to begin work on providing an inference 
capability in the near future, but it has to be 
reccgnised that  even for the restricted task cf 
database access, it may prove impossible to confine 
inference operations to a single mcdule: dcing so 
would imply, for example, that compound nouns will 
generally only be partly interpreted in the analysis 
and extraction phases. Starting with inference 
limited to the translation mcdule is therefore 
primarily a research strategy for tackling the 
inference prcblem. 
? Green parts are supplied by which suppliers? 
+ query representation: 
(For_Every  $Var l /&supp l ie r  
:trot ~very SVar2/&part : (&colour SOar2 green) 
- (&supp ly  SOar1 SOar2)) 
-(Display SOar1 )) 
? search representation in ~uel: 
Range of Ol-varl is Part 
Range cf Ql-vsr2 is Supplier 
Range cf Ol-var3 is Shipments 
Retrieve i n to  Terminal (Ql -var2.Sname) 
where (O l -var l .Pnc  = Ql-varS.Pno) 
and (O l -var2 .Sn?  = Q l -var3 .Snc)  
and (Ql-varl.CoAcur : "green") 
? F rcm where does Blake operate?  
+ query representation: 
(For The SVar2 /&c i ty  
: (For  The SVar l /B lake  - (& l ive  SOar1 SOar2)) 
- (D isp lay  SOar2 )) 
+ search representat ion  in (~Jel: 
Range cf (Ql-varl) is (Supplier) 
Retrieve into Terminal (Ol-var1.Seity) 
where (Ol-varl.Sname : "Blake") 
? What is the status of the Paris par t  suppliers 
who supply blue parts? 
? query representation: 
(For Every $Var l /&supp l ie r  
:(AND 
For Some SVar2/&part  - (&supply SOar1 SOar2)) 
For The SVar3 /Par i s  - (& l ive  SOar1 SOar3)) 
For Every SVarU/&part 
:(&cclour $Var~ blue) 
- (&supp ly  SOar1 $Varq) ) )  
-(Display (&atatus SOar1) )) 
+ search representation in Ouel: 
Range of Ql-varl is Part 
Range cf Ql-var2 is Supplier 
Range cf Ol-var3 is Shipments 
Retrieve into Terminal (Ql-var2.Status) 
where (Ol-var1.Pno = Ql-var3.Foo) 
and (Q l -var2 .Sno  Ql-var3.Snc) 
and (Ql-var2.Scity : "Paris") 
and (Ol-var1.Cclcur = "blue") 
VI CONCLUSION 
The project results so far suggest that 
developing a natural language front end tc databases 
based cn a general semantic anal yser which 
constructs rich and explicit meaning representations 
offers distinct advantages in at least two respects: 
it makes all subsequent prccessing cleaner than 
would be the case with a representation dominated by 
ccnventicnal syntax, and enhances portability by 
encouraging the declarative description cf domain- 
specific ~ncwledge. 
VII REFERENCES 
Boguraev, EK. "Automatic resolution of linguistic 
ambigulties", Technical Report No.11, Computer 
Laboratory, University of Cambridge, 1979. 
Boguraev, B.K. and Sparck Jones, K. "A natural 
language anal  yser fo r  database access" ,  
Information Technology: Research and Development, 
1, 23-39, 1982. 
Bronnenberg, W.j.H.J. et  a l .  "The quest ion  answer ing 
system PHLIQAI", in Natura l  language quest i cn  
answerln~ systems (Ed. BOle), L~ndon: Macmillan. 
1979. 
Damerau. F.J. "The transformational question 
answering (TQA) system: description, operating 
experience, and implications", Report RC8287, IBM 
Thomas J. Watson Research Center, Yorktown 
Heights, N.Y.. 1980. 
Date, C.J. An introduction to database s~rstems, 
Reading, Mass.: Addison-Wesley, 1977. 
Grcsz~ B. et al "DIALOGTC: a core natural-language 
processing system", in  Proceedings cf the Ninth 
International Conference on Computational 
Linguistics, Prague, 1982. 
Hendrix, D.G. et ai. "Developing a natural language 
interface to complex data", ACM Transactions cn 
Database Systems, 3, 105-147, 1978. 
Konolige \]L "A framework for a portable natural- 
language inter face to large data bases", 
Technical Note 197, Artificial Intelligence 
Center, SRI I n ternat iona l .  1979. 
Waltz, IX "An English language question answering 
system for a large relational database" ,  
Communications cf the ACM, 21, 526-539, 1978. 
Warren, D.H.D. and Pereira, F.C.N. "An efficient easily 
adaptab le  system for interpreting natural 
language queries", Research Paper 155, Department 
cf Artificial Intelligence, University cf 
Edinburgh, 1981. 
Wilks, Y. "An intelligent anall~ser and understander 
cf English", Communications cf the ACM, 18, 26~- 
27~, 1975. 
Wccds, WJ. "The lunar  sc iences natura l  language 
information system", Final Report, Bolt, Beranek 
and Newman Inc.. Cambridge, Mass., 1972. 
Woods, W.A. "Semantics and quantification in natural 
language question answering", Advances in 
Computers, 17, 1-87, 1978. 
88 

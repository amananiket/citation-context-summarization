Morphonology in the Lexicon 
Lynne J Cahi l l *  
School of Cognit ive and Comput ing  Sciences 
Univers i ty of Sussex, Br ighton BN1 9QH, England 
Emaih lynneca@cogs.susx.ac.uk 
Abst rac t  
In this paper we present a means of defin- 
ing morphonological phenomena in an in- 
heritance based lexicon. We make use 
of the theory behind the formal language 
MOLUSC, in which morphological lterna- 
tions were defined as mappings between se- 
quences of tree-structured syllables. We 
discuss how the alternations can be defined 
in the inheritance-based l xical representa- 
tion language DATR, and how the phono- 
logical aspects can be built upon to bring 
it closer to an integrated lexicon with rep- 
resentations which can be used by both the 
morphology and phonology of a language. 
1 In t roduct ion  
The use of inheritance mechanisms in computational 
linguistics has become wide-ranging, with applica- 
tions in semantics, yntax, morphology and phonol- 
ogy. In this paper, we shall examine the applicability 
of such mechanisms to phonological spects of mor- 
phology. 
The inheritance-based lexical representation lan- 
guage, DATR, has become widely used for vari- 
ous aspects of linguistic description, and previous 
treatments of both morphological and phonologi- 
cal phenomena in DATR have shown its applica- 
bility to this area, both for its handling of inher- 
itance by default, and for its ability to define hi- 
erarchical structures. For example, \[Gibbon, 1990\] 
describes how Kikuyu tone displacement and Ara- 
bic non-concatenative morphology can be defined in 
*Thanks are due to Roger Evans and Dafydd Gibbon 
for comments  on previous drafts of this paper. 
DATR and \[Reinhard, 1990\] describes a hierarchical 
approach to German umlaut. In this paper we as- 
sume a knowledge of DATR and refer the reader to 
the introductions in \[Cahill and Evans, 1990\] and 
\[Evans and Gazdar, 1990\]. 
MOI_USC (\[Cahill, 1990a\],\[Cahill, 1990b\],\[Cahill 
and Gazdar, 1990\]), is a formal language for defin- 
ing morphological ternations as mappings between 
sequences of tree-structured syllables. It is based on 
the theory that (many) morphological lternations 
are phonologically based, and can best be described 
as operating on hierarchical structures, such as the 
syllable. However, there are fundamentally linear as- 
pects of morphological alternations, which require 
reference to concepts uch as "initial", "final" and 
"penultimate". 
An account of English verbal morphology was dis- 
cussed in \[Cahill, 1990b\] which was expressed in a 
combined DATR/MOI_USC lexicon fragment. The 
morphological distribution was defined by the DATR 
while the morphological realisation was defined by a 
set of MOIUSC functions. In this paper, we discuss 
an account derived from this (see appendix), which 
expresses the distribution of alternations involved in 
the same underlying way, but which does not require 
a separate language to define them. In doing this, we 
can reduce the two-tiered DATR/MOLUSC approach 
originally used, to a single-tiered account. This has 
the obvious advantage of reducing the "mechanisms" 
needed. More importantly, however, we shall demon- 
strate, with discussion of how the morphonological 
information may be generalised to be more useful to 
the phonology proper, it also has the advantage of 
moving the account owards a fully-integrated lex- 
icon, in which ultimately all levels of description - 
morphology, phonology, orthography, syntax, seman- 
tics - are combined. 
87 
In the following sections we shall consider the 
structures involved and how they may be defined in 
DATR, considering how to model both the precise 
structures used by MOLUSC and more generally use- 
ful phonological structures. We shall then consider 
how we might define the alternations. Finally, we 
shall discuss the advantages of this approach over 
previous descriptions of such phenomena s well as 
over the original MOLUSC language. 
2 Phono log ica l  S t ructures  
In many previous approaches to morphology, partic- 
ularly in the English-dominated NLP community, it
was assumed that morphology consisted fundamen- 
tally of "sticking together" morphemes, and making 
the necessary adjustments to allow for spelling pe- 
culiarities. \[Cahill, 1990b\] suggested that this was 
too narrow a view, even for the rather impover- 
ished inflection displayed by English. That there are 
several subclasses of English verbs which inflect by 
means other than affixation (e.g. "bring"- "brought" , 
"sit"- "sat" ) would seem to be a strong argument in 
itself, but looking at other languages uch as the 
Semitic languages hows that there is an enormous 
body of interesting morphological phenomena which 
needs to be addressed. \[Cahill, 1990b\] showed that a 
view of morphological lternations as mappings be- 
tween tree-structured syllables permitted a natural 
and succinct way of defining such Mternations. It 
also showed that levels of structure above the level of 
the syllable, while clearly vital for phonological de- 
scription, were not necessary for morphological de- 
scription. Thus the approach used structures which 
consisted only of linear sequences of tree-structured 
syllables. 
The question of structure above the level of the 
syllable is an interesting one. The use of metrical or 
tonal structure is clearly relevant o the phonology 
of a language, but it is debatable whether it has any 
place at all in the lexicon. While certain metrical no- 
tions such as stress are relevant o the lexicon (con- 
sider the noun-verb alternation "re'ject"-"'reject"), 
the actual metrical structure of even a polysyllabic 
word is dependent on the context in which it appears. 
Thus, it would seem reasonable to assume that the 
lexicon specifies the actual evel of stress on each syl- 
lable of a word 1 but that the structure derived from 
this is extra-lexical. 
In the two-tiered DATR/MOLUSC lexicon, the 
phonological structures were assumed to be defined 
fully at each lexical entry. This meant that we 
could not make use of the inheritance mechanisms 
in DATR, even though the structures lent themselves 
to such definition. In the present work we shall define 
the structures hierarchically in DATR, thus avoiding 
1There is an issue of how many levels we may want 
to differentiate in the lexicon, but it is not one which we 
propose to address in the current work. 
redundancy and enabling generalisations about the 
structures which were previously impossible. 
The formal semantics of MOLUSC (\[Cahill and 
Gazdar, 1990\]) defined the structures as having sets 
of feature definitions at each node. Although this 
facility was not used in the examples provided nor 
in the implementation, it is an aspect of the theory 
which we shall build upon in the current work. 
2.1 Trees  
In the first instance, let us consider the simple situ- 
ation, where there are onset, peak, coda and rhyme 
nodes which consist of (sequences of) phonemes. A 
simple mono-syllabic root may be defined in DATR 
by the following: 
Word: <root> == ( "<onset>"  "<rhyme>")  
<rhyme> == ("<peak> . . . .  <coda>") 
<onset> == 0 
<peak> == 0 
<coda> == 0 .  
Here the root is said to consist of an onset and 
a rhyme (which are provided at the original query 
node), and a rhyme (if not explicitly defined at the 
query node) consists of a peak and a coda. The on- 
set, peak and coda are by default 0. Now we can 
define the root "spell" as follows: 
Spell: <> == Word 
<onset> == (s  p )  
<peak> == e 
<coda> == 1 .  
The structure is inherited from the Word node, with 
just the values of the onset, peak and coda defined 
at the node Spe l l  2. 
In our example theory defining a fragment of the 
English verb system, we only have mono- and di- 
syllabic roots to contend with, but we need to con- 
sider how to handle a root consisting of an arbitrary 
number of syllables. We need to allow for a poten- 
tially infinite number of syllables in a root, but we 
also need each syllable in a root to maintain its own 
identity so as to permit both the definition of the 
values of the onset, peak and coda of the individual 
lexemes, and to allow for the definition of alterna- 
tions in particular syllables. In MOLUSC this was 
achieved by means of a simple numbering convention 
where +N referred to the Nth syllable from the left 
and -N referred to the Nth syllable from the right. 
In our DATR-only account, we achieve the linear 
structures by means of a path prefix "struct", and by 
defining the number of syllables in a root at its own 
lexical entry by means of a sequence of symbols -
one for each syllable more than one. In the example 
below, we use the term "ext" (for "extension") to 
denote each syllable above one. Thus, a disyllabic 
root could be defined by the line: 
2The brackets around the s p are just for the benefit 
of DATR. They are removed in the final result. 
88 
<sylls> == ext 
and a tri-syllabic root: 
<sylls> == (ext ext) 
and so on. At a higher node (in our case, "VERB") 
we can then define the structure of a root with the 
following: 
<root> == <struct "<sylls>"> 
<struct ext> == (<struct> "<syll ext>") 
<struct> == <syll> 
<sy11> == ("<onset> .... <rhyme>") 
Let us run through how this works by looking at 
the example of a tri-syllabic root which does not 
have values for any <sy11> paths defined at its 
node, so we can ignore the quotes on the <syl l> 
paths. A tri-syllabic root will have the value (ext  
ext) for the path <sylls> at its own entry, so 
the first line defines the root in this case to be 
<st ruct  ext  ext>. The second line defines the 
value for the path <st ruct  ext>, and this is the 
closest match for the path we want to evaluate. It is 
defined to be the list (<st ruct  ext> "<sy l l  ext 
ext>") ,  as the extra "ext"from the path we are 
evaluating ets added to any paths to be evaluated 
on the right hand side. Taking the second part 
of this first, <sy l l  ext ext>, assuming it isn't ex- 
plicitly defined at the word's entry, is defined as 
("<onset ext ext>" "<rhyme ext ext>"). This 
again is because we carry over the extra elements 
from a left-hand side path to the right-hand side. 
The path <st ruct  ext> is defined explicitly as 
(<st ruct> "<sy l l  ext>") ,  and <st ruct> is de- 
fined as being the same as <sy11>. The derivation 
can be viewed as follows~ with the numbers of the 
lines from which values are derived in brackets: 
<root> == <st ruct  ext  ext> (1) 
<struct ext ext> == (<struct ext> 
"<syll ext ext>") (2) 
<struct ext> == (<struct> "<syll ext>") (2) 
<struct> == <sy11> (3) 
<sy11> == ("<onset> .... <rhyme>") (4) 
-> <struct ext> == (("<onset>" "<rhyme>") 
"<syll ext>") 
<syll ext> == ("<onset ext>" 
"<rhyme ext>") (4) 
-> <struct ext> == (("<onset>" "<rhyme>") 
("<onset ext>" 
"<rhyme ext>") ) 
-> <struct ext ext> == (("<onset>" 
"<rhyme>") 
("<onset ext>" 
"<rhyme ext>") 
"<syll ext ext>") 
<syll ext ext> == ("<onset ext ext>" 
"<rhyme ext ext>") (4) 
-> <struct ext ext> == (("<onset>" 
"<rhyme>" ) 
("<onset ext>" 
"<rhyme ext>") 
("<onset ext ext>" 
"<rhyme ext ext>")) 
-> <root> == (("<onset>" "<rhyme>") 
("<onset ext>" "<rhyme ext>") 
("<onset ext ext>" 
"<rhyme ext ex~>")) 
The root which results is therefore, 
("<onset>" "<rhyme>" 
"<onset exl;>" "<rhyme ext>" 
"<onset ext ext>" "<rhyme ext ext>") 
so that we can refer to the initial syllable and its 
constituents with paths without any "ext"s, the sec- 
ond syllable and its constituents with paths with one 
"ext" suffixed and so on. 
The idea of having to define the number of sylla- 
bles in a root at each lexical entry may seem a little 
undesirable, but we will need to define each syllable 
separately at the entry anyway, so the explicit in- 
formation of how many syllables there are is a very 
small cost. In addition, since in our example frag- 
ment below most roots are monosyllabic anyway, this 
will not have to be defined for each entry. We can 
have a default value for <sylls> at the VERB node of 
"( )" .  Although this is a language specific advantage, 
it is expected that it would not often be necessary to 
define polysyllabic roots for any language, since very 
long words will usually be made up of either com- 
pounded roots (as happens frequently in German) 
or a single root plus several affixes (as happens in 
agglutinative languages uch as Turkish). 
The structures as defined above allow us to refer 
to an individual syllable provided we know its po- 
sition from the left. But if we want to refer to the 
last syllable in a root, for example, we need to know 
how many syllables are in each root, thus preventing 
us from making generalisations over classes of verbs 
which do not all have the same number of syllables. 
This is clearly undesirable, but it can be avoided. In 
the example of English verbs, it is a feature of the 
verb roots that while most roots are monosyllabic:. 
those which are not only require reference to their 
final syllable, never their initial syllable. We there- 
fore want to reverse the structure definition above, 
which can be very simply achieved by reversing the 
order of the paths <st ruct> and "<sy l l  ext>" in 
the list on the right-hand side of the second line 3. 
What this means is that we must define for each lan- 
guage or language fragment (it may be different for 
nouns and verbs, for example) whether any alterna- 
tions take place at the right- or left-hand end of the 
root. It is possible to refer to a syllable any num- 
ber in from either side, not just the initial or final 
Sin our example fragment, we have replaced the term 
"ext" with "pref" to reflect he fact that it is prefixing 
which extends the structure. The actual term used is, of 
course, irrelevant. 
89 
and any form or set of forms which show a devia- 
tion from the norm can be accommodated in DATR 
simply by means of overriding structure definitions 
at a lower node in the hierarchy. However, the def- 
inition of structure at the higher node(s) make for 
a generalisation about the set of forms covered by 
that node. This is in marked contrast o MOLUSC, 
which permitted equally easy reference to either end, 
and even permitted mixing within a single alterna- 
tion definition. MOLUSC was much too powerful in 
this respect, and permitted the definition of alterna- 
tions which do not occur in any language, so this is 
clearly a desirable restriction. 
2.2 Segments within onset, peak and coda  
As well as accessing syllables within a sequence, MO- 
LOSC permitted the accessing of segments within the 
onset, peak and coda in a similar way. Although we 
do not want to go into detail here, as we do not pro- 
pose to ultimately use discrete segments, we can do 
the same in the DATR framework outlined above, by 
means of a similar mechanism to that used for sylla- 
bles. Again, we need to decide whether we want to 
extend leftwards or rightwards, and this again gives 
us a highly desirable restriction, which in this case 
we can use to restrict onsets to extend rightwards 
and codas to extend leftwards. Thus, we may refer 
to initial, second etc. segments within the onset and 
final, penultimate etc. segments within the coda but 
not vice versa. Of course, DATR itself does not force 
such restrictions, but the framework we have defined 
forces the lexicon writer to decide on how to apply 
the restrictions. 
2.3 Phonological features  
As mentioned above, we have used segments in the 
examples given so far for clarity of explanation. In 
MOLOSC and in the current work we intend the real 
unit of description to be the phonological feature or 
event rather than the segment. Much recent work, 
both computational and theoretical, has shown that 
the use of such units permits a more accurate, and 
above all, a declarative description of phonological 
phenomena such as ellision, epenthesis and assimila- 
tion (e.g. \[Coleman, 1992\], \[Bird and Klein, 1990\]). 
As mentioned above, \[Cahill and Gazdar, 1990\] de- 
fined a formal semantics for the MOLOSC language 
which permitted the definition of phonological fea- 
tures at any level in the structure, although the im- 
plementation a d examples did not make use of fea- 
ture definitions except at terminal nodes. Thus, the 
segment labels below the onset, peak and coda nodes 
were deemed to be abbreviations for a set of fea- 
tures, any one or more of which could be altered 
by a morphological lternation. It is possible to 
talk about inheritance of phonological features up 
or down the tree. For example, a \[+ voice\] fea- 
ture at a rhyme node may be considered to be in- 
herited by the peak and coda nodes below it, so that 
any segments within either of those two will contain 
the feature \[+ voice\]. Alternatively, the value of a 
coda node (null or non-null) may be inherited by the 
rhyme and syllable nodes above it in order to spec- 
ify stress vMues which may be affected by whether a
syllable is "open" or "closed". 
In the account we are proposing here, we only re- 
quire the latter type of inheritance, where the higher 
nodes inherit features from the lower nodes. This is 
because we are advocating an approach to phonology 
like that proposed by \[Bird and Klein, 1990\], \[Cole- 
man, 1992\]. In both of these approaches, phonologi- 
cal features consist of a feature (or "event") name, a 
value for that feature and an argument which defines 
how it relates temporally to the other features in the 
word 4. Thus, for example, in the word "bat" there 
may be features uch as \[+ vo ice \ ] ,  \[+ l ab ia l \ ] ,  \[+ 
alveolar\ ] ,  \[+ consonant\] and \[+ vowel\] amongst 
others 5. The voice feature would have a temporal ar- 
gument which expressed the fact that it lasts for the 
entire word, the labial feature would be defined as 
lasting for some time from the beginning of the word 
until the onset of the vowel feature and the alveolar 
feature would be defined as commencing at the end 
of the vowel feature and ending at the end of the 
word. Of course, this is very approximate, but it is 
intended only to give the flavour of the treatment. 
In an account of this nature, it is not necessary for 
the features at higher nodes to be "trickled" down 
to lower nodes, since the temporal arguments define 
how they relate. However, that is not to say that 
the structure is unimportant. Both of the theories 
from which we are borrowing here make use of the 
notion of a tree-structured syllable, and phonological 
restrictions are defined as holding within such struc- 
tures. In particular, from the point of view of the 
current account, reference to parts of the structure 
is necessary for the definition of morphological lter- 
nations (see below). In our definition of the structure 
given above, the result is a simple list (of segments 
in the example we gave). If we use features instead 
of segments, the same result is achieved, but insteaxi 
of a list of segments, considered to be temporally or- 
dered, we end up with a list of features, not tempo- 
rally ordered, but with explicit temporal arguments 
defining their relationship to each other. 
2.3.1 The features and the i r  a rguments  
Although we will not be using segments, we main- 
tain the notion of segmental units in the temporal 
4\[Bird and Klein, 1990\] does not use features in this 
form exactly, but the notion of temporal relations be- 
tween the events is vital to their account 
5It is important to note here that in this and all subse- 
quent examples of actual phonological features, no claim 
is being made as to the accuracy of the actual features 
used. They axe meant purely to demonstrate the applica- 
bility of the framework to (morpho)phonological descrip- 
tion and not to demonstrate a full phonological theory. 
90 
arguments in our examples below. We argue that 
segments, although possibly unnecessary in strict 
phonological terms, do seem to have a role at some 
level. The very fact that our writing system makes 
use of segment-type units appears to be an argument 
in favour of maintaining their existence at some level, 
and in morphological terms it is clear that many al- 
ternations eem to require reference to such units. 
For example, the English alternation "bend"-"bent" 
can be defined as an alternation i  the voicing feature 
of only the final segment of the coda. We are there- 
fore assuming timing boundaries at what would have 
been segment boundaries. Thus the word "spell" is 
assumed to have four "timing sections", one for each 
of the conventional segments. The stem "spell" can 
thus be redefined as follows: 
Spell: <> == VERB 
<rhyme_feats> == (\[ + voice 2-4 \]) 
<onset> == (\[ - voice 0-2 \] 
\[ + s ibi lant 0-I \] 
\[ + a lveolar  0-I \] 
\[ + stop I-2 \] 
\[ + labial  I-2 \]) 
<peak> == (\[ - round 2-3 \] 
\[ - h igh 2-3 \] 
\[ - low 2-3 \] 
\[ + front 2-3 \]) 
<coda> == (\[ + lateral  3-4 \]). 
The third element in each list is a (very simple) 
temporal argument. The sibilant feature, for exam- 
ple, lasts from 0 to 1, i.e. the first "segmentsworth"; 
the approximant feature of the onset goes from 1 to 
2, i.e. the second "segmentsworth"; the voice feature 
of the onset covers the whole two segmentsworth of 
the onset. These are of course extremely simplified, 
both in the definition of the temporal arguments, 
and in the descriptions of the features themselves. 
But the theories from which we are borrowing have 
plenty to say about these aspects of phonology which 
is not relevant o how it might be expressed in a 
DATR lexicon combining phonological and morpho- 
logical description. Note that in the example above, 
since we have temporal arguments, it is possibly not 
necessary to differentiate he rhyme features (just the 
voicing feature in the above example) from syllable 
features. We can have the feature \[ + voice 2-4 \] 
defined at either the rhyme or syllable node. Since 
all rhyme features are inherited by the syllable, it 
will only be relevant o make the distinction if an 
alternation requires reference to the rhyme features 
specifically. However, it is more accurate to maintain 
the distinction, and so we shall do so. 
2.3.2 Inher i t ing  feature  arguments 
The description above requires that every feature 
for which we want to define a value in a stem must be 
explicitly defined. In addition, every value for every 
feature must be explicitly defined. There is no room 
for a marked/unmarked distinction, for example. In 
doing this, we are not making use of DATR's default 
inheritance mechanisms to define default values for 
features. What we can do to improve on this situ- 
ation is to define a set of features for which a value 
and a timing must be given (although the value may 
be "undef" or some such), and provide default values 
for each feature at a very high node. 
The set of features we have chosen are not intended 
to be comprehensive or even necessarily consistent, 
but are simply those sufficient o describe the stems 
and alternations involved in our example fragment. 
The feature set is as follows: 
alv = a lveolar  
approx = approximant  
fr ic = f r icat ive 
high = high 
lab = labia l  
lat = latera l  
low = low 
nasal  = nasal  
round = round 
sib = s ib i lant  
stop = stop 
vel = velar  
voice = voice 
The default value for all features is "-" and the de- 
fault timing is r l ,  for "root length" - i.e. the whole 
length of the root. 
The definition of the structure of a stem (i.e. the 
number of syllables) is as before, but the definition of 
a syllable needs to take into account he fact that we 
are now dealing with lists of features and their val- 
ues and timings, rather than linear sequences of seg- 
ments. Since we are going to permit the permeation 
of features up the tree, we want the syllable node to 
contain all of the features for the onset and rhyme 
nodes, and the rhyme node to contain all of the fea- 
tures for the peak and coda nodes. One consequence 
of this is that we cannot simply allow the definition 
of features hared by say the peak and coda nodes at 
the rhyme node, since they will not then be inherited 
downwards, and any alternation which is dependent 
on the value of a feature at the coda node will need 
to look at the rhyme and syllable nodes' features, 
taking the timings into account as well. It would un- 
doubtedly be possible to get around this problem but 
for our present purposes the extra cost of defining a 
shared feature at both nodes which share it is not a 
problem. 
The feature sets can be defined as follows: 
<syl l> == (\[ <feats syl l> \] 
\[ <feats onset> \] 
\[ <rhyme> \]) 
<rhyme> == (\[ <feats rhyme> \] 
\[ <feats peak> \] 
\[ <feats coda> 3) 
The paths are not quoted in this because we want the 
actual feature set to be defined at the top node, with 
91 
just the values and timings defined at the terminal 
nodes. Thus, the feature set can be defined: 
<feats> == ( 
\[ alv "<val alv>" "<time alv>" 
approx "<val approx>" "<time approx>" 
f r ic  "<val  f r i c>"  "<t ime f r ic>" 
high "<val high> . . . .  <time high>" 
lab "<val lab>" "<time lab>" 
lat "<val lat>" "<time fat>" 
low "<val low>" "<time low>" 
nasal "<val nasal>" "<time nasal>" 
round "<val round>" "<time round>" 
sib "<val sib>" "<time sib>" 
stop "<val stop>" "<time stop>" 
vel "<val vel>" "<time vel>" 
voice "<val voice> .... <t ime vo ice>" \]) 
Then to find the set of features at the peak node, 
for example, the word peak is appended to all of the 
(quoted) paths in the feature list, thus evaluating 
the val and time for each feature at that node. The 
paths: 
<val> == - 
<time> == rl 
then define default values for the val and time paths. 
With these definitions, we can define a stem by sim- 
ply providing values for all those features which have 
the value ,,+,,6 and times for these. The example 
stem "spell' can therefore be defined as: 
Spell: <> == VERB_A 
<val  s ib onset> == + 
<val lab onset> == + 
<val stop onset> == + 
<val  f ront  peak> == + 
<val  vo ice  peak> == + 
<val  lat coda> == + 
<val  voice coda> == + 
<time sib onset> == 0-1 
<time lab onset> == 1-2 
<time stop onset> == 1-2 
<time front peak> == 2-3 
<t ime vo ice peak> == 2-3 
<t ime voice coda> == 3-4 
<time lat coda> =- 3-4. 
Although the timings we are using here are extremely 
approximate, they can provide a starting point for 
phonological/phonetic systems, such as YorkTalk 
(\[Coleman, 1992\]). The YorkWalk system defines 
phenomena such as epenthesis as adjustments in the 
timings of such features, so as to blur the bound- 
aries between "segment" sections. For example, the 
epenthesis which occurs in words such as "mince" 
(/mints/) is a result of the fact that the closure as- 
pect of the nasa l /n / i s  carried over to the non-nasal 
eWe are using simple boolean valued features here, 
but this is not a restriction. Multi-valued features, such 
as stress (see section 2 above), can be just as easily 
accommodated. 
/s/, resulting in a / t / sound.  This type of phonolog- 
ical phenomenon is not something we would expect 
to be represented in the lexical entry for the word 
"mince", but having approximate, relative timings of 
the features gives a system like YorkTalk something 
with which it can work more easily than simple seg- 
mental structures. They also eliminate the need to 
refer to individual segments within onset, peak and 
coda. The stem "bend" for example has a coda which 
consists of an "n" and a "d" (in conventional terms). 
This can be expressed in our account by the features 
voice, alveolar, nasal and stop having the value "+" 
in the coda, but with the following timings: 
<t ime vo ice  coda> == 2-4 
<time nasal coda> == 2-3 
<time alv coda> == 2-4  
<time stop coda> == 3-4 
The voice and alveolar features carry across the 
whole coda, but the nasal feature is only on the first 
section and the stop feature is only on the second. 
There would appear to be a problem here, result- 
ing from the decision to only allow inheritance offea- 
tures up the tree, in that it is possible for a feature 
at a particular node to be given a value at that node 
but a timing which only covers part of the node. For 
example, the stem "swell" has an onset whose voice 
feature has the value "-" for the first section and 
"+" for the second section. However, as we noted in 
the example of "spell" above, it is possible for the 
syllable node to contain features whose temporal ar- 
guments do not cover the whole syllable. Thus, the 
onset of "swell" would have a feature "f-  voice\]" 
which has the timing "0-1" and the syllable node 
would have the feature "\[+ voice\]",  with the tem- 
poral argument "1-4". 
3 Morpho log ica l  A l te rnat ions  
Let us momentarily return to the use of segments for 
clarity, and consider how to define alternations be- 
tween forms. In our example case of English verbs, 
most of the inflections take the form of suffLxation, 
which can be defined trivially. For example, the 
present participle form might be defined: 
<pres par t> == ("<root  pres>"  ing) 
(with the suffix itself having its structure defined 
- we are not concerned with that here). What is 
more interesting, however, is the definition of alter- 
nations uch as that in the forms "bereave"-"bereft", 
"cleave'-"cleft". Such verbs, although only in small 
groups, do exhibit consistent, phonologically deter- 
mined, but not strictly phonological, alternations. In
MOLUSC, these could be defined by means of func- 
tions such as the following: 
\[(peak,-1)/ii/:=~/e/\] 
\[(coda,-1,-1)/v/=~ If/\] 
\[(coda,-1,-l)\[+ voice\] :=~ \[- voice\]\] 
92 
There are two aspects to these alternations. On 
the one hand, defining the alternation between, say, a 
peak o f / i i /w i th  a peak o f /e / i s  extremely straight- 
forward, simply requiring path extensions to the 
"<peak> ''7 definitions for past and present. Thus, 
the following would define the alternation: 
<peak pres> == ii 
<peak  past> == ? 
However, in the account of English verbs in \[Cahill, 
1990b\], such verbs were grouped together with a 
large number of other verbs which did not exhibit 
this precise alternation, with the peak alternation 
being dependent on the original peak. Thus, the past 
tense peak i s /e / i f  the present ense peak i s / i i /and  
the same as the present ense peak otherwise. 
3.1 Def in ing context -dependent  
a l te rnat ions  
We can define this type of context-dependent alter- 
nation in our framework by evaluating the present 
tense value for the peak and using that as an argu- 
ment in a path for defining the past tense peak. The 
code for this is: 
<peak past> == <peak_change "<peak pres>"> 
<peak_change ii> == ? 
<peak_change> == "<peak pres>" 
This says that the peak of the past tense root 
(<peak past>) is found by evaluating the path which 
has the word peak_change followed by whatever the 
value of the present ense peak is ("<peak pres>").  
If this results in the path <peak_change i i> (i.e. if 
the present tense peak is "ii") then the past tense 
peak is "e". In any other case (the path with the 
present peak value unspecified) the past tense peak is 
the same as the present ense peak ("<peak pres>").  
3.2 Def in ing feature  value a l te rnat ions  
The coda change function is given in MOLUSC in two 
different forms - one with segments and the other 
with features. The version with segments can, unsur- 
prisingly, be defined in exactly the same way as the 
peak change above. Let us consider the alternation 
defined as an alternation in the value of the voicing 
feature. The voicing feature of the set of verbs we 
are talking about is altered if the final segment of 
the coda is either a labial fricative ("v") or an alve- 
olar stop ("d"). There are therefore four features in 
whose values we are interested: lab, f r ic ,  a lv  and 
stop. We can define the value of the voicing feature 
of the coda in the past tense form to be dependent 
on the values of all four of these features: 
<val voice coda past> == 
<coda_change "<val fr ic coda pres>" 
~This is the peak of the final syllable in all cases. We 
have already discussed above how to define roots as ex- 
tending from either the right or the left, and we assume 
here that the roots all extend from the right. 
"<val lab coda pres>" 
"<val stop coda pres>" 
"<val alv coda pres>"> 
and we can define the actual value simply by means 
of the following two DATR sentences: 
<coda_change + +> = =  - 
<coda_change - - + +> == - 
The first says that, if the values of both the f r i c  
and lab features are "+" then the vo ice feature has 
the value "-", regardless of what the values of the 
stop and a lv  features are. The second says that if 
the f r i c  and lab features both have the value "-" 
and the stop and s ly  features both have the value 
"+" then the value of the vo ice feature is "-". Note 
that the asymmetry is necessary but insignificant. It 
is not possible to define the alternation so that it is 
unimportant what the values of either the f r i c  and 
l ab  features or the stop and a lv  features are, but 
it should be clear that in a consistent phonology, it 
would not be possible to have both the f r i c  and 
stop features having the value "+" and even if it 
were possible to have the a lv  and lab features with 
the value "+", it is highly unlikely that it would af- 
fect such an alternation. That is to say, in the exam- 
ples of alternations we have looked at, such conflicts 
have never arisen. 
Two more alternations which can interestingly be 
handled very neatly in this framework are the sibi- 
lant/voice and alveolar/voice dependent "s" and "d" 
suffixes in English. The plural noun and present 
tense third person singular verb suffixes in English 
both have three realisations: / i z /a f ter  sibi lants,/s/ 
after unvoiced non-sibilants and/z /a f te r  voiced non- 
sibilants. Traditionally this is defined with rules such 
as,  
S ~/ i z / / \ [+  sib\] _ 
s - .  I s / / \ [ -  voice\] _ _  
S - -+/z / / \ [+  voice\] __  
where the first rule must apply before the other two. 
Alternatively, the feature \[- sib\] must be specified in 
the second and third rules in order to eliminate the 
need for ordering. In our account, we can define th is  
alternation declaratively and succinctly. As with the 
coda voicing alternation described above, we need to 
evaluate a path which contains values of features - 
in this case the s ib  and vo ice features. The present 
tense third person singular form is defined as: 
<pres th i rd sing> == 
("<root pres>" <ssuff  "<val sib coda>" 
"<val voice coda>">) 
and the value of the suffix ("ssuff") is defined very 
simply with the following linesS: 
<ssuff +> == iz 
<ssuff - +> == Z 
<SSUff -> == s 
8We have left the suffix forms as segments rather than 
expanding them out to features for simplicity. 
93 
This says that if the value of the sib feature is "+" 
then the ssuff is "iz", regardless of what the value 
of the voice feature is, and if the sib feature has 
the value "-" then the ssuff is "z" if the voice fea- 
ture has the value "+" and "s" otherwise. We can 
do a similar thing for the past tense / id/ - /d/ - / t /  
suffix with the s ly  and voice features. This analy- 
sis permits us to define the alternation declaratively, 
and hence without anyneed for rule ordering, but we 
can specify one feature value less than is necessary 
to avoid ordering in the traditional description. 
4 Conc lus ions  
We have presented an approach to describing mor- 
phological alternations in the lexicon which combines 
linear and hierarchical notions, making use of the 
theory behind MOLUSC. Let us now consider the 
advantages of this approach, both over the MOLUSC 
language and over previous DATR approaches tosuch 
phenomena. 
MOLUSC defined all morphological lternations 
as mappings between linear sequences of tree- 
structured syllables, including affixation. This re- 
quired extending the numerical labelling to include 
+0 and -0 to represent the prefix and suffix slots. 
While this was a reasonable extension to permit he 
definition of all morphological alternations within the 
same framework, it ignored the obvious difference be- 
tween affixation and phonologically related alterna- 
tions. It also implied (although it did not require) 
that all affixes were monosyllabic. While this is very 
often the case, it is by no means always o (e.g. En- 
glish "ation", Latin "amus" etc.) and MOkUSC did 
not have anything to say about these. Equally, it did 
not permit compounding, since every morphological 
process had to involve a stem and an affix. 
In the account we have proposed here, we can have 
the best of both worlds. We can use the type of defi- 
nitions of alternations that MOIUSC used to handle 
the phonologically related phenomena, but we can 
leave the affixation and compounding to be treated 
as simple concatenation in DATR lists. 
The account proposed here also has the advantage, 
mentioned above, that certain types of alternation 
and structural definition are much harder to define 
than in MQLUSC. MOLUSC was noticably overpow- 
ered, permitting the definition of alternations which 
affected both the first syllable and penultimate coda, 
dependent on the value of the third onset, for exam- 
ple, a combination unlikely in the extreme. \[Cahill, 
1990b\] discussed some possible ways to restrict he 
language to have context dependencies adjacent o 
the alternation being defined and to only permit ref- 
erence to the initial, second, final and penultimate 
syllables, for example. Such restrictions are not en- 
forced by the account discussed above, but the kind 
of alternations which we would want to avoid are no- 
tably more difficult o define, which is in contrast to 
MOLUSC. 
The present account has much in common with 
that in \[Gibbon, 1990\], which provided accounts of 
Kikuyu tone displacement and Arabic binyan mor- 
phology. The account Gibbon gave of Arabic can be 
directly contrasted with the general approach pro- 
posed here. Gibbon, like most others, makes use of 
a C V template level, with the C and V slots be- 
ing filled by inheritance through a DATR lexicon. In 
our account, we can deal with the Arabic "template" 
morphology without he need for this extra layer, by 
using the syllabic structure. The vowels are defined 
simply to be the peaks of the first, second etc. syl- 
lables and the consonants are defined as the onsets 
and codas. An analysis along these lines using MO- 
LOSE was given in \[Cahill, 1990b\], and it could be 
translated into the framework described above in the 
same way as the English fragment has been. This 
would amount o a description very similar to that 
in \[Gibbon, 1990\], but the resultant form, instead 
of being simply a sequence of segments, would be 
a fully specified phonological structure of the type 
described above. Thus, the node for each triliteral 
root would define the three basic consonant feature 
sets, with the form for each binyan being defined as 
a syllable sequence, for which the onset and coda for 
each syllable would inherit from the root definition. 
The vowel alternations would be defined exactly as 
the peak alternations in the English example above. 
A small example DATR theory by Dafydd Gib- 
bon in \[Evans and Gazdar, 1990\] (pp. 99-100) also 
gives a small example of phonological underspeeifi- 
cation could be expressed in DATR. An interesting 
extension of the current work would be to attempt 
to integrate it with the definition of underspecified 
phonology given by Gibbon. 
The framework outlined here, then, permits the 
same intuitive description of morphonological alter- 
nations as did MOLUSC, but with the following ad- 
vantages: 
? it forces the lexicon writer to restrict, or at least 
guide, the types of alternations occurring in any 
language fragment; 
? it permits amore simple and intuitive treatment 
of concatenation; 
? it moves the theory closer to an integrated lex- 
icon - the output of the morphology is phono- 
logical representations which could be used by 
existing phonological theories and implementa- 
tions. 
Append ix :  The  DATR code  
VERB: 
<> == ()  
<root> == <struct  "<syl ls>"> 
<syl ls> == () 
<struct  pref> == ("<syl l  pref>" 
<struct>) 
<struct> == <syl l> 
94 
<sy11> == (\[ <feats sy11> J 
\[ <feats onset> \] 
\[ <rhyme> J) 
<rhyme> == (\[ <feats rhyme> \] 
\[ <feats peak> J 
\[ <feats coda> \]) 
<feats> == 
(\[alv "<val alv> . . . .  <time alv>" 
approx "<val approx> .... <t ime approx>" 
fr ic  "<val f r ic>" "<time fr ic>" 
h igh "<val h igh> . . . .  <time high>" 
lab "<val lab>" "<time lab>" 
lat "<val lat>" "<time lat>" 
low "<val low>" "<time low>" 
nasal  "<val nasal>" "<time nasal>" 
round "<val round>" "<time round>" 
sib "<val sib>" "<time sib>" 
stop "<val stop>" "<time stop>" 
vel "<val vel>" "<time vel>" 
voice "<val voice>" "<time voice>"\])  
<val> == - 
<t ime> == rl 
<pres> == "<root pres>" 
<pres part> == ("<root pres>" ing) 
<pres th i rd  sing> == ("<root pres>" 
<ssuff  "<val sib coda>" 
"<val voice coda>">) 
<ssuff  +> == iz 
<ssuff  - +> == z 
<ssuff  - -> == s 
<past> == ("<root past>" 
"<dsuff  "<val alv coda>" 
"<val voice coda>">") 
<dsuff  +> == id 
<dsuff  - +> == d 
<dsuff  - -> == t. 
VERB_A:  
<> == VERB 
<~eats peak  past> == <peak_change 
"<feats peak pres>"> 
<peak_change ii> == e 
<peak_change> == "<feats peak pres>" 
<val  voice coda past> == 
<coda_change "<val fr ic coda pres>" 
"<val lab coda pres>" 
"<val stop coda pres>" 
"<val alv coda pres>"> 
<coda_change + +> == - 
<coda_change - - + +> == - 
<coda_change> == "<val voice coda pres>" 
<dsuf f> == t. 
Spell: <> == VERB_A 
<val sib onset> == + 
<val lab onset> == + 
<val stop onset> == + 
<val front peak> == + 
<val voice peak> == + 
Live: 
<val lat coda> == + 
<val voice coda> == + 
<time sib onset> == 0-I 
<t ime lab onset> == i-2 
<time stop onset> == 1-2 
<time front peak> == 2-3 
<time voice peak> == 2-3 
<time voice coda> == 3-4 
<time lat coda> == 3-4. 
<> == VERB 
<val fat onset> == + 
<val voice onset> == + 
<val h igh peak> == + 
<val front peak> == + 
<val voice peak> == + 
<val voice coda> == + 
<val fr ic  coda> == + 
<val lab coda> == + 
<time lat onset> == 0-I 
<t ime voice onset> == 0-I 
<t ime 
<time 
<time 
<time 
<time 
<time 
h igh peak> == 1-2 
front peak> == 1-2 
voice peak> == I-2 
voice coda> == 2-3 
fr ic  coda> == 2-3 
lab coda> == 2-3. 
Bereave:<> == VERB_A 
<syl ls> == pref  
<val voice onset pref> == + 
<val lab onset pref> == + 
<val stop onset pref> == + 
<val front peak pref> == + 
<val voice peak pref> == + 
<feats coda pref> == 0 
<val voice onset> == + 
Bend:  
<val approx onset> == + 
<val h igh  peak> == + 
<val front peak> == + 
<val voice peak> == + 
<val voice coda> == + 
<val fr ic  coda> == + 
<val lab coda> == + 
<time voice onset pref> == 0-I 
<t ime lab onset pref> == 0-I 
<t ime stop onset pref> == 0-I 
<t ime front peak pref> == I-2 
<time voice peak pref> == I-2 
<time voice onset> == 2-3 
<time approx onset> == 2-3 
<time h igh peak> == 3-5 
<time front  peak> == 3-5 
<time voice peak> == 3-5 
<time voice coda> == 5-6 
<time fr ic  coda> == 5-6 
<t ime lab coda> == 5-6. 
<> == VERB_A 
95 
<val  vo ice  onset> == + 
<val  lab onset> == + 
<val  stop onset> == + 
<val  f ront  peak> == + 
<val  vo ice  peak> == + 
<val  vo ice  coda> == + 
<val  nasa l  coda> == + 
<val  alv coda> == + 
<val  stop coda> == + 
<t ime vo ice onset> == O-i  
<t ime lab onset> == 0-I 
<time stop  onset> == 0-I  
<time f ront  peak> == 1-2 
<t ime vo ice peak> == 1-2 
<t ime vo ice  coda> == 2-4 
<t ime nasa l  coda> == 2-3 
<time a lv  coda> == 2-4 
<t ime stop coda> == 3-4. 
editors, Lexicon und Lexicographie. Olms Verlag, 
Hildesheim, 1990. 
Re ferences  
\[Bird and Klein, 1990\] S. Bird and E. Klein. Phono- 
logical events. Journal of Linguistics, 26, 1990. 
\[Cahill and Evans, 1990\] Lynne J. Cahill and Roger 
Evans. An application of DATR: The TIC lexicon. 
In Proc. ECAI-90, pages 120-125, 1990. 
\[Cahill and Gazdar, 1990\] L. J. Cahill and G. J. M. 
Gazdar. The semantics of MOI.USC. In ECAI-90, 
pages 126-131, Stockholm, 1990. 
\[Cahill, 1990a\] L. J. Cahill. Syllable-based morphol- 
ogy. In COLING 90, volume 3, pages 48-53, 
Helsinki, 1990. 
\[Cahill, 1990b\] L. J. Cahill. Syllable-based morphol- 
ogy for natural language processing (DPhil Disser- 
tation). Technical Report Cognitive Science Re- 
search Report 181, Cognitive and Computing Sci- 
ences, University of Sussex, 1990. 
\[Coleman, 1992\] J. S. Coleman. Synthesis by rule 
without segments or rewrite rules. In C.Benoit 
and G.Bailly, editors, Talking Machines. Elsevier, 
1992. 
\[Evans and Gazdar, 1990\] R. Evans and G. Gazdar. 
The DATR papers. Cognitive science research re- 
port 139, Cognitive and Computing Sciences, Uni- 
versity of Sussex, 1990. 
\[Gibbon, 1990\] Dafydd Gibbon. Prosodic associa- 
tion by template inheritance. In Walter Daele- 
mans and Gerald Gazdar, editors, Proceedings of 
the Workshop on Inheritance in Natural Language 
Processing, pages 65-81. Institute for Language 
Technology, Tilburg, 1990. 
\[Reinhard, 1990\] S. Rein- 
hard. Verarbeitungsprobleme nichtlinearer Mor- 
phologien: Umlaut-beschreibung in einem hierar- 
chischen Lexicon. In B. Rieger and B. Schaeder, 
96 

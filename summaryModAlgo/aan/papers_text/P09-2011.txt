Proceedings of the ACL-IJCNLP 2009 Conference Short Papers, pages 41?44,
Suntec, Singapore, 4 August 2009.
c?2009 ACL and AFNLP
Incremental Parsing with Monotonic Adjoining Operation
Yoshihide Kato and Shigeki Matsubara
Information Technology Center, Nagoya University
Furo-cho, Chikusa-ku, Nagoya, 464-8601 Japan
{yosihide,matubara}@el.itc.nagoya-u.ac.jp
Abstract
This paper describes an incremental parser
based on an adjoining operation. By using
the operation, we can avoid the problem
of infinite local ambiguity in incremental
parsing. This paper further proposes a re-
stricted version of the adjoining operation,
which preserves lexical dependencies of
partial parse trees. Our experimental re-
sults showed that the restriction enhances
the accuracy of the incremental parsing.
1 Introduction
Incremental parser reads a sentence from left to
right, and produces partial parse trees which span
all words in each initial fragment of the sentence.
Incremental parsing is useful to realize real-time
spoken language processing systems, such as a si-
multaneous machine interpretation system, an au-
tomatic captioning system, or a spoken dialogue
system (Allen et al, 2001).
Several incremental parsing methods have been
proposed so far (Collins and Roark, 2004; Roark,
2001; Roark, 2004). In these methods, the parsers
can produce the candidates of partial parse trees
on a word-by-word basis. However, they suffer
from the problem of infinite local ambiguity, i.e.,
they may produce an infinite number of candidates
of partial parse trees. This problem is caused by
the fact that partial parse trees can have arbitrar-
ily nested left-recursive structures and there is no
information to predict the depth of nesting.
To solve the problem, this paper proposes an in-
cremental parsing method based on an adjoining
operation. By using the operation, we can avoid
the problem of infinite local ambiguity. This ap-
proach has been adopted by Lombardo and Sturt
(1997) and Kato et al (2004). However, this
raises another problem that their adjoining opera-
tions cannot preserve lexical dependencies of par-
tial parse trees. This paper proposes a restricted
version of the adjoining operation which preserves
lexical dependencies. Our experimental results
showed that the restriction enhances the accuracy
of the incremental parsing.
2 Incremental Parsing
This section gives a description of Collins and
Roark?s incremental parser (Collins and Roark,
2004) and discusses its problem.
Collins and Roark?s parser uses a grammar de-
fined by a 6-tuple G = (V, T, S,#, C,B). V is
a set of nonterminal symbols. T is a set of ter-
minal symbols. S is called a start symbol and
S ? V . # is a special symbol to mark the end
of a constituent. The rightmost child of every par-
ent is labeled with this symbol. This is necessary
to build a proper probabilistic parsing model. C
is a set of allowable chains. An allowable chain
is a sequence of nonterminal symbols followed by
a terminal symbol. Each chain corresponds to a
label sequence on a path from a node to its left-
most descendant leaf. B is a set of allowable
triples. An allowable triple is a tuple ?X,Y, Z?
where X,Y, Z ? V . The triple specifies which
nonterminal symbol Z is allowed to follow a non-
terminal symbol Y under a parent X .
For each initial fragment of a sentence, Collins
and Roark?s incremental parser produces partial
parse trees which span all words in the fragment.
Let us consider the parsing process as shown
in Figure 1. For the first word ?we?, the parser
produces the partial parse tree (a), if the allowable
chain ?S ? NP ? PRP ? we? exists in C. For
other chains which start with S and end with ?we?,
the parser produces partial parse trees by using the
chains. For the next word, the parser attaches the
chain ?VP?VBP? describe? to the partial parse
tree (a)
1
. The attachment is possible when the al-
lowable triple ?S, NP, VP? exists in B.
1
More precisely, the chain is attached after attaching end-
of-constituent# under the NP node.
41
WePRP
NP S(a)
WePRP
NP S(b)
describeVBP
VP
WePRP
NP S(c)
describeVBP
VP NPDTa
WePRP
NP S(d)
describeVBP
VP NP
DTa
WePRP
NP S(e)
describeVBP
VP NP
DTa
NP
NPNP
Figure 1: A process in incremental parsing
2.1 Infinite Local Ambiguity
Incremental parsing suffers from the problem of
infinite local ambiguity. The ambiguity is caused
by left-recursion. An infinite number of partial
parse trees are produced, because we cannot pre-
dict the depth of left-recursive nesting.
Let us consider the fragment ?We describe a.?
For this fragment, there exist several candidates of
partial parse trees. Figure 1 shows candidates of
partial parse trees. The partial parse tree (c) rep-
resents that the noun phrase which starts with ?a?
has no adjunct. The tree (d) represents that the
noun phrase has an adjunct or is a conjunct of a
coordinated noun phrase. The tree (e) represents
that the noun phrase has an adjunct and the noun
phrase with an adjunct is a conjunct of a coordi-
nated noun phrase. The partial parse trees (d) and
(e) are the instances of partial parse trees which
have left-recursive structures. The major problem
is that there is no information to determine the
depth of left-recursive nesting at this point.
3 Incremental Parsing Method Based on
Adjoining Operation
In order to avoid the problem of infinite local am-
biguity, the previous works have adopted the fol-
lowing approaches: (1) a beam search strategy
(Collins and Roark, 2004; Roark, 2001; Roark,
2004), (2) limiting the allowable chains to those
actually observed in the treebank (Collins and
Roark, 2004), and (3) transforming the parse trees
with a selective left-corner transformation (John-
son and Roark, 2000) before inducing the al-
lowable chains and allowable triples (Collins and
Roark, 2004). The first and second approaches can
prevent the parser from infinitely producing partial
parse trees, but the parser has to produce partial
parse trees as shown in Figure 1. The local ambi-
guity still remains. In the third approach, no left
recursive structure exists in the transformed gram-
mar, but the parse trees defined by the grammar are
different from those defined by the original gram-
mar. It is not clear if partial parse trees defined by
the transformed grammar represent syntactic rela-
tions correctly.
As an approach to solve these problems, we
introduce an adjoining operation to incremental
parsing. Lombardo and Sturt (1997) and Kato
et al (2004) have already adopted this approach.
However, their methods have another problem that
their adjoining operations cannot preserve lexical
dependencies of partial parse trees. To solve this
problem, this section proposes a restricted version
of the adjoining operation.
3.1 Adjoining Operation
An adjoining operation is used in Tree-Adjoining
Grammar (Joshi, 1985). The operation inserts a
tree into another tree. The inserted tree is called an
auxiliary tree. Each auxiliary tree has a leaf called
a foot which has the same nonterminal symbol as
its root. An adjoining operation is defined as fol-
lows:
adjoining An adjoining operation splits a parse
tree ? at a nonterminal node ? and inserts an
auxiliary tree ? having the same nonterminal
symbol as ?, i.e., combines the upper tree of
? with the root of ? and the lower tree of ?
with the foot of ?.
We write a
?,?
(?) for the partial parse tree obtained
by adjoining ? to ? at ?.
We use simplest auxiliary trees, which consist
of a root and a foot.
As we have seen in Figure 1, Collins and
Roark?s parser produces partial parse trees such as
(c), (d) and (e). On the other hand, by using the
adjoining operation, our parser produces only the
partial parse tree (c). When a left-recursive struc-
ture is required to parse the sentence, our parser
adjoins it. In the example above, the parser adjoins
the auxiliary tree ?NP ? NP? to the partial parse
tree (c) when the word ?for? is read. This enables
42
WePRP*
NP S
describeVBP*
VP* NPa  method WePRP*
NP S
describeVBP*
VP* NP
a  method
adjoining
NP* WePRP*
NP S
describeVBP*
VP* NP
a  methodNP* PPforIN*
Figure 2: Adjoining operation
WePRP*
NP S
describeVBP*
VP* NPJohn  's WePRP*
NP S
describeVBP*
VP* NPadjoining NPJohn  's
We  describe  John  's We  describe  John  's
(a) (b)
WePRP*
NP S
describeVBP*
VP* NPNPJohn  's
We  describe  John  's  method
(c)
NN*method
Figure 3: Non-monotonic adjoining operation
the parser to attach the allowable chain ?PP ? IN
? for?. The parsing process is shown in Figure 2.
3.2 Adjoining Operation and Monotonicity
By using the adjoining operation, we avoid the
problem of infinite local ambiguity. However, the
adjoining operation cannot preserve lexical depen-
dencies of partial parse trees. Lexical dependency
is a kind of relation between words, which repre-
sents head-modifier relation. We can map parse
trees to sets of lexical dependencies by identifying
the head-child of each constituent in the parse tree
(Collins, 1999).
Let us consider the parsing process as shown
in Figure 3. The partial parse tree (a) is a can-
didate for the initial fragment ?We describe John
?s?. We mark each head-child with a special sym-
bol ?. We obtain three lexical dependencies ?We
? describe?, ?John ? ?s? and ??s ? describe?
from (a). When the parser reads the next word
?method?, it produces the partial parse tree (b) by
adjoining the auxiliary tree ?NP ? NP?. The par-
tial parse tree (b) does not have ??s ? describe?.
The dependency ??s ? describe? is removed when
the parser adjoins the auxiliary tree ?NP ? NP? to
(a). This example demonstrates that the adjoining
operation cannot preserve lexical dependencies of
partial parse trees.
Now, we define the monotonicity of the adjoin-
ing operation. We say that adjoining an auxiliary
tree ? to a partial parse tree ? at a node ? is mono-
tonic when dep(?) ? dep(a
?,?
(?)) where dep is
the mapping from a parse tree to a set of dependen-
cies. An auxiliary tree ? is monotonic if adjoining
? to any partial parse tree is monotonic.
We want to exclude any non-monotonic auxil-
iary tree from the grammar. For this purpose, we
restrict the form of auxiliary trees. In our frame-
work, all auxiliary trees satisfy the following con-
straint:
? The foot of each auxiliary tree must be the
head-child of its parent.
The auxiliary tree ?NP ? NP
?
? satisfies the con-
straint, while ?NP ? NP? does not.
3.3 Our Incremental Parser
Our incremental parser is based on a probabilistic
parsing model which assigns a probability to each
operation. The probability of a partial parse tree is
defined by the product of the probabilities of the
operations used in its construction. The probabil-
ity of attaching an allowable chain c to a partial
parse tree ? is approximated as follows:
P (c | ?) = P
root
(R | P,L,H, t
H
, w
H
,D)
?P
template
(c
?
| R,P,L,H)
?P
word
(w | c
?
, t
h
, w
h
)
where R is the root label of c, c
?
is the sequence
which is obtained by omitting the last element
from c and w is the last element of c. The proba-
bility is conditioned on a limited context of ?. P
is a set of the ancestor labels of R. L is a set of the
left-sibling labels of R. H is the head label in L.
w
H
and t
H
are the head word and head tag of H ,
respectively. D is a set of distance features. w
h
and t
h
are the word and POS tag modified by w,
respectively. The adjoining probability is approxi-
mated as follows:
P (? | ?) = P
adjoining
(? | P,L,H,D)
where ? is an auxiliary tree or a special symbol
nil, the nil means that no auxiliary tree is ad-
joined. The limited contexts used in this model
are similar to the previous methods (Collins and
Roark, 2004; Roark, 2001; Roark, 2004).
To achieve efficient parsing, we use a beam
search strategy like the previous methods (Collins
and Roark, 2004; Roark, 2001; Roark, 2004). For
each word position i, our parser has a priority
queue H
i
. Each queue H
i
stores the only N -best
43
Table 1: Parsing results
LR(%) LP(%) F(%)
Roark (2004) 86.4 86.8 86.6
Collins and Roark (2004) 86.5 86.8 86.7
No adjoining 86.3 86.8 86.6
Non-monotonic adjoining 86.1 87.1 86.6
Monotonic adjoining 87.2 87.7 87.4
partial parse trees. In addition, the parser discards
the partial parse tree ? whose probability P (?) is
less than the P
?
? where P
?
is the highest proba-
bility on the queue H
i
and ? is a beam factor.
4 Experimental Evaluation
To evaluate the performance of our incremental
parser, we conducted a parsing experiment. We
implemented the following three types of incre-
mental parsers to assess the influence of the ad-
joining operation and its monotonicity: (1) with-
out adjoining operation, (2) with non-monotonic
adjoining operation, and (3) with monotonic ad-
joining operation. The grammars were extracted
from the parse trees in sections 02-21 of the Wall
Street Journal in Penn Treebank. We identified the
head-child in each constituent by using the head
rule of Collins (Collins, 1999). The probabilistic
models were built by using the maximum entropy
method. We set the beam-width N to 300 and the
beam factor ? to 10
?11
.
We evaluated the parsing accuracy by using sec-
tion 23. We measured labeled recall and labeled
precision. Table 1 shows the results
2
. Our in-
cremental parser is competitive with the previous
ones. The incremental parser with the monotonic
adjoining operation outperforms the others. The
result means that our proposed constraint of auxil-
iary trees improves parsing accuracy.
5 Conclusion
This paper has proposed an incremental parser
based on an adjoining operation to solve the prob-
lem of infinite local ambiguity. The adjoining
operation causes another problem that the parser
cannot preserve lexical dependencies of partial
parse trees. To tackle this problem, we defined
2
The best results of Collins and Roark (2004)
(LR=88.4%, LP=89.1% and F=88.8%) are achieved when
the parser utilizes the information about the final punctuation
and the look-ahead. However, the parsing process is not
on a word-by-word basis. The results shown in Table 1 are
achieved when the parser does not utilize such informations.
the monotonicity of adjoining operation and re-
stricted the form of auxiliary trees to satisfy the
constraint of the monotonicity. Our experimental
result showed that the restriction improved the ac-
curacy of our incremental parser.
In future work, we will investigate the incre-
mental parser for head-final language such as
Japanese. Head-final language includes many in-
direct left-recursive structures. In this paper, we
dealt with direct left-recursive structures only. To
process indirect left-recursive structures, we need
to extend our method.
References
James Allen, George Ferguson, and Amanda Stent.
2001. An architecture for more realistic conver-
sational systems. In Proceedings of International
Conference of Intelligent User Interfaces, pages 1?
8.
Michael Collins and Brian Roark. 2004. Incremen-
tal parsing with the perceptron algorithm. In Pro-
ceedings of the 42nd Meeting of the Association for
Computational Linguistics (ACL?04), Main Volume,
pages 111?118, Barcelona, Spain, July.
Michael Collins. 1999. Head-Driven Statistical Mod-
els for Natural Language Parsing. Ph.D. thesis,
University of Pennsylvania.
Mark Johnson and Brian Roark. 2000. Compact
non-left-recursive grammars using the selective left-
corner transform and factoring. In Proceedings of
the 18th International Conference on Computational
Linguistics, pages 355?361, July.
Aravind K. Joshi. 1985. Tree adjoining grammars:
How much context sensitivity is required to provide
a reasonable structural description? In David R.
Dowty, Lauri Karttunen, and Arnold M. Zwicky, ed-
itors, Natural Language Parsing, pages 206?250.
Cambridge University Press.
Yoshihide Kato, Shigeki Matsubara, and Yasuyoshi In-
agaki. 2004. Stochastically evaluating the valid-
ity of partial parse trees in incremental parsing. In
Proceedings of the ACLWorkshop Incremental Pars-
ing: Bringing Engineering and Cognition Together,
pages 9?15, July.
Vincenzo Lombardo and Patrick Sturt. 1997. Incre-
mental processing and infinite local ambiguity. In
Proceedings of the 19th Annual Conference of the
Cognitive Science Society, pages 448?453.
Brian Roark. 2001. Probabilistic top-down parsing
and language modeling. Computational Linguistics,
27(2):249?276, June.
Brian Roark. 2004. Robust garden path parsing. Nat-
ural language engineering, 10(1):1?24.
44

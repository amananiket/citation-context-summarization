PARALLEL MULTIPLE CONTEXT-FREE GRAMMARS, FINITE-STATE 
TRANSLATION SYSTEMS, AND POLYNOMIAL-TIME RECOGNIZABLE 
SUBCLASSES OF LEXICAL-FUNCTIONAL GRAMMARS 
Hiroyuki Seki tt  Ryuichi Nakanishi t Yuichi Kaji t 
Sachiko Ando t Tadao Kasami $t 
t Department of Information and Computer Sciences, Faculty of Engineering Science, Osaka University 
1-1 Machikaneyama, Toyonaka, Osaka 560, Japan 
:~ Graduate School of Information Science, Advanced Institute of Science and Technology, Nara 
8916-5 Takayama, Ikoma, Nara 630-01, Japan 
Internet: seki@ics.es.osaka-u.ac.jp 
Abst rac t  
A number of grammatical formalisms were intro- 
duced to define the syntax of natural languages. 
Among them are parallel multiple context-free 
grammars (pmcfg's) and lexical-functional gram- 
mars (lfg's). Pmcfg's and their subclass called 
multiple context-free grammars (mcfg's) are nat- 
ural extensions of cfg's, and pmcfg's are known 
to be recognizable in polynomial time. Some sub- 
classes of lfg's have been proposed, but they were 
shown to generate an AlP-complete language. Fi- 
nite state translation systems (fts') were intro- 
duced as a computational model of transforma- 
tional grammars. In this paper, three subclasses 
of lfg's called nc-lfg's, dc-lfg's and fc-lfg's are 
introduced and the generative capacities of the 
above mentioned grammatical formalisms are in- 
vestigated. First, we show that the generative 
capacity of fts' is equal to that of nc-lfg's. As 
relations among subclasses of those formalisms, 
it is shown that the generative capacities of de- 
terministic fts', dc-lfg's, and pmcfg's are equal to 
each other, and the generative capacity of fc-lfg's 
is equal to that of mcfg's. It is also shown that 
at least one Af79-complete language is generated 
by fts'. Consequently, deterministic fts', dc-lfg's 
and fc-lfg's can be recognized in polynomial time. 
However, fts' (and nc-lfg's) cannot, if P ? AfT 9. 
1 In t roduct ion  
A number of grammatical formalisms such as 
lexical-functional grammars (Kaplan 1982), head 
grammars (Pollard 1984) and tree adjoining 
grammars (Joshi 1975)(Vijay-Shanker 1987) were 
introduced to define the syntax of natural lan- 
guages. On the other hand, there has been 
much effort to propose well-defined computa- 
tional models of transformational grammars. One 
of these is the one to extend devices which oper- 
ate on strings, such as generalized sequential ma- 
chines (gsm's) to devices which operate on trees. 
It is fundamentally significant o clarify the gen- 
erative capacities of such grammars and devices. 
Parallel multiple context-free grammars (pm- 
cfg's) and multiple context-free grammars (mcfg's) 
were introduced in (Kasami 1988a)(Seki 1991) as 
natural extensions of cfg's. The subsystem of lin- 
ear context-free rewriting systems (Icfrs') (Vijay- 
Shanker 1987) which deals with only strings is 
the same formalism as mcfg's. The class of cfl's 
is properly included in the class of languages gen- 
erated by pmcfg's, which in turn is properly in- 
cluded in the one generated by mcfg's. The class 
of languages generated by pmcfg's is properly 
included in that of context-sensitive languages 
(Kasami 1988a). Pmcfg's have been shown 
to be recognized in polynomial time (Kasami 
1988b)(Seki 1991). 
A tree transducer (Rounds 1969) takes a tree 
as an input, starts from the initial state with its 
head scanning the root node of an input. Ac- 
cording to the current state and the label of the 
scanned node, it transforms an input tree into 
an output tree in a top-down way. A finite state 
translation system (fts) is a tree transducer with 
its input domain being the set of derivation trees 
of a cfg (Rounds 1969)(Thatcher 1967). A num- 
ber of equivalence relations between the classes 
of yield languages generated by fts' and other 
computational models have been established (En- 
gelfriet 1991)(Engelfriet 1980)(Weir 1992). Espe- 
cially, it has been shown that the class of yield 
languages generated by finite-copying fts' equals 
to the class of languages generated by lcfrs' (Weir 
1992), hence by mcfg's. 
In lexical-functional grammars (Ifg's) (Ka- 
plan 1982), associated with each node v of a 
derivation tree is a finite set F of pairs of at- 
tribute names and their values. F is called the f- 
structure of v. An lfg G consists of a cfg Go called 
the underlying cfg of G and a finite set Pfs of 
equations called functional schemata which spec- 
ify constraints between the f-structures of nodes 
in a derivation tree. Functional schemata re at- 
tached to symbols in productions of Go. It has 
been shown in (Nakanishi 1992) that the class of 
languages generated by lfg's is equal to that of re- 
130 
cursively enumerable languages even though the 
underlying cfg's are restricted to regular gram- 
mars. In (Gazdar 1985)(Kaplan 1982)(Nishino 
1991), subclasses of lfg's were proposed in order 
to guarantee the recursiveness (and/or the effi- 
cient recognition) of languages generated by lfg's. 
However, these classes were shown to generate an 
A/P-complete language (Nakanishi 1992). 
In this paper, three subclasses of lfg's called 
nc-lfg's, dc-lfg's and fc-lfg's are proposed, two 
of which can be recognized in polynomial time. 
Moreover, this paper clarifies the relations among 
the generative capacities of pmcfg's, fts' and these 
subclasses of lfg's. 
In nc-lfg's, a functional schema either speci- 
fies the vMue of a specific attribute, say atr, im- 
mediately (Tart = val) or specifies that the value 
of a specific attribute of a node v is equal to the 
whole f-structure of a child node of v (Tatr =l). 
An nc-lfg is called a dc-lfg if each pair of rules 
P\] : A --~ aa and P2 : A --~ a2 whose left-hand 
sides are the same is inconsistent in the sense 
that there exists no f-structure that locally sat- 
isfies both of the functional schemata of Pl and 
those of p2. Intuitively, in a dc-lfg G, for each pair 
(tl, t2) of derivation trees in G, if the f-structure 
and nonterminal of the root of tl are the same as 
those of t2, then t\] and t2 derive the same termi- 
nal string. 
Let G be an nc-lfg. A multiset M of nonter- 
minals of G is called an SPN multiset in G if the 
following condition holds: 
Let M = {{A1,A2, ' . . ,An}} be a mul- 
tiset of nonterminals where different Ai's 
are not always distinct. There exist a 
derivation tree t and a subset of nodes 
V = {v\],v2,...,v,~} of t such that the 
label o fv i  is Ai (1 < i < n) and the f- 
structures of vi's are the same with each 
other by functional schemata of G. 
If the number of SPN multisets in G is finite, then 
G is called an fc-lfg. 
Our main result is that the generative capac- 
ity of nc-lfg's is equal to that of fts'. As relations 
among proper subclasses of the above mentioned 
formalisms, it is shown that the generative capac- 
ities of dc-lfg's, deterministic fts' and pmcfg's are 
equal to each other, and the generative capacity 
of fc-lfg's is equal to that of mcfg's. It is also 
shown that a (nondeterministic) fts generates an 
Af:P-complete language. 
2 Parallel Mult iple Context-Free 
Grammars 
A parallel multiple context-free grammar (pmcfg) 
is defined to be a 5-tuple G = ( N, T, F, P, S) 
which satisfies the following conditions (G1) 
through (Gh) (Kasami 1988a)(Seki 1991). 
(G1)  N is a finite set of nonterminal symbols. A 
positive integer d(A) is given for each nonter- 
minal symbol A ? N. 
(G2)  T is a finite set of terminal symbols which 
is disjoint with N. 
(G3)  F is a finite set of functions satisfying the 
following conditions. For a positive integer d, 
let (T*) a denote the set of all the d-tuples of 
strings over T. For each f ? F with arity 
a(f), positive integers r( f )  and di(f) (1 _< 
i < a(f)) are given, and f is a total function 
from (T*) dl(:) x (T*) d2(f) ?... x (T*)da(f) (1) to 
I T*)'( :)  which satisfies the following condition fl). Let 
? i = (z i l ,  z i2 , . . . ,  zid,(S)) 
denote the ith argument of f for 1 < i < a(f). 
( f l )  For 1 < h < r(f) ,  the hth component of 
f ,  denoted by f\[h\], is defined as; 
f\[h\] \[Xl, f~2,-" -, Xa(f)\] = OCh,OX#(h,O)rl(h,o)Oth,1 
? .'ah,nh_lXu(h,nh_l)n(h,nh_Dah,n~ (2.1) 
where ah,k ? T* for 0 < k <_ nh, 1 < 
#(h,j)  <_ a(f) and 1 <_ ~(h,j) <_ dt~(h,j)(f) 
for O ~ j ~_ nh --1. 
(G4)  P is a finite set of productions of 
the form A ---* f\[A1,A2,.. . ,Aa(y)\] where 
A, Aa,A2, . . . ,Aa( / )  ? N, f ? F, r ( f )  = d(A) 
and di(f) = d(Ai) (1 < i < a(f)). I fa ( f )  = 0, 
i.e., f ? (T*) r(f), the production is called a 
terminating production, otherwise it is called 
a nonterminating production. 
(Gh)  S ? N is the initial symbol, and d(S) = 1. 
If all the functions of a pmcfg G satisfy the 
following Right Linearity condition, then G is 
called a multiple context-free grammar (mcfg). 
\ [Right L inear i ty  \] For each xlj, the total num- 
ber of occurrences of xij in the right-hand 
sides of (2.1) from h = 1 through r ( f )  is at 
most one. 
The language generated by a pmcfg G = 
(N, T, F, P, S) is defined as follows. For A ? N, 
let us define LG(A) as the smallest set satisfying 
the following two conditions: 
(L1) If a terminating production A --* & is in P,  
then ~ ? LG(A). 
(L2) If A --~ f\[A1,A2,.. . ,Aa(y)\] ? P and 
(~i ? LG(Ai) ~1 < i < a(f)), then 
f\[~1,~2,''', O~a(f)\] ? LG(A) .- 
131 
Define L(G) a=La(S). L(G) is called the par- 
allel multiple context-free language (pmcfl) gen- 
erated by G. If G is an mcfg, L(G) is called the 
multiple context-free language (mcfl) generated by 
G. 
Example  2.1(Kasami 1988a): Let GEX1 ~--- (N, 
T ,F ,P ,S ) ,N  = {S}, T = {a},F  = { f~, f} ,P  = 
{r\] : S --~ fa, ro : S --* f\[S\]}, where f~ = 
a,f \[(x)\]  = xx. GExl  is a pmcfg but is not an 
mcfg since the function f does not satisfy Right 
Linearity. The language generated by GEx~ is 
{a 2" In > 0}, which cannot be generated by any 
mcfg (see Lemma 6 of (Kasami 1988a)). 
The empty string is denoted by ?. 
Example  2.2: Let GEx2 = (N, T, F, P, S) be 
a pmcfg, where N = {S,A),  T = {a,b}, F = 
{g\[(Xl,X2) \] ---- XlX2, fa\[(Xl,X2)\] -~ (xla, x2a), 
= y, = and, P= 
- --* {Po : S g\[A\], Pl : A ---* f~\[A\], Pz : A --* 
fb\[A\], P3 : A ---* f~}. Note that GEx2 is an mcfg. 
L (GEx2) = {ww I w E {a, b)*}. 
Lamina  2.1(Kasami 1988b)(Seki 1991): Let C 
be a pmcfg. For a given string w, it is decidable 
whether w E L (G) or not in time polynomial of 
I~1, where I~1 denotes the length of w. 
3 F in i te State Trans la t ion  Systems 
A set ~ of symbols is a ranked alphabet if, for 
each cr E ~, a unique non-negative number p(c~) 
is associated, p(cr) is the rank of ~. For a set X,  
we define free algebra T~.(X) as the smallest set 
such that; 
* T~: (X) includes X. 
? If p(~) = 0 for cr E ~, then ~ E T~(X). 
? If p(o') = n (> 1) for a E, ~ and t l , . . . ,  E 
7-~.(X), then t-= or(t1,.., tn) E T~(X).  t~ is 
called the root symbol, or shortly, the root of 
t. 
Hereafter, a term in 7"~ (X) is also called a tree, 
and we use terminology of trees such as subtree, 
node and so on. 
Let G - (N, T, P, S) be a context-free gram- 
mar (cfg) where N, T, P and S are a set of non- 
terminal symbols, a set of terminal symbols, a 
set of productions and the initial symbol, respec- 
tively. A derivation tree in cfg G is a term defined 
as follows. 
(T1)  Every a E T is a derivation tree in G. 
(T2)  Assume that there are a production p : 
A ---* X1. . .X ,~ (A E N, X I , . . . ,Xn  E NUT)  
in P and n derivation trees t l , . . . t ,~ whose 
roots are labeled with P l , . . . ,  pn, respectively, 
and 
? i fXi  E N, then pl is a production Xi --~ " ", 
whose left-hand side is Xi, and 
? i fX iET ,  thenp i=t i=X i .  
Then p( t l , . . . ,  t,~) is a derivation tree in G. 
(T3)  There are no other derivation trees. 
Let T~(G) be the set of derivation trees in G, and 
7?s(G) C 7?(G) be the set of derivation trees 
whose root is labeled with a production of which 
left-hand side is the initial symbol S. Clearly, 
T~s(G) C_ T~(?) holds. Remark that 7?s(G) is a 
multi-sorted algebra, where the nonterminals are 
sorts, and the terminals and the labels of produc- 
tions are operators. 
A tree transducer (Rounds 1969) defines a 
mapping from trees to trees. Since we are mainly 
interested in the string language generated by 
a tree transducer, a "tree-to-string" version of 
transducer defined in (Engelfriet 1980) is used in 
this paper. For sets Q and X, let 
Q\[X\]~{q\[x\] l q e Q,x e X). 
A tree-to-string transducer (yT-transducer 
or simply transducer) is defined to be a 5-tuple 
M = (Q, ~., A, q0, R) where (1) Q is a finite set of 
states, (2) ~ is an input ranked alphabet, (3) A is 
an output alphabet, (4) q0 E Q is the initial state, 
and (5) R is a finite set of rules of the form 
q\[c~(xl,..., xn)\] --* v 
where q e Q, e = and v e (Z uQ\[{xl, 
. . . ,  xn}\])*. If any different rules in R have differ- 
ent left-hand sides, then M is called deterministic 
(Engelfriet 1980). 
A configuration of a yT-transducer is an ele- 
ment in (A U Q\[T~.(?)\])*. Derivation of M is de- 
fined as follows. Let t ----- alq\[a(t l , . . . ,  tn)\]a2 be 
a configuration where a l ,  a2 E (A U Q\[T~.(?)\])*, 
q E Q, ~ E ~, p(a) = n and Q, . . . , tn  E T~.(?). 
Assume that there is a rule q\[cr(xl , . . . ,  Xn)\] --* V 
in R. Let t ~ be obtained from v by substituting 
t \ ] , . . . ,  tn for x l , . . . ,  xn, respectively, then we de- 
fine t ~M ultra2 ? Let : :~  be the reflexive and 
transitive closure of :=~. If t =?.~ t ~, then we say 
t ~ is derived from t. If there is no w E A* such 
that t ~ w, then we say no output is derived 
from t. 
A tree-to-string finite state translation sys- 
tem (yT-fts or fts) is defined by a yT-transducer 
M and a cfg G, written as (M,G)  (Rounds 
1969)(Thatcher 1967). 
We define yL(M,G) ,  called the yield lan- 
guage generated by yT-fts (M, G), as 
yL(M,a)~{w e A* 13t e ~s(a),qo\[t\] ~*M w} 
where A is an output alphabet and q0 is the initial 
state of M. An fts is called deterministic (Engel- 
friet 1980) if the transducer M is deterministic. 
132 
Engelfriet introduced a subclass of fts' called 
finite-copying fts' as follows (Engelfriet 1980): 
Let (M,G)  be an fts with output alphabet A 
and initial state q0, t be a derivation tree in G 
and t ~ be a subtree of t. Assume that  there is 
a derivation a : q0\[t\] =~ w. Now, delete from 
this derivation a all the derivation steps which 
operates on t t. This leads to the following new 
derivation which keeps t ~ untouched; 
! * 
: q0\[t\] 
wherewi ?  A* fo r l< i<n+l .  
The state sequence of t ! in derivation a is 
defined to be (q i~, . . . ,q i . ) .  Derivation a has 
copying-bound k if, for every subtree of t, the 
length of its state sequence is at most k. An fts 
(M, G) is a finite-copying, if there is a constant 
k and for each w ? yL(M,  G), there is a deriva- 
tion tree t in G and a derivation q0\[t\] ~ w with 
copying-bound k. It is known that the determin- 
ism does not weaken the generative capacity of 
finite-copying fts' (Engelfriet 1980). 
We note that an fts (M, G) can be considered 
to be a model of a transformational grammar: A 
deep-structure of a sentence is represented by a 
derivation tree of G, and M can be considered to 
transform the deep-structure into a sentence (or 
its surface structure). 
4 Subc lasses  o f  Lex ica l - funct iona l  
g rammars  
A simple subclass of lfg's, called r-lfg's, is in- 
troduced in (Nishino 1992), which is shown to 
generate all the recursively enumerable languages 
(Nakanishi 1992). Here, we define a nondeter- 
ministic copying Ifg (nc-lfg) as a proper subclass 
of r-lfg's. An nc-lfg is defined to be a 6-tuple 
G = (N, T, P, S, N~t~, A~tr~) where: (1) N is a fi- 
nite set of nonterminal symbols, (2) T is a finite 
set of terminal symbols, and (3) P is a finite set of 
annotated productions. Sometimes, a nonterminal 
symbol, a terminal symbol and an annotated pro- 
duction are abbreviated as a nonterminal, a ter- 
minal and a production, respectively, i 4) S ? N 
is the initial symbol, (5) Nat~ is a finite set of at- 
tributes, and (6) A~tm is a finite set of atoms. 
An equation of the form T atr =~ (atr ? 
Nat,) is called an S (structure synthesizing) 
schema, and an equation of the form T atr .-= 
val (atr ? Natr, val ? A~tm) is called a V (im- 
mediate value) schema. A functional schema is 
either an S schema or a V schema. 
Each production p ? P has the following 
form: 
p :A  -~ B1 B2 ... Bq, (4.2) 
Ev ESl Es2 ""  Esq 
where A ? N, B1 ,B2 , . " ,Bq  ? NUT.  Ev  is a 
finite set of V schemata nd Esj  (1 _< j <_ q) is 
a singleton of an S schema. A --~ B1B2"..  Bq in 
(4.2) is called the underlying production of p. Let 
P0 be the set of all the underlying productions of 
P. Cfg Go = (N, T, P0, S) is called the underlying 
c/g o/ C. 
An f-structure of G is recursively defined as a 
set F -=- {(atrl, call), (atr2, val2>,..., latrk, valk)} 
where atr\], atr2,..., and atrk are distinct at- 
tributes, and each of vail, val2,." ", and valk is an 
atom or an f-structure. We say that vali (1 < i < 
k) is the value of atri in F and write F.atri -= vali. 
For a cfg G' = ( N ~, T', P~, S~), derivation re- 
lations in G ~, denoted by A ::~a' a and A =~* G ~ 
(A ? N ' ,a  ? (N '  u T')*) are defined in the 
usual way. 
Suppose Go = i N, T, P0, S) is the underlying 
cfg of an nc-lfg G = (N, T, P, S, Nat,, Aa,m). Let 
t be a derivation tree in Go. (In 4.,7. and 8., the 
label of a leaf of a derivation tree is allowed to be 
a nonterminal.) Every internal node v in t has 
an f-structure, which is called the f-structure of 
v and written as Fv. If  an underlying production 
P0 :A  ~ B I " .Bq  ? P0 is applied at v, then v is 
labeled with either P0 itself, or p ( ?  P)  of which 
P0 is the underlying production, if necessary. Let 
vi be the ith child o fv  (1 < i < q). We define 
the values of both sides of a functional schema 
attached to the symbol in p (on v) as follows: 
* the value of T atr(atr ? Nat,) is Fv.atr, 
? the value of + in an S schema is Fv~ if the 
S schema is attached to the i(1 _< i _< q)th 
symbol in the r ight-hand side of p, and 
? the value of atom atm in a V schema is arm 
itself. 
We say that  v satisfies functional schemata if for 
each functional schema lls = rib of p, the val- 
ues of lls and r/s on v are defined and equals 
with each other. In this case, it is also said that  
Fv locally satisfies the functional schemata of p. 
NOTE : Because the meaning of a V schema is in- 
dependent of the position where it is annotated, 
V schemata re attached to the left-hand side in 
this paper. 
For a nonterminal A E N and a sentential 
form a E iN  t_J T)*, let t be a derivation tree of 
a derivation A =** Go a. I f  all internal nodes in 
t satisfy functional schemata, then a is said to 
be derived from A and written as A =~* . a a In 
this case, the tree t is called a derivation tree of 
A:=~* G a. We also call t a derivation tree (of a)  
in G simply. 
The language generated by an nc-lfg G, de- 
noted by LIG), is defined as L(G) = {w e 
T* \ [S  ~*  w I. G 
NOTE : In the definition of nc-lfg, even if 
"Esj (1 < j < q) is a's ingleton of an S 
schema" 
is replaced with 
133 
Fcount :\[COunt :\[COunt : e \]\]~ S 
a b c 
~otmt :\[count : eli 
%? 
Figure 1: A derivation tree of aabbccdd 
"Es j  (1 < j < q) is either a singleton of 
an S schema or an empty set", 
the generative capacity of nc-lfg is not changed. 
Example  4.1: Let G~xs = (N, T, P, S, Nat,, 
A~tm) be an nc-lfg where N = {S,A,B},  T = 
{a, b,c, d}, Nat~ = {count}, Aatrn = {e}, and pro- 
ductions in P are; 
pl l  : s {T coA, t=l  _ {T couBt=l}  ' 
P12 : A ~ a { T couAt = ~ } b, 
p~ : B -~ ~ iT couBtM} d, 
P14 : {T coAt  e} ~ ~ 
P"  : {T eou~t= e} -~ ~ 
The language generated by GExs is L(GExs)  = 
{a'~bncnd  In > 0}. Figure 1 shows a derivation 
tree of S ~*  aabbccdd in GEXS. GEX3 
Example  4.2: Let Gsx4 = (N, T, P, S, N,t,,  
A~tm) be an nc-lfg where g = {S}, T = Ca}, 
N,t ,  = {log}, A,tm = {e}, and productions in P 
are; 
: s iT _ {T J= l} ,  
p22 : { T loS= e } ~ a. 
The language generated by GEX4 is L(GEx4) = 
{a2" \]n > 0}. 
Example  4.3: Let GEX5 = (N, T, P, S, Na~,, 
Aatm) be an nc-lfg where N = {S,S ' ,A ,B} ,  
T = {the, woman, men, and, drinks, smoke, respec- 
tively}, N . t ,  = {hum, list}, A.tm = {sg,pl,  ni l}, 
and productions in P are; 
P3o : S --* S t respectively 
{T list =l}  
P31 : 
P32 : 
p33 : 
p34 : 
P35  : 
S~---* the woman and A drinks and B 
{Tnum=sg} {Tlist=l} {Tlist=l}' 
S~--* the men and A smoke and 13 
{Tnum=pl} {Tlist=~} {Tlist=~}' 
A ~ the woman and A 
{ T num= sg} { r list =.\[}'  
A ~ the men and A 
{ T num = pl } {T list =~}'  
A ~ the woman 
T num= sg 
T list = nil  ) 
p3~ : A ---. the men 
T num = pl 
T list = nil  ) 
pz7 : B --* drinks and B 
{T n~,m = ~g} {T l ist =~}' 
P38 : B --~ smoke and B 
{ T hum = pl } iT list =l} '  
p39 : B ---. drinks 
{ T num = sg 
T list = nil  ) 
p310 : B ---+ smoke 
T hum = pl 
T list = nil  ) 
G~xs generates "respectively" sentences such as 
"the woman and the men drinks and smoke re- 
spectively". 
For a set X of functional schemata, X is con- 
sistent iff neither the following (1) nor (2) holds. 
(1) {T atr = Call, T atr = val2 } c X 
for some atr E Na,, and some vall,val2 E 
Aatm such that call # val2. 
(2) iT atr = val, T atr =~} _C X 
for some atr E Nat~ and some val E Aatm. 
Productions p l , ' ' ' , Pn  are consistent iff 
Ul<i<_n E (0 is consistent where E (/) is the set of 
functional schemata of Pl. If productions are not 
consistent then they are called inconsistent. 
An nc-lfg G is called a deterministically copy- 
ing Ifg (dc-lfg), if any two productions A --+ al  
and A --+ a2 whoes left-hand sides are the same 
are inconsistent. 
Suppose G = (N ,T ,  P, S, Nat,, Aatm) is an 
nc-lfg. Let {{el ,e2, - ' . ,en}} denote the multi- 
set which consists of elements el, e2," ? ?, en that 
are not necessarily distinct. An SPN (SubPhrase 
Nonterminal) multiset in G is recursively defined 
as the following 1 through 3: 
1. {{S}} is an SPN multiset. 
2. Suppose that {{A1, A2 , ' " ,  Ah}} (A1, A2, '"  ", 
Ah E N)  is an SPN multiset. Let A1 --~ al ,  
134 
? .', Ah ~ O:h be consistent productions. For 
each atr E Nat,, let MS~,~ be the multi- 
set consisting of all the nonterminals which 
appear in a l , ' ' ' , ah  and have an S schema 
T atr --l. If MSat~ is not empty, then MS~t~ 
is also an SPN multiset. 
3. There is no other SPN multiset. 
An nc-lfg such that the number of SPN multisets 
in G is finite is called a finite-copying lfg (fc-lfg). 
Example  4.4: Consider GEX s in Example 4.1. 
Productions /912 and P14 are inconsistent with 
each other and so are P13 and Ply. SPN multisets 
in GEX3 are  {{S}} and {{A,B)) .  Hence GEXS 
is a dc-lfg and is an fc-lfg. GEX5 is also a dc-lfg 
and is an fc-lfg by the similar reason. Similarly, 
GEX4 in Example 4.2 is a dc-lfg. SPN multisets 
in C~x~ are {{S}}, {{S, S}), {{S, S, S, S)}, .... 
Hence GEx4 is not an fc-lfg. 
NOTE : L (GExs) is generated by a tree adjoining 
grammar. Suppose that a sentence has three or 
more phrases which have co-occurrence r lation 
like the one between the subject phrase and the 
verb phrase in the "respectively" sentence. Tree 
adjoining grammars can not generate such syntax 
while fc-lfg's or dc-lfg's can, although the authors 
do not know a natural language which has such 
syntax so far. 
By Lemma 2.1 and Theorem 8.1, fc-lfg's are 
polynomial-time r cognizable. Hence, it is desir- 
able that whether a given lfg G is an fc-lfg or not 
is decidable. Fortunately, it is decidable by the 
following lemma. 
Lemma 4.1: For a given nc-lfg G, it is decid- 
able whether the number of SPN multisets in G 
is finite or infinite. 
Proof. The problem can be reduced to the 
boundedness problem of Petri nets, which is 
known to be decidable (Peterson 1981). 
5 Overv iew of  the  Results 
Let ~'nc-lfg, ~'dc-lfg and ~-'fc-lfg denote the classes 
of languages generated by nc-lfg's, dc-lfg's and 
fc-lfg's, respectively, and let y~#,, Y~.d-fts and 
YElc-#s denote the classes of yield languages gen- 
erated by fts', deterministic fts' and finite-copying 
fts', respectively. Let l:vmcla and ?:mcfg be the 
classes of languages generated by pmcfg's and 
mcfg's, respectively. Also let ?:ta9 be the class of 
language generated by tree adjoining grammars. 
Inclusion relations among these classes of 
languages are summarized in Figure 2. An equiv- 
alence relation *1 is shown in (Weir 1992). Re- 
lations *2 are new results which we prove in this 
paper. We also note that all the inclusion rela- 
tions are proper; indeed, 
0 l{ala2a3a41n >_ E D - E a a2  n n _ . . . . .  a2m_la2m \[ n > E C - D for m > 3, 
(by (Vijay-Shanker 1987).) 
{a 2" In > 0} e S - C, 
(by (Kasami 1988a)(Seki 1991).) 
A relation B~ A is shown in (Engelfriet 1980). By 
Lemma 2.1, all languages in the region enclosed 
with the bold line are recognizable in polynomial 
time. On the other hand, it is shown in this 
paper that Unary-3SAT, which is known to be 
A/P-complete (Nakanishi 1992), is in A. Hence, 
if ~ ~ A/~, then Unary-3SAT E A - B and the 
languages generated by fts' (or equivalently, nc- 
lfg's) are not recognizable in polynomial time in 
general. 
6 Generat ive  Capac i ty  o f  fts'  
6.1 Determin is t i c  fts'  
Here, the proof of an inclusion relation yEd-#s C_ 
/:vmc/g is sketched. 
Let (M, G) be a deterministic yT-fts where 
M = (Q,~,A ,q l ,R )  and G = (N ,T ,P ,S ) . ,  We 
assume that Q = {ql,-- - ,ql}, T = {a l , . . .  an} 
and P = {Pl , . . . ,Pm}. Since the input for M is 
the set of derivation trees of G, we assume that 
= {Pl, . - .  ,Pro, a l , . . . ,  an} without loss of gen- 
erality. 
We will construct a pmcfg G I -=- ( N ~, T ~, F', 
P',  S') such that yL(M,  G) ---- L(G') N A*. Since 
/:pmc/g is closed under the intersection with a 
regular set (Kasami 1988a)(Seki 1991), it follows 
that yL(U ,  G) E ?'pmclg. Let T' = A td {b} where 
b is a newly introduced symbol and let 
N'  = {S ' ,R I , . . . ,Rm,  A I , . . . ,An}  
where d(Ri) = d(Aj) = t for 1 < i <_ m and 
1 < j <_ n. Productions and functions of G ~ will 
be constructed to have the following property. 
- -  A y~/t, *=2 ~,~c-lfg 
- -B ~ ??~:~ .__2 y?~_:,, .__2 ?~_,:~ 
- -c  oL -  ?.~:~ *j y?:~-:. *=2 :-.:o-,:, 
__  D (2) 
- - E - -  ?cr~ 
l : ,a~ - -  
Figure 2: Inclusion relations between classes of 
languages. (1) : The class of language generated 
by lcfrs' is equal to C. (2) : The class of language 
generated by head grammars is equal to D. 
135 
Proper ty  6.1: There is (a~, . . .  ,a~) e LG,(Rh) 
(resp. LG,(Ah))  such that 
each of a , , , . . . ,as~ does not contain b, and 
every remaining a t , , . . . ,  a,~ contains b 
if and only if there is a derivation tree t of G such 
that the root is Ph (resp. ah) and 
{ qs, \[t\] ==>~ c~s~ (1 < j < u) no output is derived from q,~\[t\] (1 _< j < v). 
D 
The basic idea is to simulate the move of tree 
transducer M which is scanning a symbol Ph 
(resp. ah) with state ql by the ith component of 
the nonterminal Rh (resp. Ah) of pmcfg G I. Dur- 
ing the move of M, it may happen that no rule 
is defined for a current configuration and hence 
no output will be derived? The symbol b is intro- 
duced to represent such an undefined move ex- 
plicitly. 
We define RS(X) (X E N tO T) as follows. 
{Rh \[the left-hand side of Ph is X} 
RS(X) = if X E N 
{ Ah } if X = ah E T. 
Productions and functions are defined as follows. 
Step 1: For each production Ph : Iio --'* 
Y~ " " Yk ( Yo ~ N , Y= E NtoT  for 1 <u< k) 
of cfg G, construct nonterminating produc- 
tions 
Rh -+ \ [& , . . . ,  zk\] 
for every Z~ E RS(Y~) (1 < u < k), where fph 
is defined as follows: For 1 < i < g, 
? if the transducer M has no rule whose left- 
hand side is qi~ah(Xl, . . . ,  xk)\], then 
(6.a) 
h ? ' '  
? if M has a rule 
-+ 
? " ai,n,-lq~(i,,~,_D\[x~4~,,,_D\] a~,n,, then 
f p \ [ i \ ] \ [  x  .. , 5:k\] __a ei,ox~,(i,o),7(i,o)ei,\] (6.4) h ~ ? 
? " " Ot-,ni--lglz",ni--l'rl'i,ni--l'Ogi,ni~, (1, ) \[ ) 
where = (1 <,  < k). 
(Since M is deterministic, there exists at most 
one rule whose left-hand side is qi~h('"  ")\] and 
hence the above construction is well defined?) 
Step 2: For each ah E T, construct a terminat- 
ing production Ah -"+ fah where f~h is defined 
as follows: For 1 < i < i, 
? if M has no rule whose left-hand side is 
qi\[ah\], then ~a~\[i\] ~--b. 
? i fM  has a rule qi\[ah\] --+ hi, then f \ [~&ai .  
Step 3: For each Rh E RS(S), construct S' --+ 
/fi~st\[Rh\] where /fi,st\[(x\], . . . ,  xl ) \ ]~x\] .  Intu- 
itively, the right-hand side of this production 
corresponds to the initial configuration, that 
is, M is in the initial state ql and scanning 
the root symbol Ph of a derivation tree, where 
the left-hand side of Ph is the initial symbol 
S. 
The pmcfg G I constructed above satisfies 
Property 6.1. Its proof is found in (Kaji 1992) 
and omitted in this paper. By Property 6.1, we 
obtain the following lemma. 
L e m m a  6 .1 :  y l :d_ f ,  s C f f .pmcfg .  0 
The reverse inclusion relation l:p,~c/g C_ 
Y~.d-B, can be shown in a similar way, and the 
following theorem holds? 
Theorem 6.2: yf-.d./,s : E-pmcfg? 0 
6.2 Nondetermin is t i c  fts'  
In this section, the generative capacity of nonde- 
terministic yT-fts' is investigated, from the view- 
point of computational complexity? We have al- 
ready shown that Y~.d-~s : ~.pmcfg, and hence 
every language in this class can be recognized in 
time polynomial of the length of an input string? 
Our result here is: there is a nondeterministic fts 
that generates an A/'~-complete language? In the 
following, a language called Unary-3SAT,  which 
is ArT'-complete (Nakanishi 1992), is considered, 
and then it is shown to belong to yL:/,a. 
A Unary-3CNF is a (nonempty) 3CNF in 
which the subscripts of variables are represented 
in unary. A positive literal xi in a 3CNF is rep- 
resented by 1i$ in a Unary-3CNF. Similarly , a 
negative literal --xl is represented by 12#. For 
example, a 3CNF 
(x i  v x2 v ~xa) A (xa V ~x\]  v ~x~) 
is represented by a Unary-3CNF 
15115111# A I1151#I i#.  
Unary-3SAT is the set of all satisfiable Unary- 
3CNF's. 
Next, we construct a nondeterministic yT-fts 
(M, G) that generates Unary-3SAT. Define a cfg 
G = (N,T ,P ,  S) where N = {S,T ,F} ,  T = {e} 
and the productions in P are as follows: 
r ss  : S - -+S 
rsT : S--+ T 
rsF  : S -+F  
"rTT : T--+ T 
rTF : T--+ F. 
?'Te : T--+ e 
rFT  : F-+T 
? 'FF  : F - -+  F 
rFe  : F-+ e 
136 
Let M = (Q, E, A, qo, R) where 
q = {qo,q~,qt, qa}, 
~ {rSS, . . .  ,rFe}, 
z~ = {L^,$ ,#}.  
Since there are many rules in R, we will use an ab- 
breviated notation. For example, following four 
rules 
qaIrTelXll-~ 15, q~\[rTe(X)\] ~ 1# 
qdrF~tX)\]  + 15, qo\[rF~(X)\] -~ 1# 
are abbreviated as "q~\[rT~(X)\] = q~\[rF~(X)\] --* 
15 or 1#' .  By using this notation, the rules in R 
are defined as follows. 
q0\[r~(~)\] -~ qo\[~\] A q0\[x\] 
qo\[r~s(~)\] -~ q&\ ]  
q0\[~sr(~)\] = q0\[~sv(~)\] = q~\[r~r(~)\] 
= q~\[rSF(X)\] --~ qdx\]q~\[x\]q~\[x\] or 
q~\[x\]qt\[x\]qa\[x\] or qa\[x\]qa\[x\]qt\[x\] 
q,\[r**(x)\] = q&.~(~)\ ]  -* lq,\[~\] or 1~ 
q,\[rr,(~)\] ~ 1, 
q,\[r~,(~)\] = q , \ [ r~(~) \ ]  -* lq,\[x\] or 1# 
q,\[rF~(x)\]---+ 1# 
qo\[rr~(~)\] = qo\[rr~(~)\] = qoirF~(~)\] 
= qa\[rFF(X)\] lqa\[X\] or 15 or 1# 
qo\[r~c(x)\] = q. \ [ r~(~)\ ]  ++ 1, or 1#. 
The readers can easily verify that this yT-fts 
generates Unary-3SAT. 
7 Equ iva lence  o f  f-'nc-lfg and Y?f ts  
First, we show ?,~c-lfg C_ Y?qt~. For a given nc- 
lfg G = (N, T, P, S, Nat,, A~m), an equivalent fts 
(M, G I) is constructed in the following way. 
Let t be a derivation tree in lfg G and 
the f-structure of the root node of t be F = 
{(atr l ,F1), . . . ,  (atr,~,Fn)}. F is represented by 
a derivation tree r = p,p(Tl , ' - . ,  rn) in G', where 
ri (1 < i < n) is a derivation tree in G' which rep- 
resents Fi recursively. And sp is a set of produc- 
tions such that F locally satisfies the functional 
schemata of all productions in sp. M transforms 
r into the yield of t, i.e., the terminal string ob- 
talned by concatenating the labels of leaves, in a 
top-down way. 
\ [TRANS 7.11 Let N = {A1, ' " ,Am},  S = A1 
and Nat, = {atr l , - . . ,  atr,~}. Define SP as the set 
of all consistent subsets of P. 
Step 1: G' = (N ' ,{d} ,P ' ,S ' ) ,  where N'  = 
{S,plsp e SP} U {S'} and 
P'  = {p',p : S,p ---* S ' - . .  S ' t  
u{p;=~. . .  : s '  --+ Ss, l,p e sP}  
u{p~,m :~s' -+ deC:_/}. 
For a derivation tree r in G' and a node v 
' is applied, the snbtree rooted by the where p,p 
ith child of v represents he value of attribute 
atr i. 
Step 2: M = (Q,E,T ,  ql,R) is defined as fol- 
lows. 
Define Q = {ql , . . . ,  qm}. A state qj (1 < j _< m) 
corresponds to nonterminal A t in N. Define E -- 
{d} where  p(p ' . , )  = p(p . . . .  .~) = ' = 
and p(d) = O. And define R by the following (i) 
through (iii). 
(i) q j~ .. . .  .,(x)\] -~ qj\[x\] (1 _< j < m) belongs 
to R for each sp ? SP. 
(ii) Let r be a derivation tree in G '. When plsp 
is the production applied at the root of r and 
a state of M is q,o, M chooses a production 
p whose left-hand side is Auo , if exists, in sp. 
NOTE : Since productions in sp are consis- 
tent, there is an f-structure, which locally sat- 
isfies the functional schemata of all produc- 
tions in sp. 
For each production p E sp in SP 
p : A~o --* a0 A m al . . .  OtL -1  At, L aL 
Ev {~ atrv~ =~} ... {~ atrvL =~} 
where A~z E N and al E T*(0 < l < L), the 
following rule belongs to R: 
q#o~tsp(Xl, , *',xn)\] 
-~ "0q,, \ [X~,\]" I . . -"L-- lq,~\[X,~\]~. (7.5) 
(iii) No other rule belongs to R. 
Next, Y?~s C_ ?~c-zf9 is shown. For a given 
fts (M, G), the following algorithm constructs an 
nc-lfg G' such that L(G') --- yL(M, G). 
\ [TRANS 7.2\] Suppose that a given fts (M, G) is 
G -- (N, T, P, S) and M -- (Q, E, A, ql, R) where 
Q = {ql ,q2, '" ,qm}. Let n be the maximum 
length of the right-hand side of a production in P. 
Define an nc-lfg G I = ( N', A, P', S I, N~r, Aatm) 
as follows. 
Step 1: N '={C\ [ J \ ] IC ?N ,  lg j  <m} 
u{aI~l la ? T, 1 < j <_ m}, 
S' = S \[11, 
Nat~ = {atri I1 < i < n} U {rule}, and 
Aatm = {PIP is the label of 
a production in P}. 
A derivation tree t = p( t l , ' "  ,th) in G is rep- 
resented by an f-structure {(rule, p),(atrl, El), 
? ".,(atrh, Fh)} of G' where Fi (1 < i < h) is 
an f-structure which represents the subtree ti 
recursively. 
Each pair of a symbol (either nonterminal or 
terminal) X of G and a state qj of M is rep- 
resented by a single nonterminal X\[J\] in G'. 
137 
Step 2: A move when M at state qj reads a 
symbol p which is the label of a production 
p : C --+ ... ,  can be simulated by a production 
in G ~ whose left-hand side is C\[J\] 
{T ute = p}" 
Formally, the set P~ of productions of G I is con- 
structed as follows. 
(i) Let p : C --* X1 "" Xh be a production in P 
where CE N, Xi E NUT (1 < i  < h), and 
let: 
qj\[p(x\],.. . ,  Xh)\] 
--~ ajoq,7,, \[z~,,, \ ]aj , . . .q,7,zj  \[X~,,L ' \]O~jL, 
be a rule in R where ~k  E A* (0 < k < Lj), 
q'Tj~ E Q, and xvj~ e tX l , ' " ,Xh}(1  < l < 
L j). 
Then, the following production belongs to P~: 
y \ [ r / j l \ ]  V\[nJLj\] C\[J\] 7...40tjo-~vjl Otjl "'" AI~jLj OtjLj" 
{Trute = p) {Tatr  , {Tatr   j 
(ii) Let qj\[a\] ---* flj be a rule in R where a 6 T 
and flj 6 A*. Then the production a\[J\] --~ flj 
belongs to P'.  
(iii) No other production belongs to P'.  
By TRANS 7.1 and TRANS7.2 ,  the fol- 
lowing theorem is obtained. A formal proof is 
found in (Nakanishi 1993). 
Theorem 7.1: f~nc-lfg = Y~'fts. 
Coro l la ry  7.2: ~'dc-lfg ---- Y~.d-fts. 
Proof. In TRANS 7.1, if G is a dc-lfg, then 
no sp E SP  contains distinct productions whose 
left-hand sides are the same and hence the con- 
structed transducer M becomes deterministic by 
the construction. Conversely, in TRANS 7.2, if 
M is deterministic, then there exist no consistent 
productions p~ and p~ in P~ whose left-hand sides 
are the same and hence the constructed nc-lfg is 
a dc-lfg. 
8 Equ iva lence  o f  ~fc- l fg and ?~mcfg 
To prove f~fc-lfg C Lmcfg, we give an al- 
gorithm which translates a given fc-lfg G = 
(N, T, P, S, Nat,, Aatm) into an mcfg G I such that 
L (G') = L (G). 
\ [TRANS 8\] We explain the algorithm by us- 
ing the fc-lfg GEX3 in Example 4.1. An mcfg 
G' = (N', T, F, P' ,  S) is constructed as follows. 
Step 1: N'  = (the set of nonterminals which 
has a one-to-one correspond- 
ence with the set of SPN multi- 
sets in G) 
= {(S), (A,B)} 
(for GEx3 in Example 4.1) 
P '  = ?, and 
F =?.  
Step 2: For each SPN multiset M0 = {{A1,A2, 
? ".,Ak}} of G, consider every tuple (pl,P2, 
"" ,Pk)  of productions in P whose left- 
hand sides are A1, A2,'", Ak respectively and 
which are consistent. (Suppose that, if we 
write an SPN multiset as {{A1, A2,. " ,  Ak}}, 
then Aj's are arranged according to a pre- 
defined total order < on N, that is, A1 < 
A2 <_ "'" <_ Ak hold.) For an SPN multiset 
{{A, B}} in GEX3, the following two pairs of 
productions have to be considered: 
b p12 : A ---* a {TcouAt,~ 
PI3 : B ~ c B d ,  
{Tcount --~} 
p14: {Tcoun A = e} 
pls : {Tc?u B=e} 
For (Pl ,P2, '" ,Pk),  a production p' and a 
function f of G' are constructed and added 
to P '  and F, respectively as follows. 
The multiset M of the nonterminals appearing 
in the right-hand side of some pj (1 < j < k) 
are partitioned into multisets M1, M2," -., Mh 
with respect to the S schemata attached 
to the nonterminals in pj's. That is, 
(11//1, M2, - " ,  Mh) are the coarsest partition of 
M such that for each M,, (1 < u < h), the fol- 
lowing condition holds. 
Each nonterminal in M~, has the same S 
schema. 
By the definition, each M= (1 < u < h) is an 
SPN multiset in G. _Construct aproduction of  
mcfg p ' :  hit0 --* f\[M1, f f I2, '" ,  Mh\] where M= 
is the nonterminal of G' which corresponds to 
M=(1 < u < h). Addp '  to P'  and f to F 
where f is defined as follows. Suppose 
pj : Aj ~ ajoBj la j l  "'' BjL~ajL~ (1 < j < k) 
where Aj E N, Bfl E N(1 < l < Lj) and 
ajz E T* (0 < l < Lj), and le t -  - 
= (1 < < h) 
where Cu, E N(1 < v < su). Then, for 1 < 
j < k, the j th  component f\[J\] of f is: 
_ A f\[J\] (X-l, x2 , "  " ' ,  Xh )=ot joYj l  Otjl Yj2 "" ? Y jL j  OtjLj 
where x-u = (xu l ,xu2, ' " ,xus . ) (1  < u < h). 
For j (1 <_ j < k) and l (1 _< l _< nj) ,  if 
z~ 
Bjl = C~,, then yfl-=x~,v. Note that, since 
Mu's are a partition of M, f satisfies Right 
Linearity (see 2.) and hence G' is an mcfg. 
For example, consider the above (P12,P13)- 
The nonterminals appearing in the right-hand 
138 
sides are A and B, and their S schemata re 
the same. Thus, we construct he following 
mcfg production: 
(A, B) --* f l  \[(A, B)\] 
where f l  \[(Xl, x2)\] = (aXlb, cx2d). 
Consider the following pair of productions as 
another example: 
{ ~ :~} bD{Tatr2 p~ : A --* a {TatrB 
---* c D P'2 : B {TatrA=?} {TatrC=j,} {1"air2 --,L} 
The multiset of nonterminals in the right- 
hand sides are partitioned into M1 = 
I{ A, B}} (for arT1) and M~ = {{C, D, D}} for atr2). For (p~,p~), the following mcfg 
production is constructed: 
(A, B) --+ g \[(A, B), (C, D, D)\] 
where g \[(x11, x12), (=21, X22, x23)\]~--(ax12bx22, 
xilx .lc  3). V\] 
Example  8.1: TRANS 8 translates fc-lfg 
GEx3 in Example 4.1 into an equivalent mcfg 
G~x 3 = (N',T, F, P', S I) where N' ,  S' are those 
illustrated in TRANS 8, F = {fo\[(xl,x2)\] = 
XlX2, f l \ [ (X l ,X2) \ ]  = (aXlb, cx2d), f2 ----- (~',~')}, 
and, P '  = {(S)  --+ fo\[(A,B)\], (A,B) --* 
fl \[(A, B)\], (A, B) --~ f2}. 0 
Theorem 8.1: ~rncfg = Efc- l fg.  
Proof: ?yc-tfg C ?mcf9 can be proved by 
TRANS 8. Conversely, for a given mcfg G, an 
fc-lfg G' such that L (G') = L (G) can be con- 
structed in a similar way to TRANS 8. Details 
are found in (Ando 1992). \[1 
9 Conc lus ion  
In this paper, we introduce three subclasses of 
lfg's, two of which can be recognized in polyno- 
mial time. Also this paper clarifies the relations 
between the generative capacities of those sub- 
classes, pmcfg's and fts'. 
Re ferences  
Ando, S. et al 1992. "Subclasses of Lexical- 
Functional Grammars Which Are Recognizable 
in Polynomial Time", IEICE Technical Report, 
COMP92-44. 
Engelfriet, J. and Heyker, L. 1991. "The String Gen- 
erating Power of Context-Free Hypergraph Gram- 
mars", J. Comput. & Syst. Sci., 43:328-360. 
Engelfriet, J., Rosenberg, G. and Slutzki, G. 1980. 
"Tree Transducers, L Systems, and Two-Way Ma- 
chines", J. Comput. & Syst. Sei., 20:150-202. 
Joshi, A.K., Levy, L. and Takahashi, M. 1975 "Tree 
Adjunct Grammars", J. of Comput. & Syst. Sci., 
10:136-163. 
Gazdar, G. and Pullum, G.K. 1985. "Computa- 
tionally Relevant Properties of Natural Languages 
and Their Grammars", New Generation Computing, 
3:273-306. 
Kaji, Y. et al 1992. "Parallel Multiple Context- 
Free Grammars and Finite State Translation Systems 
", IEICE Technical Report, COMP92-34. 
Kaplan, R. and Bresnan, J. 1982. "Lexical- 
Functional Grammar", The Mental Representation 
of Grammatical Relations, J.Bresnan (ed.), MIT 
press:173-281. 
Kasami, T. et al 1988a. "Generalized Context-Free 
Grammars and Multiple Context-Free Grammars", 
Trans. IEICE, J71-D-I ,  5:758-765. 
Kasami, T. et al 1988b. "On the Membership Prob- 
lem for Head Language and Multiple Context-Free 
Languages, Trans. IEICE, J71-D-I ,  6:935-941. 
Nakanishi, R. et al 1993. "On the Generative 
Capacity of Tree Translation Systems and Lexi- 
cal Functional-Grammars", Technical Paper of FAI, 
Japanese Society for Artificial Intelligence, SIG- 
FAI-9202. 
Nakanishi, R. et al 1992. "On the Generative Capac- 
ity of Lexical-Functional Grammars", IEICE Trans. 
Inf. and Syst., 75-D, 7:509-516. 
Nishino, T. 1991. "Mathematical Analysis of Lexical- 
Functional Grammars --Complexity, Parsability, and 
Learnability--", Language Research Institute, Seoul 
National University. 
Nishino, T. 1992. "Relating Attribute Grammars 
and Lexical-Functional Grammars", Information Sci- 
ences, 66:1-22. 
Peterson, J.L. 1981. "Petri Net Theory and the Mod- 
eling of Systems", Prentice-Hall. 
Pollard, C.J. 1984. "Generalized Phrase Structure 
Grammars, Head Grammars and Natural Language", 
Ph.D. dissertation, Stanford University. 
Rounds, W.C. 1969. "Context-Free Grammars on 
Trees", Proc. of ACM STOC:143-148. 
Seki, H. et al 1991. "On Multiple Context- 
Free Grammars", Theoretical Computer Science, 88, 
2:191-229. 
Thatcher, J.W. 1967. "Characterizing Derivation 
Trees of Context-Free Grammars through a Gener- 
alarization of Finite Automata Theory". J. Comput. 
& Syst. Sci., 1:317-322. 
Vijay-Shanker, K. 1987. "A Study of Tree Adjoining 
Grammars", Ph.D. thesis, University of Pennsylva- 
nia. 
Vijay-Shanker, K., Weir, D.J. and Joshi, A.K. 1987. 
"Characterizing structural descriptions produced by 
various grammatical formalisms", Proc. of 25th 
meeting of Assoc. Comput. Ling. :104-111. 
Weir, D.J. 1988. "Characterizing Mildly Context- 
Sensitive Grammar Formalisms", Ph.D. thesis, Uni- 
versity of Pennsylvania. 
Weir, D.J. 1992. "Linear Context-Free Rewriting 
Systems and Deterministic Tree-Walking Transduc- 
ers", Proc. of 30th meeting of Assoc. Comput. Ling. 
139 

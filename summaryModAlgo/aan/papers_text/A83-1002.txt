PROBLEMS IN NATURAL-LANGUAGE INTERFACE TO DSMS 
WITH EXAMPLES FROM EUFID 
Marjorie Templeton  
John Burger 
System Development Corporation 
Santa Mortice, California 
ABSTRACT 
For five years the  End-User Friendly 
Interface to Data management (EUFID) pro- 
ject team at System Development Corpora- 
tion worked on the design and implementa- 
tion of a Natural-Language Interface 
(NLI) system that was to be independent 
of both the application and the database 
management system. In this paper we 
describe application, natural- language 
and database  management problems involved 
in NLI development, with specific refer- 
ence to the EUFID system as an example. 
I INTRODUCTION 
From 1976 to  1981 SDC was invo lved  
in  the  deve lopment  o f  the  End-User  
Friendly Interface to Data management 
(EUFID) system, a natura l - language inter- 
face (NLI) that is designed to be 
independent of both the application and 
the underlying database management system 
(DBMS). \[TEMP79, TEMP80, BURG80, 
BURG82\]. The EUFID system permits users 
to communicate with database management 
systems in natural English rather than 
formal query languages. It is assumed 
that the application domain is well 
defined and bounded, that users share a 
common language to address the applica- 
tion, and that users may have little 
experience with computers or DBMSs but 
are competent in the application area. 
At least three broad categories of 
issues had to be addressed during EUFID 
development, and it is apparent that they 
are common to any general natural- 
language interface to database management 
systems. 
The first category involves the 
application: how to character ize  the 
requirements of the human-machine dialo- 
gue and interaction, capture that infor- 
mation efficiently, formalize the infor- 
mation and incorporate that knowledge 
into a framework that can be used by the 
system. The major problems in this area 
are knowledge acquisition and representa- 
tion. For many NLI systems, bringing up 
a new application requires extensive 
effort by system designers with coopera- 
tion from a representative set of end- 
users. Tools that could assist in 
automating this process are badly needed. 
The second set of issues involves 
language processing techniques: how to 
assign constituent structure and 
interpretation to queries using robust 
and general methods that al low extension 
to additional lexical items, sentence 
types and semantic relationships. Some 
NLI systems dist inguish the assignment of 
syntactic structure, or  parsing, from the 
interpretation. Other systems, including 
EUFID, combine information about consti- 
tuent and semantic structure into an 
integrated semantic grammar. 
The third class involves database 
issues: how to actual ly perform the 
intent of the natural- language question 
by formulating the correct structured 
query and eff ic iently navigat ing through 
the database to retrieve the right 
answer. This involves a thorough under- 
standing of the DBMS structure underlying 
the appl icat ion,  the operations and func- 
tions the query language supports, and 
the nature and volati l i ty of the data-  
base. 
Obviously issues in these three 
areas are related, and the knowledge 
needed to deal with them may be distr i-  
buted throughout a natura l - language 
interface system. The purpose of this 
paper is to show how such issues might be 
addressed in NLI development, with illus- 
trations from EUFID. 
The next section includes a brief 
review of related work, and an overview 
of the EUFID system. The third section 
describes the goals that EUFID achieved, 
and section four discusses in detail ~ome 
of the major application, language, and 
database problems that arose. Section 
five suggests guidelines for determining 
whether an application is an appropriate 
target for a natural- language interface. 
II BACKGROUND 
Over the past two decades a consid- 
erable amount of work has gone into the 
development of natural-language systems. 
Early developments were in the areas of 
text processing, syntactic parsing tech- 
niques, machine translation, and early 
attempts at Engl ish- language question 
answering systems. Several early 
quest ion-answering experiments are 
reviewed by R. F. Simmons in \[SIMM65\]. 
Waltz has edited a col lect ion of short 
papers on topics related to natural-  
language and artificial intel l igence in a 
survey of NLI research \[WALT77\]. A sur- 
vey of NLIs and evaluation of several 
systems with respect to  their applicabil- 
ity to command and control environments 
can be found in \[OS179\]. 
A. RELATED WORK 
While few NLIs have reached the com- 
mercial marketplace, many systems have 
contr ibuted to advancing the state of the 
art. Several representative systems and 
the problems they addressed are described 
in this section. 
i. CONVERSE \[KELLT1\] used formal syn- 
tactic analysis to generate surface- 
and deep-structure parsings together 
with formal semantic transformation 
rules to  produce queries for a 
bui lt- in relational DBMS. It was 
written in SDC LISP and ran on IBM 
37@ computers. Started in 1968, it 
was one of  the first natural-  
language processors to be built for 
the purpose of querying a separate 
data management system. 
2. LADDER \[HEND77\] was designed to 
access large distr ibuted databases. 
it is implemented in INTERLISP, runs 
on a PDP-I@, and can interface to 
different DBMSs with proper confi-  
guration. It uses a semantic gram- 
mar and, like EUFID and most NLIs, a 
di f ferent grammar must be defined 
for each application. 
3. The Lunar Rocks system LSNLIS 
\[WOOD72\] was the first to use the 
Augmented Transit ion Network (ATN) 
grammar. Wrl~ten in LISP, it 
transformed formally parsed ques- 
tions into representations of the 
first-order predicate calculus for 
deductive processing against a 
built- in DBMS. 
4. PHLIQAI \[SCHA77\] uses a syntactic 
parser which runs as a separate pass 
from the semantic understanding 
passes. This system is mainly 
i nvo lved  w i th  prob lems o f  semant ics  
and has three  separate  layers  o f  
semantic understanding. The layers 
are called "English Formal 
Language", "World Model Language", 
and "Data Base Language" and appear 
to correspond roughly to the "exter- 
nal", "conceptual",  and "internal" 
views of data as descr ibed by C. J. 
Date \[DATE77\]. PHLIQAI can inter- 
face to a var iety of database struc- 
tures and DBMSs. 
5. The Programmed LANguage-based 
Enquiry System (PLANES) \[WALT78\] 
uses an ATN based parser and a 
semantic case frame analysis to 
understand questions. Case frames 
are used to handle pronominal and 
el l ipt ical reference and to generate 
responses to  clar i fy part ia l ly  
interpreted questions. 
6. REL \[THOM69\], init ial ly written 
ent irely in assembler code for an 
IBM36@, has been in cont inuous 
development since 1967. REL al lows 
a user to make interactive exten- 
sions to the grammar and semantics 
of the system. It uses a formal 
grammar expressed as a set of gen- 
eral re-write rules with semantic 
transformations attached to each 
rule. Answers are obtained from a 
bui lt - in database. 
7. RENDEZVOUS \[CODD74\] addresses the 
problem of certa inty regarding the 
machine's understanding of the 
user's question. It engages the 
user in dialogue to specify and 
disambiguate the question and will 
not route the formal query to the 
relational DBMS until the user is 
satisf ied with the machine's 
interpretation. 
8. ROBOT \[HARR78\] is one of the few NLI 
systems current ly avai lable on the 
commercial  market. It is the basis 
for Cul l inane's OnLine English 
\[CULL80\] and Arti f ic ial  Intel l igence 
Corporat ion's Intellect \[EDP82\]. It 
uses an extracted version of the 
database for lexical data to assist 
the ATN parser. 
9. TORUS \[MYLO76\], like RENDEZVOUS, 
engages the user in a dialogue to 
specify and disambiguate the user's 
question. It is a research oriented 
system looking at the problems of 
knowledge representation, and some 
effort has been spent on the under- 
standing of text as well as ques- 
tions. 
B. OVERVIEW OF EUFID 
EUFID is a general purpose natural- 
language front-end for database manage- 
ment. The original design goals for 
EUFID were: 
- to be application independent. This 
means that the program must be table 
driven. The tables contain the dic- 
tionary and semantic information and 
are loaded with appl icat ion-specif lc 
data. It was desired that the 
tables could be constructed by some- 
one other than the EUFID staff, so 
that  users could build new applica- 
tions on their own.  
- to be database independent. This 
means that the organization of the 
data in the  database must be 
representable in tables that drive 
the query generator. ~ A database 
reorganization that does not change 
the semantics of the application 
shou ld  be t ransparen~ to  the  user .  
- to be DBMS independent. This means 
that it must be able to generate 
requests to different DBMSs in the 
DBMS's query language and that the 
interface of EUF~D to a different 
DBMS should not require changes to 
the  NLI modules. Transferring the 
same database with the same semantic 
content to another DBMS should be 
transparent to the natural-language 
users. 
- to run on a mini-computer that might 
possibly be different from the com- 
puter with the DBMS. 
- to have a fast response time, even 
when the question cannot be inter- 
preted. This means it must be able 
quickly to recognize unanalyzable 
constructs. 
- to handle nonstandard or poorly- 
formed (but, nevertheless, meaning- 
ful) questions. 
- to be portable to various machines. 
This means that the system had to be 
* We make a technical dist inction 
between the words "question" and 
"query". A question is any string 
entered by the user to the EUFID 
analyzer, regardless of the 
terminating punctuation. This is 
consistent with the design since 
EUFID treats all input as a request 
for information. A query is a formal 
representation of a question in 
either the EUFID intermediate 
language IL, or in the formal query 
language of a DBMS. 
written in a high level language; 
init ial ly a customer required code 
to be written in FORTRAN, later we 
were able to use the "C" programming 
language. 
- to support different views of the 
data for security purposes. 
The design which met these requirements 
is a modular system which uses an Inter- 
mediate Language (IL) as the output of 
the  natural- language analysis system 
\[BURG82\]. This language represents, in 
many ways, the union of the capabi l i t ies 
of many "target" DBMS query languages. 
The EUFID system consists of three 
major modules, not counting the DBM3 (see 
Figure I). The analyzer (parser) module 
is table driven. It is necessary only to 
properly build and load the tables to 
interface EUFID to a new application. 
Mapping a question from its d ict ionary 
(user) representation to DBMS representa- 
tion is handled by mapping functions con- 
tained in a table and applied by a 
separate  module, the  "mapper". Each con-  
tent (application dependent) word in the 
dict ionary has one or more mapping func- 
tions defined for it. A final stage of 
the mapper is a query- language generator 
containing the syntax of IL. This stage 
writes a query in IL using the 
group/field names found by the mapper to  
represent the user's concepts and the 
structural relationships between them. 
This design satisfies the  requirement of 
application independence. 
ENGLISH 
QUESTION P, ESPO~SE 
t t 
Figure i: EUFID Block Diagram 
For each different DBMS used by a 
EUFID application, a "translator" module 
needs to be written to convert a query in 
IL to the equivalent in the DBMS query 
language. This design satisfies the 
requirement of DBMS independence. 
Other modules are the system con- 
troller, a "help" module, and a "synonym 
editor". An "Application Definition 
Module" is used off-l ine to assist in the 
creation of the run-time application 
description tables. 
The following subsections descrloe 
each of the modules of the EUFID system, 
and give our motivat ion for design. 
i. A~plication Definit ions 
Bringing up a new appl ication is a 
long and complex process. The database 
def init ion must be transmitted to EUFID. 
A large corpus of "typical" user ques- 
tions must be col lected from a represen- 
tative set of users and from these the 
dict ionary and mapping tables are  
designed. A "semantic graph" is defined 
for the application. This graph is 
implicit ly realized in the dict ionary 
where the nodes of the graph are the 
def in i t ions of English content words and 
the connect iv i ty  of the graph is implied 
by the case-structure relat ionships 
defined for the nodes. 
All d ict ionary and mapping-funct ion 
data are then entered into computer files 
which are processed by the Appl icat ion 
Definit ion Module (ADM) to produce the  
run-time tables. These final tables are 
complex structures of pointers, character 
strings, and index tables, designed to 
decrease access time to the information 
required by the analyzer and mapper 
modules. 
The ADM, typically, needs to be run 
several times to "debug" the tables. 
EUFID interfaces to  three appl icat ions 
current ly exist, and building tables for 
each new appl icat ion took less time than 
the previous one, but  it still requires 
several staff-months to bring up a new 
application. 
a. User-View Representation 
All information on the user's view 
of the database is kept in the dict ion- 
ary. The dict ionary consists of two 
kinds of words and definit ions. Function 
words, such as preposit ions and Conjunc- 
tions, are pre-stored in each 
appl icat ion's dict ionary and are used by 
the analyzer for direction on how to con- 
nect the semantic-graph nodes during 
analysis. Content words are appl ication 
dependent. The d -c rOons  of content 
words are semantic-graph nodes. The con- 
nectivity o? the graph is indicated by 
semantic case slots and pointers con- 
tained in the nodes. A form of 
semant ic -case  is used to  indicate the 
attr ibutes of an entity (e.g., adjec- 
tives, preposit ional phrases, and other 
modif iers of a noun). 
b. Mapping Functions 
The list of mapping functions is 
derived from the dictionary. Every pos- 
sible connection of every node has to be 
considered. Frequently, desig~ :o,~- 
s iderat ions in the mapping- funct ion list 
necessitate going back and modifying the 
content of the dict ionary. This is an 
example of the over lap of the l inguist ic  
and database issues in assigning an 
interpretation to a question. 
c. Database Representat ion 
The structure of  the data  in the 
user's database is represented in two 
tables, called the CAN (for canonical) 
and REL (for relationships) tables. Tak- 
ing advantage of the fact that any data- 
base can be represented in relational 
form, EUFID lists each database group as 
if it were a relation. Group-to-group 
l inkage (represented in the REL table) is 
dealt  with as if a join* were necessary 
to implement the link. For hierarchical  
and network DBMSs the join will not be 
needed: the link is "wired in" to the 
database structure. EUFID nevertheless 
assumes a join mainly in order to faci l i -  
tate the writ ing of group-to-group links 
in IL, which is a relational language. 
The CAN table includes database-speci f ic  
information for each field (attribute) of 
each group (relation), such as field 
name, containing group, name of domain 
from which attr ibuted gets its values, 
and a pointer to a set of conversion 
functions for numeric values which can be 
be used to convert from one unit of meas- 
ure to another (e.g., feet to meters). 
These data are used by the run-t ime 
modules which map and translate the 
tree-structured output of the analyzer to 
IL on the actual group/f ie ld names of the 
database, and then co the language of the 
DBMS. These modules are discussed in the 
next sections. 
2. The EUFID Analyzer 
The current version of the EUFID 
analyzer employs a variant of the Cocke- 
Kasami-Younger algorithm for parsing its 
input. This classical nonpredict ive 
bottom-up algorithm has been used in a 
family of "chart parsers" developed by 
Kay, Earley, and others \[AHO72\]. The 
main features of these parsers are: (i) 
They use arbitrary context- free grammars. 
There are no restr ict ions on rules which 
have left-recursion or other character is-  
tics which sometimes cause diff iculty. 
(2) They produce all possible parses of a 
given input string. The grammars they 
use may be ambiguous at either the 
nonterminal-  or terminal-symbol levels. 
In natural - language processing, this 
allows for a precise representat ion of 
* The term "join" refers to a composite 
operation between two relations in a 
relational DBMS. 
both the syntactic and lexical ambigui- 
ties which may be present in an input 
sentence. (3) They provide partial 
parses of the input. Each non-terminal 
symbol derives some input substring. 
Even if no such substring spans the 
entire sentence, i.e., no complete parse 
is achieved, analyses of various regions 
of  the  sentence  are  available. (4) They 
are conceptual ly straightforward and easy 
to  implement. The speed and storage con- 
siderations which have kept such parsers 
from being widely used in compilers are 
less relevant in the analysis of  short 
strings such as queries to a DBMS. 
The grammar used by the EUFID parser 
is essential ly semantic. The symbols of 
the grammar represent  the  concepts under- 
lying lexical items, and the  rules 
specify the ways in which these concepts 
can be combined. More spec i f i ca l l y ,  the  
concepts are organ ized  into a case sys- 
tem. Each rule states that a given pair 
of constituents can be linked if the con- 
ceptua l  head of one constituent fills a 
case on the conceptual head of the  other. 
A degree of context  sensit ivity is 
achieved by attaching predicates to the 
rules. These pred icates  b lock  applica- 
tion of the  rules unless certain (usually 
syntactic) conditions hold true. The 
parser uses syntactic information only 
"on demand", that is, only when such 
information is necessary to reso lve  
semantic ambiguities. This adds to its 
coverage and robustness, and makes it 
relatively insensitive to the phrasing 
variations which must be explicit ly 
accounted for in many other systems. 
3. Mapping 
The mapper module converts the out- 
put of the analyzer to input for the 
translator module. Analyzer output is a 
tree structure where the nodes are 
semantic-graph nodes corresponding to the 
content words in the user's question and 
obtained from the dictionary. 
Input to the translator module is a 
string in the syntax of IL which contains 
the names of actual groups and fields in 
the database. The mapping algorithm, 
thus, has to make several levels of 
conversion simultaneously: 
- it must convert a tree structure 
into a linear string of tokens, 
- it must convert semantic-graph nodes 
into database group- and field- 
names, and 
- it must convert the connectivity of 
the tree (representing concept-to- 
concept linkage in English) into the 
(frequently very different) group- 
to-field and group-to-group connec- 
tions of the  database. 
The mapper makes use of a table of 
mapping functions. The table contains at 
least one mapping function for every con- 
tent word in the dictionary. The 
analyzer's tree is traversed bottom up, 
applying mapping functions to each node 
on the  way. Mapping funct ions  are con-  
text  sensit ive with respect to those 
nodes below it in the tree: nodes that 
have already been mapped. A new tree is 
gradual ly formed and connected this way. 
Mapping functions may indicate that the 
map of a semantic-graph node is a data- 
base node (that is, a group or field 
name), or  a pre-connected sub- t ree  of 
database nodes. The mapping function may 
also indicate removal of a database node 
or modif icat ion to the existing structure 
of the tree being constructed. 
The new t ree  i s  c reated  in  te rms  o f  
the  database  groups  and f ie lds  and i t s  
s t ruc ture  re f lec ts  the  connect iv i ty  o f  
the database. A final stage of the 
mapper traverses this new tree and gen- 
erates the EL statement of the query 
using a table of the syntax and keywords 
of EL and the database names from the 
tree. 
An alternative method of mapping 
that i s  now being investigated involves 
breaking the process into two basic 
parts. The first step would be to map 
the tree output  o f  the analyzer to  an I L  
query on what C. J. Date calls the "con- 
ceptual schema" of the database \[DATE77\]. 
A second step would take this IL input 
and re-arrange the schema connectivity 
(and names of groups and fields) from 
that of the conceptual schema to that of 
the actual target database, generating 
another IL query as input to the current 
translators. 
4. Trans la t in~ 
The final run-time module in EUFID 
is a syntax translator that converts IL 
to the actual DBMS query language. If 
necessary, the translator can also add 
access-path information related to data- 
base search. Currently, two translators 
have been written. One converts IL to 
QUEL, a relatively simple conversion into 
the language of the relational database 
management system INGRES \[STONY6\]. The 
other translator converts IL into the 
query language of the World-Wide Data 
Management System (WWDMS) \[HONE76\] used 
by the Department of Defense, and also 
handles additional access path informa- 
tion. This translator was quite diff i-  
cult to design and build because of the 
highly procedural nature of the WWDMS 
query system. 
The output of a translator is sent 
to the appropriate DBMS. In the EUFID 
system running at SDC, a QUEL query is 
submitted direct ly to INGRES running on 
the same PDP-II/70 as EUFID. For testing 
purposes, queries generated by the WWDMS 
translator were transmitted from a PDP- 
11/70 to a Honeywell H6000 with a WWDMS 
database. 
5. Appl icat ion Descript ion 
EUFID runs on three di f ferent appli-  
cation databases. The METRO appl icat ion 
involves monitoring of shipping transac- 
tions between companies in a city called 
"Metropolis".  There are ten companies 
located in any one of three neighbor- 
hoods. Each company rents warehouse 
space for shipping/recelving transac- 
tions, and has local off ices which 
receive goods. The data is organized 
telat ional ly using the INGRES database 
management system. That means that there 
are no navigational links stored in the 
records (called "relations") and there is 
no predefined "root" to the database 
structure. Access may be made from any 
relation to any other relation as long as 
there is a field in each of the two rela- 
tions which has the same "domain" (set of 
values). 
AIREP (ADP Incident REPorting) is a 
network database, implemented in WWDMS. 
It contains reports about hardware and 
software failures and resolution of the 
problems in a large computer system. 
Active problems are maintained in an 
active file and old, solved problems are 
moved to an historical file. If a prob- 
lem \[s reported more than once, an abbre- 
viated record is made for the addit ional 
report, called the "duplicate incident" 
record. This means that there are four 
basic type of report: active incidents, 
dupl icate incidents, historical 
incidents, and historical dupl icate 
incidents. In addition, there are 
records about sites, problems, and solu- 
tions. 
The APPLICANT database is a rela- 
tional database implemented in INGRES 
that contains information about job 
applicants and their backgrounds. The 
central entity is the "applicant", while 
other relations describe the appl icant's 
specialties, education, previous employ- 
ment, computer experience, and inter- 
views. 
Each database has dif ferent features 
chat may present problems for a natural- 
language interface but which are typical 
of 'real-world' applications. METRO has 
relatively few entit ies but has complex 
relationships among them. APPLICANT has 
many updates and many dif ferent values, 
some coming from open-ended domains. 
AIREP has a network database structure 
and contains the same data structure in 
four di f ferent files. 
III LEVEL OF SUCCESS 
Most of the EUFID design goals were 
actual ly met. EUFID runs on a mini-  
computer, a DEC PDP 11/70. It is appli-  
cation, database, and DBMS independent. 
A typical quest ion is analyzed, mapped 
and translated in five to fifteen seconds 
even with grammatica l ly  incorrect input. 
The analyzer contains a good spel- 
ling corrector and a good morphology 
algorithm that strips inf lect ional end- 
ings so that all inflected forms of words 
need not be stored expl icit ly.  A 
"synonym editor" permits the user to  
replace any word or string of words in 
the dic ionary with another word or 
string, to accommodate personal jargon 
and expressabi l i ty.  A "Concept Graph 
Editor s allows a database administrator 
to modify tables and define user profi les 
so that di f ferent users may have l imited 
views of the data for security purposes. 
The analysis strategy, based on a 
semantic grammar, permits easy and 
natural paraphrase recognit ion, although 
there are l inguist ic constructs it cannot 
handle. These are discussed below. 
An English word may have more than 
one def init ion without complicat ing the 
analysis strategy. For example, "ship" 
as a vessel and as a verb meaning "to 
send" can be defined in the same dict ion- 
ary. Words used as database values, such 
as names, may also have mult iple def ini -  
tions, e.g., "New York" used as the name 
of both a city and a state. 
The mapper, despite its many l imita- 
tions, can correct ly map almost all trees 
output by the analyzer. It is able to 
handle English conjunctions,  mapping them 
appropriately to logical ANDs or ORs, and 
understanding that some "ands" may need 
to be interpreted as OR and vice-versa 
under certain circumstances.  It is able 
to generate calls on DBMS calculat ions 
(e.g., average) and user-defined func- 
tions (e.g., marine great-c irc le dis- 
tance) if the user-function exists and is 
supported by the DBMS. 
Questions involving time are inter- 
preted in a reasonable way. Functions 
are defined for "between" and "during" in 
the METRO application. The AIREP appl i -  
cation allows time comparisons such as 
"What system was running when incident 
J123 occurred" which require a test to 
see if a point in time is within an 
interval. 
The mapper can translate "user 
values" (e.g., "Russian") to database 
values (e.g., "USSR"), and convert one 
unit of measure (e.g., feet) to another 
(e.g., meters). 
EUFID can in ter face  to  very  complex  
relational and CODASYL-type databases  
having diff icult  nav igat ion  and para l le l  
structures. In the  AIREP application a 
cons is tent  WWDMS navigational methodology 
i s  used to  access  non-key  records .  The 
system can also map to the  parallel, but 
not  identical, structures for duplicate 
and historical incidents. 
In  the INGRES applications, EUFID is 
ab le  to use and correctly map to =re la -  
t ionsh ip  re la t ions"  wh ich  re la te  two or  
more o ther  re la t ions .  For  example ,  the  
METRO relation =cw" conta ins  a company 
name, a warehouse name, and a date. This 
represents  the  in i t ia l  bus iness  contact. 
A user  might  ask, =When d id  Co lon ia l  
s ta r t  to  do bus iness  w i th  Super io r?  = or  
? When d id  bus iness  beg in  between Co lon ia l  
and Super io r?  = , e i ther  o f  wh ich  must  ~o in  
both  the  company ( "c  =) and the  warehouse  
('w') relations to  the =cw" relation. 
The system cont ro l  module keeps a 
journal of all user-system interaction 
together with internal module-to-module 
data such as the IL for the user's ques- 
tion and the generated DBMS query. The 
system also employs a very effective HELP 
module which, under cer ta in  cir- 
cumstances, is context sensitive to  the 
problem affecting the user. 
IV PROBLEMS 
This section describes problems 
associated with EUFID development that 
appear to be common to natural- language 
interfaces to database management sys- 
tems. They are loosely classif ied into 
the major areas Of application, language 
and database management issues, although 
there may be overlap. Criteria for 
evaluating whether an application is 
appropriate for a natural- language 
front-end are also described. 
A. APPLICATION DEFINITION PROBLEMS 
The primary issue in this area is 
concerned with problems of defining, 
creating, and bringing up the necessary 
data for a new application. The discus- 
sion points out the diff icult ies associ- 
ated with systematic knowledge acquisi- 
tion. 
I. User Model 
A single database may be used by 
different groups of users for different 
purposes. For example, some users of the 
APPLICANT database may wish to fill a 
specific Job opening while others may 
collect statist ics on types of appli~ 
cants. The language used for these two 
functions can be quite different, and it 
is necessary to have extensive interac- 
tion with cooperative users in order to 
characterize the kinds of dialogues they 
will have with the system. 
Not on ly  must representative 
l anguage protoco ls  be co l lec ted ,  but  
desired responses must be understood. 
For example, to answer a question such as 
=What is the  status of our forces in 
Europe = , the system must know whether 
'our' refers to U.S. or NATO or some 
other unit. 
The importance of this interaction 
between potential users and system 
deve lopers  should not  be underestimated, 
as  i t  i s  the  bas i s  fo r  de f in ing  much of  
the knowledge base needed by the system, 
and may also be the  basis for eventual 
user acceptance or  rejection of the NLI 
sys tem.  
2. Value Recogn i t ion  
A "value = is a specific datum stored 
in the database, and is the smallest 
piece of data obtainable as the result of  
a database query. For example, i n  
response  to  the  quest ion  "What companies 
in North Hills shipped light freight to 
Superior? = the METRO DBMS returns two 
values: "Colonial" and "Supreme'. Values 
can also be used in a query to qualify or 
select certain records for output, e.g., 
in the  above question "North Hills" and 
"Superior" are values that must be 
represented in the query to the DBMS. As 
long as the alphanumeric values used in a 
particular database field are the same as 
words in the  English questions, there are 
no diff icult problems involved in recog- 
nizing values as selectors in a query. 
There are three basic ways to recog- 
nize these value words in a question. 
They can be explicit ly listed in the dic- 
tionary, recognized by a pattern or con- 
text, or found in the database itself. 
If the value words are stored in the 
dictionary, they can be subject to spel- 
ling correction because the spelling 
corrector uses the dict ionary to locate 
words which are a close match to unrecog- 
nized words in a question. This means, 
though, that all possible values and 
variant legitimate spell ings of values 
for a concept must be put either into the 
dict ionary or into the synonym list. 
This is reasonable for concepts which 
have a small and controlled set of 
_values* such as the names of the 
* A set of va lues  is called a "domain ,r. 
companies in METRO, but may become 
unwieldy for large sets of values. 
If a value can be recognized by a 
pattern, it is not necessary to itemize 
all instances in the dict ionary. For 
example, a date may be entered as 
"yy/mm/dd" so that any input matching the 
pattern "nn/nn/nn" is recognized as a 
date. This is the approach used for 
dates and for names of appl icants in the 
APPLICANT database, where names of people 
match the pattern "I . I .Lastname". 
In another approach, OnLine English 
\[CULL80\] and Intellect \[HARR78, EDP82\] 
(two var iat ions of ROBOT) used the data- 
base to recognize values. This is a 
sat isfactory solution if the database is 
small or if the small number of di f ferent 
values is stored in an index accessible 
to the NLI, and if the values in the 
database are suitable for use in English 
questions. 
Each of these solutions has disad- 
vantages. If values are stored in the 
dict ionary there may be many dif ferent 
ways to spell each particular value. For 
example, the company name for "System 
Development Corporation" may also be 
given as "S.D.C.", "S D C", or "System 
Development Cotp". While each dif ferent 
spell ing could be entered as a synonym 
for the "correct" spell ing in the data- 
base, this would result in an enormous 
prol i ferat ion of the dict ionary entries 
and problems with concurrency control 
between the updates directed to the data 
management system and the updates to the 
dictionary. A creative solution might he 
to define rules for synonym generation 
and apply them to database updates. 
A somewhat different example is from 
the APPLICANT appl ication which has many 
open ended domains, such as names of 
applicants and previous employers. In 
this case, the appl ication designer may 
have to treat certain fields as 
"retr ieve-only", meaning that the data 
can be asked ~or but not used as a selec- 
tion criterion. A database with a large 
number of retr ieve-only fields may be a 
poor candidate for an NLI. 
Patterns can be used only if they 
can be enforced, and probably few values 
really fit the patterns nicely. Proper 
names ate a poor choice for patterns 
because of variat ions such as middle ini- 
tial or title such as "Dr." or "Jr.". 
Also, spell ing correction cannot be per- 
formed unless the value is stored in the 
dictionary. 
Finally, the solution of using the 
database itself to recognize values is 
unsat is factory to a general NLI for any- 
thing other than trivial databases, 
unless an inverted index of values is 
easi ly accessible. There are the prob- 
lems of spell ing correct ion and synonyms 
for database values, the inef f ic iency 
involved in accessing the DBMS for 
every unrecognized word, and the di f f i -  
culty of knowing which fields in the 
database to search. 
3. Semantic Variat ion By Value 
Databases are general ly  designed 
with a minimum number of d i f ferent  record 
types. When there are entit ies which are 
similar, but possibly have a small number 
of attr ibutes which are not shared, the 
entit ies will be stored in the same 
record type with null values for the 
attr ibutes that do not apply. The user, 
in his questions, may view these similar 
entit ies as very di f ferent entit ies and 
talk about them dif ferently.  
We did not encounter the problem 
with METRO or AIREP. For example, in 
METRO, the user asks the same type of 
quest ions about the company named "Colo- 
nial" as about the company named 
"Supreme". In APPLICANT, however, each 
appl icant has a set of "specialt ies" such 
as "computer programmer", "accounting 
clerk", or "gardener". These are all 
stored as values of the specialty field 
in the database. Unfortunately, in this 
case di f ferent specialt ies evoke com- 
pletely di f ferent concepts to the end 
user. The user may ask quest ions such 
as, "What programmers know COBOL?", "Who 
can program in COBOL?", and "How many 
appl icants with a specialty in computer 
programming applied in 1982?". Notice 
the new nouns and verbs that are intro- 
duced by this specialty name. 
A value domain such as specialt ies 
should be handled with an ISA hierarchy. 
Each di f ferent type of specialty such as 
gardener or programmer could have a dif-  
ferent concept that is a subset of the 
concept "specialty". Some quest ions 
could be asked about all specialt ies and 
others could be directed only to certain 
subconcepts. However, there is no \[SA 
hierarchy in EUFID, and it would have 
been ineff icient to treat each specialty 
and subspecialty as a separate concept 
since there are 30 specialt ies and 196 
subspecialt ies.  Therefore, we required 
the users to know the exact values, to 
know which values are for specialt ies and 
which are for subspecialt ies, and to ask 
questions using the values only as nouns. 
This is not "user friendly". 
I0 
Even if it were possible to build a 
different concept for each different 
skill, there is an update problem. When 
a new value is added to a va lue domain 
where there ace uniform semantics (as in 
adding a new company name in METRO), the 
new value is simply attached to the 
existing concept, when the new value has 
different semantics, the  newly associated 
concepts, nouns, and verbs cannot be 
added automatically. If the  NLI supports 
an ISA hierarchy, someone wi l l  need to 
categor i ze  the  new value and add a new 
node to  the  h ie rarchy  or  spec i fy  a pos i -  
t ion  in  the  h ie rarchy .  
4. Automation of Def in i t ion  
A natura l - language in ter face  sys tem 
wi l l  not  be pract i ca l  unt i l  a new app l i -  
ca t ion  can be installed easily. "Easily" 
means that the end-user organization must 
be able to create and modify the driving 
tables for the application relatively 
quickly without the help of the NLI 
developer, and must be able to use the 
NLI without restructuring the database.  
Each EUFID application required 
"handcrafted" tables that were built by 
the development staff. Each new applica- 
tion was done in less time than the pre- 
vious one, but still required several 
staff-months to bring up. Clearly, the 
goal of facil itating the building of the 
tab les  by  end users was not  met .  
Computer -ass i s ted  too ls  fo r  de f in ing  new 
applications are a prerequisite for prac- 
tical NLIs. 
B. LANGUAGE PROBLEMS 
The basic approach to language 
analysis in EUFID involves a bottom up 
parser using a semantic grammar. The 
symbols of the grammar are concepts 
underlying lexical items, and the rules 
of the grammar ace based on a case frame- 
work. Essentially syntactic information 
is used only when needed to resolve ambi- 
guity. The language features that this 
technique has to  handle are common to any 
NLI, and some of the problem areas are 
described in the following sections. 
I .  Anaphora and Ellipsis 
To support natural interaction it is 
desirable to allow the use of anaphoric 
reference and elliptical constructions 
across sentence sequences, such as "What 
applicants know Fortran and C?", "Which 
of them live in California?", "In 
Nevada?", "How many know Pascal?'. One 
of the biggest problems is to define the 
scope of the reference in such cases. In 
the example, it is not clear whether the 
user wishes to retrieve the set  of all 
applicants who know Pascal or only the 
subset  who l i ve  in  Nevada .  
One so lu t ion  i s  to  p rov ide  commands 
that al low users  to def ine  subsets  of the 
database to which to address questions. 
This removes the ambiguity and speeds up 
retrieval time on a large database .  How- 
ever, it moves the NLI interaction toward 
that of a structured query language, and 
forces the user to be aware of the level 
of subset be ing  accessed. It is also 
dif f icult  to implement because a subset 
may i nvo lve  pro jec t ions  and jo ins  to  
build a new relation containing the sub- 
set. The NLI must be able dynamical ly  
and temporari ly to change the mapping 
tables to  map to  this new relation. 
2. Intell l~ent Interaction 
One of the EUFID design goals was to 
respond promptly either with an answer or 
with a message that the question could 
not be interpreted. The system handles 
spelling or typographical errors by  
interacting with the user to  select the 
correct word. However, when all of the 
words are recognized but do not  connect 
semantically, It is diff icult to identify 
a single point in analysis which caused 
the failure. 
It is in this area that the absence 
of a syntactic mechanism for determining 
wel l - formedness was most not iceab le .  
There are times when a question has a 
proper syntactic structure, but contains 
semantic relationships unrecognizable to 
the application as in "What is the loca- 
tlon of North Hills?". A response of 
"Location is not defined for North Hills 
in this appllcacion" should be derivable 
from the recognizable semant ic  failure. 
Similarly, it would be useful to have a 
framework for interpreting partial trees, 
as in the question "What companies does 
Mohawk ship to?" where Mohawk is not a 
recognized word within the application. 
An appropriate response might be "Com- 
panies ship to receiving offices and com- 
panies; Mohawk is ne i ther  a receiving 
office nor a company. The names of 
off ices and companies are . . . " .  
Interpretation of partial analyses  is not 
possible within the EUFID system; it 
either succeeds or fails completely. 
3. Yes/No Questions 
In normal NLI interaction users may 
wish to ask "yes/no" questions, yet no 
DBMS has the abil ity to answer "yes" or 
"no" explicitly. The EUFID mapper maps a 
yes/no question into a query which will 
retrieve some data, such as an "output  
identifier" or default name for a con- 
cept, if the answer is "yes" and no data 
if the answer if "no". However, the 
answer may be "no" for several reasons. 
II 
For example, a "no" response to the ques- 
tion "Has John Smith been interviewed?" 
may mean that the database has knowledge 
about John Smith and about interviews and 
Smith is not listed as having had an 
interview*, or the database knows about 
John Smith and no data about interviews 
is available. A third possibi l i ty could 
be that the database has information 
about John Smith and his employment 
situation (already hired), and the 
response might include that information, 
as in "No, but he has already been 
hired'. 
4. Conjunct ions 
The scope  of conjunct ions is a dif-  
ficult problem for any parsing or analyz- 
ing algorithm. The natural - language use 
of "and" and "or" does not necessar i ly  
correspond to the logical meaning, as in 
the question "List the appl icants who 
live in Cal i fornia and Arizona.". Multi-  
ple conjunct ions in a single question can 
be ambiguous as in "which minor i ty and 
female appl icants know Fortran and 
Cobol?'. This could be interpreted with 
logical "and" or with logical "or" as in 
"Which appl icants who are minor i ty or 
female know either Fortran or Cobol?". 
The EUFID mapper will change English 
"and" to logical "or" when the two 
phrases within the scope of the conjunc- 
tion are values for the same field. In 
the example above, an applicant has only 
one state of residence. 
uncertain whether they should be returned 
in the answer. It is also di f f icult  to 
take a complement of a set of data using 
the many data management systems that do 
not support set operators between rela- 
tions. 
Questions which require a "yes" or 
"no" response are di f f icul t  to answer 
because often the "no" is due to a 
presupposit ion which is invalid. This is 
especial ly  true with negation. For exam- 
ple, if the user asks, "Does every com- 
pany in North Hills except Supreme use 
NH2?", the answer may be "no" because 
Supreme is not in North Hills. 
The current implementation of EUFID 
does not al low expl ic it  negation, 
although some negative concepts are han- 
dled such as "What companies ship to com- 
panies other than Colonial?".  "Other 
than" is interpreted as the "!-" operator 
in exact ly the same way that "greater 
than" is interpreted as ">". 
C. INTERPRETATION AND DATABASE ISSUES 
Many quest ions make perfect sense 
semantical ly  but are di f f icult  to map 
into DBMS queries because of the database 
structure. The problems become worse 
when access is through an NLI because of 
increased expectat ions on the part of the 
user and because it may be di f f icul t  for 
a help system adequately to descr ibe the 
problem to the user who is unaware of the 
database structure. 
5. Nepption 
Negative requests may contain expli- 
cit negative words such as "not" and 
"never" or may contain implicit negatives 
such as "only", "except" and "other than" 
\[OLNE78\]. The interpretation of nega- 
tives can be very diff icult.  For exam- 
ple, "Which companies did not ship any 
perishable freight in 1976" could mean 
either "Which (of all the  companies) 
shipped no perishable freight in 1976?" 
or "Which (of the companies that ship 
perishable freight) shipped none in 
1976?'. Moreover, if some companies were 
only receivers and never shippers it is 
" - "~e is the important dist inct ion 
between a "closed world" database in 
which the assumption is that the 
database covers the whole world (of 
the application) and an "open world" 
database in which it is understood 
that the database does not represent 
all there is to the real world of the 
application. In the open world 
database, which we encounter most of 
the time, a response of "not that 
this database knows of" might be more 
appropriate. 
I. IL Limitations 
The design of the IL is crit ical.  
It must be rich enough to support 
retrieval from all the underlying DBMSs. 
However, if it contains capabi l i t ies that 
do not exist in a specif ic DBMS, it is 
di f f icult  to describe this def ic iency to 
the user. 
In APPLICANT, the user cannot get 
both the major and minor fields of study 
by asking "List appl icants and field of 
study", because a l imitation in the EUFID 
IL prevents making two joins between edu- 
cation and subject records. This problem 
was corrected in a subsequent version of 
IL with the addit ion of a "range" state- 
ment similar to  that used by QUEL 
\[STON76\]. 
The current IL does not contain an 
"EXISTS" or "FAILS" operator which can 
test for the existence of a record. Such 
an operator is frequently used to test an 
interrecord link in a network or 
hierarchical DBMS. It is needed to 
express "What problems are unsolved?" to 
the AIREP application, which requires a 
test for a database link between a 
~Z 
problem set and a solution set. 
2. Mixed Case Values 
EUFID allows a value in the database 
to  be upper or lower case and will con-  
ver t  a value in the question either to  
all upper or all lower case in the IL, or 
leave it as input by  the user. If the 
database values are mixed case, it is not 
poss ib le  to  conver t  the  user ' s  input  to  a 
s ing le  case .  I f  the  user  does  not  enter  
each le t te r  in the  proper  case ,  the  va lue  
will not  match. 
3. Granular it~ Differences 
The NLI user is not  expected to  
understand exactly how data is stored, 
and yet must understand something about 
the granular ity of the data. Time fields 
often cause problems because time may be 
g iven  by year or  by fractions of  a 
second.  Users  may make t ime compar i sons  
that require more granular ity than is 
stored in the  database. For example, the  
user can ask "What incidents were 
reported at SAC while system release 3.4 
was installed?". If incidents were 
repor ted  by day but system release dates 
were given by month, the system would 
return i nc idents  which occurred in the 
days of the month before the system 
release was ins ta l led .  
4. Nested Queries 
A very simple question in English 
can turn into a very complicated request 
in the  query language if it involves 
retrieval of data which must be used fo r  
qualif ication in another part of the same 
query. In IL these are called "nested 
queries". Most of ten  some qualif ication 
needs to be done both  "inside" and "out- 
side" the  clause of the query that does 
the internal retrieve. For example, the  
quest ion  "What i nc ident  a t  SAC had the  
longest  downt ime?"  f rom our  AIREP app l i -  
ca t ion  i s  expressed  in  I L  as 
retrieve \[INCA. ID\] 
where (INCA.SITENAME = "SAC") 
and (INCA.DNTM - 
\[retrieve \[ max (INCA.DNTM)\] 
where (INCA.SITENAME = "SAC")}) 
The nested part of the  query is enclosed 
in braces. "INCA" is the database name 
of the active incident records. Notice 
that removing the "INCA.SITENAME = 'SAC'" 
clause from either the inner or outer 
query would result in an incorrect formu- 
lation of the question. 
A similar example from the METRO 
application is the question, "What com- 
pany shipped more than the average amount 
of light freight in 198~?" which will 
13 
generate  the  IL query  
re t r ieve  \ [cc t . scname\ ]  
where  (cc t .date  ? 198~) 
and (cc t . l f  >-  
{ re t r ieve  \ [avg (cc t . l f ) \ ]  
where (cct.date - 1980)}) 
Here ,  =cct"  i s  the  name o f  the  company-  
to -company transaction relation. 
"Scname" is the name of a shipping com- 
pany in this relation. Note again that 
the  qua l i f i ca t ion  on "198~"  needs  to  be 
done both  i ns ide  and outs ide  the  nested  
par t  o f  the  query. 
In the query language for INGRES 
such a request  i s  expressed  in  a manner  
very  s imi l ta r  to  the  IL express ions .  For  
WWDMS a very  complex  procedure  i s  gen-  
e ra ted .  In a l l  cases ,  the  DBMS needs  to  
answer  the  inner  request  and save  the  
resu l t  fo r  usa in  qua l i fy ing  the  outer  
request .  There  are  many database  manage-  
ment sys tems that  cannot  hand le  such 
quest ions  and these  I L  s ta tements  cannot  
be translated into the system's query 
language. 
5. I ncons is tency  In Retrieval 
The NLI presents a uniform view of 
all databases  and DBMSs, but it is diff i -  
cult to truly mask all dif ferences in the 
behav ior  o f  the  DBMSS because  they  do not  
a l l  p rocess  the  equ iva lent  query  in  the  
same way. For example, when data are 
retrieved from two relations in a rela- 
tional database, the two relations must 
be Jo ined  on a common attribute. The 
answer forms a new relation which may be 
displayed to the  user or  stored. Since 
the join clause acts as qualif ication, a 
record (tuple) in either relation which 
has no corresponding tup le  in the  other 
relation does  not  participate in the 
result. This is a different concept from 
the hierarchical and network models where 
the system retrieves all records from a 
master record and then retrieves 
corresponding records from a subfile. 
This difference can cause anomalies with 
retrieval. For example, in a pure rela- 
tional system "List applicants and thei~ 
interviews" would be treated as "List 
applicants who have had interviews 
together with their interview informa- 
tion." A hierarch ica l  or network DBMS 
would treat it as "List all applicants 
(whether or not  they have  been inter- 
viewed) plus any interview information 
that exists." This second interpreta- 
tion is more likely to be the correct 
one. 
D. OVERALL NLI DESIGN 
There are several problems that 
affect the selection of appl icat ions for 
the NLI. Some databases and data manage- 
ment systems may not be appropriate tar- 
gets for natural - language interfaces. 
Some DBMS functions may be dif f icult  to 
support. It is important to have a clear 
understanding of these problems so that 
the NLI can mediate between the user 
view, as represented by the natural-  
language questions, and the underlying 
database structure. 
i. ~ Design Considerat ion 
For any database there are natural-  
language quest ions that cannot be inter- 
preted because the concepts involved lle 
outside the world of the database. Ques- 
tions can also involve structural com- 
plexity that is not  representable in the 
DBMS query language. A part icular ly  dif- 
ficult decis ion in the overall  design of 
an NLI is the issue of where in the chain 
of events of processing a user's question 
into a DBMS query to trap these quest ions 
and stop processing. 
One approach is to decide that if a 
question is not meaningful to the world 
of the database it should not be meaning- 
ful to the NLI and, therefore, not  
analyzable on semantic grounds. Another 
assumes that if the NLI can analyze a 
question that cannot be asked of the 
database, it has a much better chance of 
describing to the user what is wrong with 
the question and how it might be 
rephrased to get the desired information. 
Codd made good use of the dialogue 
procedures of the RENDEZVOUS \[CODD74\] 
system to avoid questions that the DBMS 
could not handle, as well as avoiding 
generation of DBMS queries that did not 
represent the user's intent. Such a sys- 
tem, however, requires a very large 
semantic base (much larger than that of 
the database) in order to make meaningful 
communicat ion with the user during the 
dialogue. 
2. Class of Database to Support 
Some databases are simply not good 
candidates for an NLI because of charac- 
teristics mentioned in previous sections 
such as many retr ieve-only fields, or 
domains that have a high update rate but 
cannot be recognized by a pattern. 
There are also some structural prob- 
lems chat must be recognized. If the 
database contains "flat" files about one 
basic entity, it is reasonably easy to 
map quer ies  and to  exp la in  prob lems to  
the  user  when the  mapp ing  cannot  be made.  
However, there can be "reasonable" 
queries that cannot be answered direct ly  
because of the database structure. 
Hierarchical DBMSs present the most prob- 
lems with navigation because access must 
start from the root. For example, if the 
APPLICANT database were under an 
hierarchical  DBMS, the question "List the  
specialt ies for each applicant" could be 
answered direct ly  but not "What are the 
specialt ies?" as there would be no way to 
get to the specialty records except via 
particular applicant records. 
An array allows more than one 
instance of a field or set of fields in a 
single record. There may be arrays of 
values or even arrays of sets of values 
in nonrelat lonal databases. When the 
user retr ieves a field that is an array 
the DBMS requires a subscript into the 
array. Either the user must specif ly 
this subscript or the NLI must map to all 
members of the array with a test for 
missing data. 
3. Class of DBMS to Supp%rt 
For systems such as EUFID, the data- 
base must be organized within a data 
managdment system so that the data is 
structured and individual fields are 
named. If the data is just text, the 
EUFID approach cannot be used. 
Current NLI systems are designed to 
be used interact ively by a user, which 
means that the DBMS should also have an 
interactive query language. However, noc 
all data management systems are interac- 
tive. WWDMS \[HONE76\] has a user query 
language, but  queries are entered into a 
batch job queue and answers may not 
return for many minutes. If an Nil front 
end is to be added to such a DBMS, i~ 
must have the  capabi l i ty to generate 
query programs without any access to the 
database for parsing or for processing 
the returned answer. 
The query language should support 
operations equivalent to the relational 
operations of select, project, and join. 
Also, the query language should support 
some arithmetic capabil ity. Most have 
aggregate functions such as SUM and 
COUNT. WWDMS does not have an easy-to- 
use average operation, but it does have a 
procedural language with arithmetic 
operators so that EUFID can produce a 
"query" that procedural ly calculates an 
average. 
Basic calculat ions should be sup- 
ported such as "age=today-birthdate".  It 
is also desirable to be able to call spe- 
cial functions to do complex calculat ions 
such as nav igat iona l  ca lcu la t ions  
requ i red  in  a nava l  database .  
4. Support for Metadata 
Metadata is data about the data in 
the database. It would be able to tell 
the user of the METRO application, for 
example, the k ind  of information the 
database has for warehouses and other 
entit ies in the application. Such meta- 
data might be extensions of active 
integrated data dictionaries now avail- 
able in  some DBMSs. 
In an app l i ca t ion - leve l  system the  
user  shou ld  be ab le  to  query  the  metadata  
to  learn  about  the  s t ruc ture  o f  the  data -  
base. A different mode, such as the 
menus used by the EUFID help system, 
could be used to access metadata, or 
English language questions to both meta 
information and the database could be 
supported. 
5. Updates  
Some potential users would like a 
natural- language interface to include the 
capabil i ty to update the database. 
Currently, updating through any high 
level view of the database should be 
avoided, especial ly when the view con- 
tains joins or derlve4 data, because of 
the  risk of inadvertently entering 
incorrectly- interpreted data. 
V SUMMARY AND CONCLUSIONS 
For many years, researchers have 
been attempting to build robust systems 
for natural- language access to databases. 
It is not clear that such a system exists 
for general use \[0SI79\]. There are prob- 
lems that need to be solved on both the 
front end, the parsing of the English 
question, and the back end, the transla- 
tion of the question into a data manage- 
ment system query. It is important to 
understand the types of requests, types 
of functions, and types of databases that 
can be supported by a specific NLI. 
Some general guidelines that can be 
applied to the selection of applications 
for current NLI front ends are suggested 
below: 
lo 
2. 
the underlying DBMS should have an 
interactive query language, 
the DMS view should be relational or 
at least support multiple access 
paths, 
3. the database should not contain 
arrays either of values or of struc- 
tures, 
4. the input must be control led to 
standardize values, 
5. there should be few fields than have 
values that change rapidly, cannot 
be recognized by a pattern, and that 
must be used in qualif ication, 
6. the users of the NLI should have a 
common use for the data and a common 
vlew of the data, and 
7. there must be some user who under- 
stands the questions that will be 
asked and is avai lable to work with 
the developers of the NLI. 
We believe that current system 
development is l imited by the need for 
good semantic modell ing techniques and 
the length of time needed to build the 
knowledge base required to interface with 
a new application. When the knowledge 
base for the NLI is developed, the data- 
base as well as sample input must be con- 
sidered in the design. Parsing of ques- 
tions to a database cannot be divorced 
from the database contents since semantic 
interpretation can only be determined in 
the context of that database. On the 
other hand, a robust system cannot be 
developed by considering only database 
structure and content, because the range 
of the questions allowed would not accu- 
rately reflect the user view of the 
appl ication and also would not account 
for all the information that is inferred 
at some level. 
ACKNOWLEDGEMENTS 
We would like to acknowledge the 
many people who have contributed to EUFID 
development: David Brill, Marilyn Cril- 
ley, Dolores Dawson, LeRoy Gates, Iris 
Kameny, Philip Klahr, Antonio Leal, Char- 
lotte Linde, Eric Lund, Fillp Machi, Ken- 
neth Miller, Eileen Lepoff, Beatrice 
Oshika, Roberta Peeler, Douglas Pintar, 
Arie Shoshani, Martin Vago, and Jim 
Weiner. 
\[5 
REFERENCES 
\[AHO72\] Aho, A. V. and J. D. Ullman, "The 
Theory of Parsing, Translation, and 
Compiling", Vol. I: Parsing, 
Prentice-Hall, 1972, pp. 314-23Z. 
\[BURGBff\] Burger, J. F., "Semantic Data- 
base Mapping in EUFID", Proceedings 
of the 198Z ACM/SIGMOD Conference,  
~3"n~-a ' -o~caY- ' -Ca~. ,  May 14-16, 
198ff. 
\[BURG82\] Burger ,  J .  F. and Mar jo r ie  Tem- 
pleton, "Recommendations for an 
Internal Input Language Eor the 
Knowledge-Based System', System 
Development Corporation internal 
paper N-(L)-24890/021/00, January 5, 
1982. 
\[CODD74\] Codd, E. F., "Seven Steps to 
Rendezvous with the Casual User', 
Proc. IFIP TC-2 Working Conference 
on Data-'5"~e'-~a~a~emen~ ~ystems, Car ~ 
gese, Corsica, April 1-5, 1974, in 
J. W. Kimbie and K. I. Koffeman 
(Eds.), "Data Base Management"  
North-Holland, 1974. 
\[CULL80\] Cullinane Corporation, "IQS Sum- 
mary Description", May 1980. 
\[DATE77\] Date, C. J., "An Introduction to 
Database Systems', second edition, 
Addison-Wesley Publishing, Menlo 
Park, CA, 1977. 
\[EDP82\] "Query Systems for End Users", 
EDP Analyzer, Vol. 20, No. 9, Sep- 
tember, 1982. 
\[HARR78\] Harris, L. R., "The ROBOT Sys- 
tem: Natural Language Processing 
Applied to Data Base Query', 
Proceedings ACM 78 Annual Confer- 
ence, 1978. 
\[HEND77\] Hendrix, G. G., E. D. Sacerdoti, 
D. Sagalowicz, and J. Slocum, 
"Developing a Natural Language 
Interface to Complex Data" SRI 
Report 78-305, August 1977. 
rHONE76\] Honeywell, WWMCCS: World Wide 
Data Management System User's Guide, 
Honeywell DE97 Ray.3, April 1976. 
\[KELL71\] Kellogg, C. H., J. F. Burger, T. 
billet, and K. Fogt, "The CONVERSE 
Natural Language Data management 
System: Current Status and Plans", 
Proceedings of the ACM SZmposium on 
:ntormation ~ ~ a n d  ~etrleval-~, 
University o? Maryland, College 
Park, MD, 1971, pp. 33-46. 
\[MYLO76\] Mylopoulos, J., A. 8org ida ,  P. 
Cohen, N. Roussopoulos, J. Tsotsos, 
and H. Wong, "TORUS: A Step Towards 
Bridging the Gap between Data Bases 
and the Casual User", in Information 
Volume 2 1976, Pergamon 
Press, pp 49-64. 
\[OLNE78\] Olney, John, "Enabling EUFID to 
Handle Negative Expressions", SDC 
SP-3996, August 1978. 
\[OS179\] Operating Systems, Inc., "An 
Assessment of Natural Language 
Interfaces for Command and Control 
Database Query", Logicon/OSI Divi- 
sion report for WWMCCS System 
16 
Engineering, OSI Report R79-026, 29 
June 1979. 
\[SCHA77\] Scha, R. J. H., "Phillips 
Question-Answering System PHLIQAI", 
in SIGART Newsletter Number 61, 
February 1977, Association for Com- 
puting machinery, New York. 
\[SIMM65\] Simmons, R. F., "Answering 
English Questions by Computer -- a 
Survey', Comm. ACM 8,1, January 
1965, 53-70. 
\[STON76\] Stonebraker, M., et. al., "The 
Design and Implementation of 
INGRES', Electronics Research 
Laboratory, College of Engineering, 
University of California at Berke- 
ley, Memorandum No. ERL-M577, 27 
January 1976. 
\[TEMP79\] Templeton, M. P., "EUFID: A 
Friendly and Flexible Frontend for 
Data Management Systems", Proceed- 
o~_~hOf the 1979 National Conference 
e--As--~cl'~on tot Computational 
L'rn~-~stics, August, 1979. 
\[TEMP80\] Templeton, M. P., "A Natural 
Language User Interface", Proceed- 
ings of "Pathwazs ~o System 
rn~r i%7" ,  washington DYC. C ah~ 
o? ACM, 1980. 
\[THOM69\], Thompson, F. B., P. C. Lock- 
emann, B. H. Dostert, and R. 
Deverill, "REL: A Rapidly Extensible 
Language System", in Proceedings of 
the 24th ACM National Conference, 
s~ociation--"~or Computing machinery, 
New York, 1969, pp 399-417. 
\[WALT77\] Waltz, D. L., "Natura l  Language 
Interfaces", in SIGART Newsletter 
Number 61, February - '~7,  Associa- 
tion for Computing machinery, New 
York. 
\[WALT78\] Waltz, D. L., "An English 
language Question Answering System 
for a Large Relational Database", 
Communications of the ACM 21, 7(July 
1978), pp 526-539. 
\[WOOD72\] Woods, W. A., R. M. Kaplan, B. 
Nash-Webber, The Lunar Sciences 
Natura l  Lan@ua~e-"rnformation ' System 
~'~Repor t ,  Report number~,  
Bolt, Beranek, and Newman, Inc., 
Cambridge, MA, 15 June 1972. 

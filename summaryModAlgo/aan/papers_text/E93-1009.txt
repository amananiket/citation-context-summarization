A Strategy for Dynamic Interpretation: a Fragment and an 
Implementat ion 
Ol iv ie r  Bouchez  1,2, Jan  van  E i j ck  2,3 and  O l iv ie r  I s tace  1,2 
EMAIL: obo@info.fundp.ac.be, jve@cwi.nl, ois@info.fundp.ac.be 
lInstitut d' Informatique, FUNDP, 61 Rue de Bruxelles, 5000 Narnur, Belgium, 
2CWI, P.O. Box 4079, 1009 AB Amsterdam, The Netherlands 
3OTS, Trans 10, 3512 JK Utrecht, The Netherlands 
Abst rac t  
The strategy for natural language interpre- 
tation presented in this paper implements 
the dynamics of context change by translat- 
ing natural anguage texts into a meaning 
representation language consisting of (de- 
scriptions of) programs, in the spirit of dy- 
namic predicate logic (DPL) \[5\]. The dif- 
ference with DPL is that the usual DPL 
semantics i replaced by an error state se- 
mantics \[2\]. This allows for the treatment 
of unbound anaphors, as in DPL, but also 
of presuppositions and presupposition pro- 
jection. 
The use of this dynamic interpretation 
strategy is demonstrated in an implemen- 
tation of a small fragment of natural an- 
guage which handles unbound pronoun an- 
tecedent links, where it is assumed that the 
intended links are indicated in the input 
string, and uniqueness presuppositions of
definite descriptions. The implementation 
consists of a syntax module which outputs 
parse trees, a semantic module mapping 
parse trees to DPL representations, a repre- 
sentation processor which determines truth 
conditions, falsity conditions and presuppo- 
sition failure conditions, and an evaluator of 
these conditions in a database model. 
The implementation uses the logic pro- 
gramming language GSdel \[6\], an exper- 
imental successor of Prolog, with similar 
functionality and expressiveness, but with 
an improved eclarative semantics. 
1 The  Idea  o f  Dynamic  
In terpreta t ion  
Recent developments in Natural Language semantics 
have witnessed a shift away from static represen- 
tation languages towards representation languages 
with a dynamic flavour. Such representation lan- 
guages can be viewed as definitions of very simple 
imperative programming languages. 
To see how the imperative style comes in, consider 
the treatment of indefinite descriptions (or: existen- 
tial phrases). Existential quantifiers are viewed dy- 
namically as random assignment s atements followed 
by tests. The translation of the natural anguage 
phrase 'a man' becomes omething like: 
x := ?; man(x)  
The first part of this statement can be viewed as a 
random assignment toregister x, the second part as a 
test on the value ofx. This sequence of instructions i  
performed against the background ofa database, i.e., 
a model of first order logic. The sequence succeeds if
the database contains (representations of) men, and 
it can succeed in as many ways as there are men 
available in the database. 
The motivating examples for the shift from static 
to dynamic representation have to do with pronoun 
binding. The translation of phrases like 'a man' in 
terms of assignments of values to registers makes 
it possible to treat binding of pronouns across sen- 
tence boundaries (the next sentence can start with 
'He' to pick up the reference to 'a man'). The nice 
thing about the treatment in terms of assignment is 
that the scope of the existential quantification is not 
closed off at the end of a sentence, as used to be the 
case for NL systems that employ static representa- 
tion (in terms of the existential quantifiers of predi- 
cate logic, with their irritating closing brackets). 
61 
Recently, it has become clear that dynamic repre- 
sentation has some other interesting features: 
? It becomes possible to give an account of pre- 
supposition failure phenomena in terms of the 
definition of an error state semantics for the dy- 
namic representation language \[3; 2\]. Presuppo- 
sition failure occurs for example if one tries to 
interpret "John's wife is unhappy" in a situation 
where John is not married. 
? A more natural treatment of tense becomes pos- 
sible. A sequence of sentences in the past tense 
like "A man walked in. He sat down. He or- 
dered a drink" etc, is represented using subse- 
quent assignments of values (time intervals) to 
a dedicated time register t \[10\]. 
The dynamic representation language can be anal- 
ysed with tools that were originally designed 
for analysing imperative programming languages, 
namely the tools for precondition reasoning from 
Itoare logic or dynamic logic \[11\]. Precondition rea- 
soning for dynamic predicate logic with standard se- 
mantics was introduced in \[4\]. Precondition reason- 
ing gives the truth conditions of DPL representations 
in the form of formulas of first order logic (FOL). 
When applied to the error state semantics of DPL, 
precondition reasoning can also be used to find the 
presupposition failure conditions of DPL representa- 
tions as FOL formulas. 
We provide an integrated treatment of syntax and 
semantics of a small fragment of natural language 
and test this by implementing it. The syntax of our 
toy grammar is a version of categorial grammar with 
feature unification. The semantics uses DPL rep- 
resentations, with an error state semantics which is 
reflected in the rules for precondition reasoning im- 
plemented in the precondition module. This module 
generates predicate logical formulas expressing the 
weakest preconditions of success, failure or error of 
the DPL representations. 
In detail, our interpretation strategy consists of 
the following steps: 
1. Parsing a sentence or text and building a repre- 
sentation tree of its structure. 
2. Translating the parse tree into a DPL program. 
3. Using precondition reasoning to compute pre- 
conditions as formulas of FOL. 
4. Simplifying the preconditions using a simplifier 
for FOL formulas. 
5. Evaluating the resulting formulas in a database 
model. 
The current implementation produces for an input 
text within the grammar fragment: a LaTeX form re- 
port containing the sentence, the parse tree, the DPL 
translation, the precondition of success, the precon- 
dition of failure and the precondition of error, all in 
simplified form, and the result of evaluation in the 
database. 
2 Dynamic  P red icate  Log ic  
2.1 In fo rmal  discussion 
DPL meaning representations for natural language 
sentences can be viewed as procedures or programs 
with a relational semantics. The programs that rep- 
resent the meanings are interpreted as relations be- 
tween input states and output states. A state is a 
mapping from variables to values in a model (in our 
simple set-up all variables are of the same type). The 
representation for an example sentence such as "John 
saw a man" is a program which associates John with 
a variable z, a man with a variable y, and first checks 
whether the value of x equals John, next puts a value 
in y which satisfies the predicate of being a man, and 
finally checks whether the values of z and y are such 
that the first saw the second. 
Thus, the representation of "John saw a man" 
is a program which relates input states where z is 
mapped to John to output states where z is mapped 
to John and y is mapped to some man seen by John. 
If the evaluation takes place in a model where John 
saw several men, then there are several possible out- 
put states. If the evaluation takes place in a model 
where John saw no men at all, then there is no out- 
put. A program that yields no output for a given in- 
put fails for that input. A program yielding at least 
one output for a given input succeeds for that input. 
A program which yields at most one output for a 
given input is deterministic for that input. A pro- 
gram which yields more than one output for a given 
input is indeterministic for that input. The example 
"John saw a man" shows that indefinite descriptions 
may give rise to indeterministic programs. Deter- 
ministic programs that do not change their input are 
called test programs. If a test program succeeds, its 
output equals its input. The sentence "John saw 
him" would give rise to a test program. Assuming 
that the variable z, y are used for the subject and 
object of the sentence, respectively, the program will 
succeed for any input with x mapped to John and ~/ 
mapped to some male individual seen by John. In 
this case success means that the output state equals 
the input state. The program will fail for any other 
input. 
All basic programs of DPL are tests; they do not 
change their input, and they succeed if the values of 
terms are in a specified relation and fail otherwise. 
Indeterminism in DPL arises from assignment pro- 
grams. The assignment program for an indefinite de- 
scription a man will assign a new value to a variable 
x and succeed for any value of z which is a man. 
This is called indefinite assignment. The assignment 
program for a definite description ~he manager gives 
a value to a variable if and only if there is only one 
possible value in the model under consideration. 
Complex programs can be formed by means of 
negation, implication and sequential composition. 
Negation and implication always form tests, but se- 
62 
quential composition does not. Sequential composi- 
tions are tests if and only if the component programs 
are tests. 
2.2 Syntax  
For ease of exposition we will assume there are no 
function symbols in the DPL representation lan- 
guage, so the terms of DPL are either constants or 
variables. Let C be the set of constants, V the set of 
variables, and assume c E C, v E V. 
DPL  te rms t ::= c I v. 
Assume a set of relation symbols R with arities. 
Then the programs of DPL are given by the following 
BNF definition. 
DPL  programs ~r ::= t = t I Rt . . . t  \[ Qr;r) \ [ ( r  ::~ 
I I v: I,v : 
We will use man, see as the relation symbols that 
translate "man", "see", and so on. Thus, (1) is a 
DPL program. 
(1) (T/v2 : man(v2); see(v2, v4)). 
We will omit outermost brackets and brackets in 
sequential compositions like ((71"1;7i'2);r3). This is 
harmless, for sequential composition is associative. 
Also, we will abbreviate r\]v : v = t as v := t. This 
abbreviation is natural, as the sequential composi- 
tion of random assignment to v and test for equality 
with t boils down to assigning the value of t to v. 
2.3 Ind ices  for  Antecedents  and  Anaphors  
In the natural language fragment we treat, we use 
co-indexing to indicate intended anaphoric links. 
We follow Barwise \[1\] in using superscripts for an- 
tecedents and subscripts for anaphors. 
(2) A man walked in. He smiled. 
If we intend the pronoun in (2) to refer to the subject 
of the first sentence, we indicate this intention as 
follows. 
(3) A man 1 walked in. He1 smiled. 
The superscript on the indefinite noun phrase indi- 
cates that this NP acts as an antecedent for NPs 
with the same index as a subscript. The subscript 
on the pronoun indicates the antecedent towhich the 
pronoun is linked. 
The use of subscripts and superscripts i necessary 
because noun phrases can act as anaphors and an- 
tecedents at the same time. 
(4) A man I walked in. 
Another man~ walked ont. 
Hez was angry. 
In example (4) the noun phrase another man is 
anaphorically constrained by an antecedent noun 
phrase a man (it must have a different referent), and 
at the same time acts as antecedent for the second 
occurrence of a man. 
The superscripts and subscripts refer to the vari- 
ables we employ in the translation of the noun 
phrases. Superscripts correspond to variables that 
get assigned a value in the translation, subscripts to 
variables that are simply used. Sentence (5) will get 
translated as (6) (tense is ignored, here and hereafter, 
for ease of exposition). 
(5) John 1 saw a man 2. 
(6) vl := J; : man( 2); see( l,,2). 
Sentence (7) gets translated as (8). 
(7) Mary 3 ignored himx. 
(8) va := M; ignore(va, vl). 
Sentence (9) gets translated as (10). 
(9) Shea saw another man~. 
(10) ~/v4; v4 ? v2; man(v4); see(va, v4). 
Turning now to definite descriptions, the natural 
translation of example (11) is (12). 
(11) John I saw the man 2. 
(12) vl := J; ~v2 : man(v2); see(vl, v2). 
In the error state semantics for DPL that we have in 
mind for this, (12) gives error in every model where 
there is no unique man. It is clear that in most cases 
this is too strong. Still, we do not think this is a 
serious problem for our general approach. It seems 
to be a linguistic fact that definite descriptions often 
are used in a context-dependent way, to designate 
a unique referent in a very specific context, which 
however is not made fully explicit. 
One context where (11) makes perfect sense is a 
situation where John and some other male individ- 
ual are present, and where it is left implicit that John 
is excluded from the context where the reference is 
unique. In such cases we propose to read the def- 
inite description as uniquely satisfying the descrip- 
tion plus the extra condition of being non-identical 
with some constraining antecedent, in this case the 
subject of the sentence. This strategy boils down to 
reading (11) as (13). 
(13) John 1 saw the other man~. 
Here the determiner the otheri is treated similarly to 
anotheri. This gives translation (14). 
(14) Vl := J; ,v2:(v2 ? vi; man(v2)); 
see(vi, 
cases another mechanism seems to be at In many 
work. 
(15) A man walked in. John saw the man. 
Example (15) has a natural reading where the 
definite description is anaphorically linked to an 
antecedent. We propose to make such implicit 
anaphoric links explicit, as in (16). 
(16) A man a walked in. John 2 saw the man~. 
If we provide the right translation instruction for 
such anaphoric uses of the, we arrive at translation 
63 
(17). 
(17) Ovl : man(vl); walk-in(v1); vg~ := J; 
/,'03 : (133 = 131; man(vs)); see(v2, v3). 
This gives the man~ the meaning: the unique man 
that is equal to vl, with v3 available for later reference 
to this individual. It seems to us that this gives the 
correct result, in the present case and in lots of other 
cases .  
In the case of (18) we still run into trouble, how- 
ever .  
(18) The man with the hat smiled. 
Here, the natural translation is (19). 
(19) +vx : (man(v1); ,vz : hat(v2); is-of(v2, vl); 
smile(v1). 
This translation contains a definite assignment ev2 : 
hat(v2), so it seems to assume that there is a unique 
hat in the domain of discourse, which is perhaps a 
bit too strong. There are at least the following two 
ways out. One is by handwaving. Just remark that 
in descriptions like the man with the golden gun, the 
second definite article is not quite as definite as it 
looks, and the description is in fact idiomatic for the 
more strictly correct he man with a golden gun. The 
other escape is to add an epicycle to the analysis, in 
order to achieve that man 1 with1 the hat 2 translates 
into (20). 
(20)  man(~) l ) ;  t~)2: (hat( I )2)"  ~ i8-0f( I ;2 ,1)1)  ). 
We provisionally opt for the first solution. 
2.4 Semantics 
The standard DPL semantics maps input states to 
sets of possible output states. Let a model .A4 = 
(M, II, where M is the domain and I the interpre- 
tation function for a set of constants and relation 
symbols be Kiven. Then the set of states is the set of 
functions M v , and the standard semantics for DPL 
is given by a function \ [ . \ ]~ : M V --+ ~p(MV). 
In order to capture the uniqueness presuppositions 
of definite descriptions, we replace the standard se- 
mantics by an error state semantics. In a Russellian 
account of definite descriptions, "The king of France 
is bald" when evaluated with respect o the state of 
affairs in 1905 or 1993 is false, for there is no unique 
referent for the description. But it is much more nat- 
ural to follow Frege, Strawson and the majority of the 
linguistic ommunity in assuming that statements in- 
volving "the king of France", when interpreted with 
respect o a state of affairs where there is no unique 
king of France, may be neither true nor false, because 
they suffer from presupposition failure. 
We propose to use an error state semantics to take 
in account he failure of uniqueness presuppositions 
of t assignments. The error state semantics of DPL 
if given by a function 
\[.\].~ : (M e t.J <r) -+- :P(M V 12 e). 
In the definition of this function, which follows, e 
refers to a special error state, A ranges over proper 
states, B ranges over states in general (including the 
error state), and A\[x := d\] is used for the proper 
state which is like A, except for the fact that z is 
mapped to d. 
1. \[xl.~l(e) = {c} 
2. \ [Rta. . . tn\] .~(A)= 
{A} if (V~,a(tl), . . . .  V.~,a(tn)) E I(R) 
0 otherwise. 
3. \[t~ = t2\].~(A) =
{A} if Vdbl,A('l) ~- V.I~,A('2) 
0 otherwise. 
4. \[(~1; ~2) \ ]~(a)  = 
s. \ [ (~,  ~ ~) |~(a)  = 
/ {~} if there is a state B E \[a'l\]~(A) 
with\[lr2\]~(B) = {c} 
{A} if for all B e \[~II~(A) 
it holds that\[a'2\]~(B)  {e) 
otherwise. 
6. \[('~x\]~a(A) = 
{e} if \[a'\]~(A) = {e} 
{A} if \[Tr\],~(A) = $ 
O otherwise. 
7. \ [ , lx :  ,~ \ ]~(A)  = 
U{\[-\]~(A\[z := d\])ld e A4}. 
s. \ [ , , x : . l~CA)  = 
{ \[x\]~(A\[z := d\]) for the unique d with 
\[x\]~(A\[z := d\]) g {e} 
if d exists 
{e} otherwise. 
More information on this definition can be found in 
\[2\]. For present purposes it is sufficient o note that 
a DPL program can execute in three different ways, 
when acting on a given input state: 
1. The program reports success by producing at 
least one proper output state. For example, the 
program man(vx) when acting on an input state 
where Vl refers to John will succeed and return 
the input state as its only output state. 
2. The program reports failure by not producing 
any output at all. For example, the program 
rlvl : woman(v1) will fail for any input state 
(except e) if there are no women in the model 
under consideration (its output state set will be 
empty). 
3. The program reports error by producing eas its 
only output. For example, the program ,.vl : 
manager(v1) will produce e for any input state 
if the model under consideration does not have 
a unique manager. 
64 
3 Precond i t ions  of DPL  programs 
Above, we have referred to DPL formulas as pro- 
grams. We are now going to use tools for program- 
ming language analysis on DPL. We will use quan- 
tified dynamic logic over DPL to describe the pre- 
conditions for success, failure and error of DPL pro- 
grams. 
QDL terms t ::= c I v, 
qDLprograms lr ::= t = t \] R t . . . t  I Or; It) \] 
QDLformulas  ~: :=t - - t IR t . . - t l (~A~) l - -~ l  
Note that the QDL programs are precisely the DPL 
programs. An atomic relation Rtl, . . . ,  tn can occur 
inside a QDL program or as an atomic QDL formula, 
so we need to distinguish the programs of QDL from 
the static QDL relations. We use boldface for the 
test program Rt~ . . .  tn and italics for the formula 
Rt t . . .t~. 
We omit outermost parentheses as usual, and use 
T for a formula which is always true, I for a formula 
which is always false. 
The semantics of QDL is as for first order logic, 
with the following clauses for the program modalities 
added (assume A ~ e): 
? A4 ~A (~')~ iff there is some B with B E 
\[Tr\]\]~a(A), B ? e and .44 ~B 9. 
? A4 ~A \[lr\]~ iff for all S e I r i s (A)  it holds 
that B # e and .44 ~ 9- 
Note that (~r) and \[~r\] are not duals. (~')T expresses 
the conditions for success of ~r, \[~-\].L the conditions 
for failure of z. It follows that ~(~r)T A --\[~r\].l_ ex- 
presses the conditions for error. 
The following axiom schemata can be used to com- 
pute these conditions as formulas of FOL. 
1. (Rt ,  . . .  t , , )~ ~ (nt t  . . . t ,  A ~). 
2. \[Rt, . . . t , \ ] to  ~ (Rt t . . . tn  -~ 9). 
~. ( t ,  = t , )~,  ~ (t~ = t~ ^  9) .  
4. It, = t~\]~, ~ (t~ = t~ --. 9)-  
6. \[~, ;~:~\]~ ~ \ [~, \ ] \ [~\ ]~.  
7. ( - ,~)~ ~ (~, ^  \ [~\ ]?) .  
8. \[-~-\]~, ~ ( (~) - r  v (~, ^  \[~-\]?)). 
10. \[~r, =~ ~r,\]~ ~ ((\[~',\]((~r,)T V \[~r,\]J_)) A 
(\[~r,\](~,)T --~ 9))- 
11. (n , , :  ,r)~, ~. a~,(,,-)~,. 
12. Nv :  ~r\]~# --Vv\[vr\]~. 
14. \[ , , , :  ~-\]~, ~ (a!v(~-)T ^ V,,((~-)T --+ \[~-\]~)). 
The most interesting item of this list is the univer- 
sal schema for t assignment (item 14). To see what 
it means, note that \[~r\]m expresses that all output 
states of ~r are proper. The schema states that the 
following are equivalent: 
? For proper input state A, the program tv : lr 
does only have proper output states, and all of 
these satisfy ~a. 
? For proper input state A there is precisely one 
d E M for which 7r has a proper output on input 
A\[v : -  d\], and for all d' for which ~r has proper 
outputs on A\[v := d'\], all outputs of lr on A\[v := 
d'\] are proper and satisfy 9. 
It is not very difficult to see that these are indeed 
equivalent, so the axiom schema is sound, as are the 
other axiom schemata. 
The axiom schemata can be used to calculate the 
truth, falsity and error conditions of DPL programs 
as formulas of FOL. If we represent a first order 
model as a database, then evaluation of DPL in a 
model reduces to evaluation of first order formulas 
in the database. 
An example will make clear how the axioms may 
be used to compute preconditions of DPL programs 
as FOL formulas. Consider example (21) with trans- 
lation (22). 
(21) I f  a woman is married, 
her husband looks after her. 
(22) (qx : Wx; Mx)  =~ (~y: gyx;  Lyx). 
Here is the derivation of the truth conditions. 
((rlz : Wa~; Mz)  =~ ( ty :  Hyz;  Lyx))T 
4-~ \ [~x:  Wx;  Mx\ ] (~y  : t tyx ;  Lyx)T  
~-+ \[r lx: Wx\] \ [Mz \ ] ( *y  : I ' lyz)(Ly~)T 
~-* Vx\[Wx\] \ [Mx\](Ly : Hyx}(Lyx)T  
Vx(Wx ~ (Mx  -~ 
(:JIy(I-Iy~c)-t- A By(I-Iyx)(Lyx)T))) 
,-, Vx(W2: .-* (Mx  
(3 !yH~ ^ 3y(Hy~ ^ Lye)))) .  
To calculate the falsity conditions, we can use 
theorem (23), which is derivable from the axiom 
schemata: 
Applying theorem (23), we get the following falsity 
conditions for (22): 
3x(Wx A Mx A 3!yHyx A Vy(Hyx ~ -~Lyx)). 
Program (22) aborts with error if it doesn't succeed 
and doesn't fail. Modulo some FOL reasoning the 
conditions for this are given by (24): 
(24) 3x(Wx A Mx A - ,d!yYyx). 
This means that in all models where married women 
do have unique husbands, program (22) will never 
abort with error. In other words, the calculus allows 
us to derive that the presupposition of the definite 
description has been cancelled by the implication. 
65 
4 The  Imp lementat ion  
The parser The grammar for our fragment uses 
categorial feature unification, and the parser is based 
on standard techniques for such grammars. The syn- 
tax consists of a lexicon, which associates categories 
with lexical items, a category descriptor which gives 
definitions of complex categories in terms of simpler 
categories and some reduction rules. 
Basic categories are S without features, and E 
with features for number, person, case, uindez for 
up index (= antecedent index) and dindex for down 
index (= anaphor index). Complex categories are 
built with / and \ and the constraints on feature uni- 
fication in the usual way. The index features uindez 
and dindez also occur on noun phrases and determin- 
ers. Here are some examples of complex categories 
(, marks the feature values that do not matter). 
? N(number) = 
S/E(number,*,*,*). 
? NP(number,person,case,uindex,dindex) = 
S/(E(number,person,case,uindex,dindex) kS). 
? VP(number,person,*) = 
E(number,person,Nom,*,*)\S. 
? TV(number,person,tense) = 
VP(*,*,tense)/NP(*,*,Acc,*,*). 
? DET(number,uindex,dindex) = 
NP(number,Third,*,uindex,dindex)/ 
N(number). 
? AUX(number,person) - 
VP(number,person,Tensed)/ 
VP (number ,person ,In f). 
? NEG = 
AUX(number,person)\AUX(number,person). 
Basic categories get assigned in the lexicon. For ex- 
ample: 
word Category 
John ~ NP(Sg,Third,*,i,*) 
hei NP(Sg,Third,Nom,*,i) 
himi NP(Sg,Third,Acc,*,i) 
sees TV(Sg,Third,Tensed) 
a i DET(Sg,i,*) 
the i DET(*,i,*) 
another~ DET(*,i~i) 
h i s}  DET(*,ij) 
man N(Sg) 
with (N(nr)kN(nr))/NP(*,*,*,*,*) 
Some examples of complex category formation: 
? a man;: 
DET(Sg,i,*). N(Sg) = 
NP(Sg,Third,*,i,*)/N(Sg). N(Sg) = 
NP(Sg,Third,*,i,*). 
? sees a man*: 
TV(Sg, Third, Tensed) ? NP(Sg,Whird,*,*,*) 
= (VP(Sg,Third,Tensed)/ 
NP(Sg,Third,Acc,*,*,*)) 
-NP(Sg,Third,*,*,*) 
= VP(Sg,Third,Tensed). 
? John~ sees a mani: 
NP(Sg,Third,*j,*)- VP(Sg,Third,Tensed) - 
(S/(E(Sg,Third,* j,*)kS))- 
(E(Sg,Third,Nom,*,*)\S) 
mS. 
The trans lator  The translator uses A-calculus to 
translate parse trees into DPL programs? We could 
have translated on the fly, building translations while 
parsing, but the present set-up seemed preferable for 
reasons of modularity of design. 
The translation algorithm makes use of a lexical 
function mapping pairs consisting of a lexical item 
with an associated category to A-expressions in the 
lexicon, along the lines of \[9\]. 
Translating a sentence into DPL boils down to 
lambda reduction of the lambda expression which 
results from combining the lambda expressions as- 
sociated with the leaves of the parse tree, according 
to the rules of functional application dictated by the 
categorial structure. 
Here are some examples of lambda expressions as- 
sociated with lexical items with categories. Note that 
we assume the presence of indices in the lexicon, so 
we can handle anaphoric links by co-indexing. 
For a proper understanding of the translation i - 
structions one should bear in mind the distinction 
between DPL variables that are used for DPL assign- 
ment and lambda calculus variables. We use lower 
case for the first and upper case for the latter. 
Translation for man, N(Sg): 
AVl.m..(VI). 
Translation for John i,NP(Sg,Third,*,i,*): 
AVl.vi := J; Vi(v,). 
Translation for sees, TV(Sg,Third,Tensed): 
A VI.( A V2.(Vl A V3.see(V2, V3))). 
Translation for is, TV(Sg,Third,Tensed): 
A VI .( A V2.(Vl A Vs. V2 = v3)). 
Translation for a(n) i, Det(Sg,i,*): 
AV~.(AV2.(,lv, : VlO,,); V2(,,))). 
Translation for the i, Det(*,i,*): 
AVI.(AV~.(~,,,: V,(v,); V~(v,))). 
Translation for the~, Det(*,ij) (the anaphoric use of 
the): 
AVI.(AV2.~v, : (v, = vi; VlV,); v2(,,)). 
Translation for if, (S/S)/S: 
A VI ,( A V2. V, =~ v~ ). 
Translation for does, AUX(Sg,Third): 
AVI.V1. 
66 
Translation for not, NEG: 
~ v~ .( ~ v~ .-, ( v~ v~ )) . 
Translation for another, DET(Sg,i,j): 
~Vl.(~v~.(,~v~ : ,  # v~; v\](~); V~(vd)). 
Translation for the other, DET(*,i~): 
~Vl.(~V~.(~,~ : (.~ # ~; V~(v~)); V~(~d)). 
Translation for he/, NP(Sg,Third,Nom,*,i): 
~v~.v,(~,). 
Translation for hisS, DET(*,ij): 
~v~.(~v~.,v~ : Vl(,d; iso/(,~, ~); V2(vd). 
Translation for with, (N(nr)\N(nr))/NP(*,*,*,*,*): 
~ v~.( ~ v2.( ~ v~.( v~(v~); Vl ( ~ ? ~of ( V~, v3)))). 
All these translations are typed, but we have left 
most of the typing discipline implicit. For example, 
the translations of noun phrases all are of the type 
of (dynamic) generalized quantifiers, which take a 
property to give a DPL program. The translation 
of proper names is a dynamic variation of the Mon- 
tague treatment for proper names \[8\]. In extensional 
Montague grammar, proper names translate into ex- 
pressions denoting the set of properties which are 
true of the named individual. Here, proper names 
translate into expressions that for every property 
give the DPL program which first assigns the name 
of the individual to the index variable of the proper 
name, and then tests for the property. This is like 
in Montague grammar, but with a dynamic touch 
added. Anaphoric links to the name remain possible 
by means of the index variable as long as its value 
remains unchanged. 
Other noun phrases with a dynamic flavour are 
indefinite and definite descriptions. Indefinite de- 
scriptions translate into expressions that for every 
property give the DPL program which does an in- 
definite assignment to an index variable and tests 
for the property. Definite descriptions are handled 
likewise, but with definite assignment instead of in- 
definite assignment. 
(25) John x uses his pc~. 
As an example, we treat the translation of (25), 
which is obtained starting from the following parse 
tree: 
(S ,  
(NP  1, John) , 
(yP,  
(TV, u~e~), 
(NP?, 
(DET~,his), 
(N, pc) 
) 
The translation step by step: 
his pc~ ~ AVI.()W~.tv2 :
y~ (v2); i8-o/(v2, 1); y2(,2))(~v~ .pc(V1)) 
*-.-b 
;w2.,v2 : pc(v2); is-of(v2, v0; v2(~2). 
uses his pc~ 
)~ V~ . ( )W2 . V, ( ), Vs . use ( V2 ,113 ) ) ) 
(~v2.~v2 : pc(v2); i~-of(~2, v0; v2(v2)) 
.--'4" 
~v2.(~v2.(~ : pc(~2); i~-of(v2, ~); V2(v2)) 
(aV3.use(V~, V,)) 
(AV~.tv2 : 
pc(v2); is-of(v~., vl); (AVa.use(V2, Vs))(v2)) 
~v2.,v2 : p~(v2); is-of(,2,,1); use(V2, ~2). 
John 1 uses his pc~ 
(~Vl.v~ := J; (vdvl))  
~V2.,v2 : ~c(v~); i~.of(v~, v~); use(V2, v~) 
, . -+ 
v~ := J; 
(AVz .tv2: pc(v2); is-of(vg., Vl); use(V~, vg.))(vl) 
. . .4  
Vl := J; ~ : ~c(v~); is-of(~, ~1); use(~x, v~). 
In the same way, (26) gets translated into (27). 
(26) John 1 is a man ~. 
(27) vl := J; ~/v2 : man(v2); Vl = v2. 
Note that 'is' is treated as in Montague grammar \[8\]. 
5 Experiences with the GSdel 
Implementat ion Language 
The declarative semantics of GSdel improves on the 
semantics of Prolog: extra-logical Predicates (such as 
vat, nonvar, assert, retract, ! . . . .  ) are avoided and 
sometimes replaced by declarative counterparts. 
Like Lambda Prolog \[7\], GSdel is a typed language: 
it is necessary to declare the type and domain of all 
functions and predicates (polymorphism is allowed, 
however). This convention makes program writing a 
bit more cumbersome, For example, we have to de- 
clare the type Program for representing a DPL pro- 
gram. For each DPL statement, it is necessary to 
define a function to build a Program (example: Pi- 
ota : Variable * Program ~ Program). We also have 
to declare a type Expression for A-expressions. Some 
complications arise from the fact that an expression 
may contain a DPL program and vice versa. On the 
plus side, more errors are detected uring compila- 
tion, the compiler generates more efficient code, and 
the typing discipline makes for more legible, com- 
prehensible programs. Last but not least, the typing 
discipline has obliged us to think a bit more about 
the clauses we were writing than we perhaps would 
have done otherwise. 
67 
GSdel has facilities that permit elegant meta- 
programming. In Prolog the program and the meta- 
program are not independent: the predicates as- 
sert and retract modify the program itself in which 
these predicates occur. In GSdel, program and meta- 
program are completely independent. It is possible 
for a program to load another program, to modify 
this other program by inserting or retracting predi- 
cates, functions or types, and to demonstrate a goal. 
In our implementation we use these facilities to rep- 
resent a model as a logic database and a precondition 
as a complex goal. 
6 The  Program I t se l f  
The main module takes a sentence or text as input 
and produces a report containing the sentence, the 
parse tree, the DPL program it gets translated into, 
and the preconditions. This module uses the follow- 
ing submodules: 
? the parser module which from a sentence, finds 
its category and builds its parse tree, 
? the translation module which from the parse 
tree, computes a representation f a DPL pro- 
gram, 
? the precondition module which from a DPL pro- 
gram, derives the preconditions (this module 
calls another module to simplify the resulting 
FOL formulas), 
? the evaluation module which performs a 
database valuation. 
A lexicon module is called by the first two of these 
modules. It contains the words, with their categories 
and the associated A-expressions. 
6.1 Ma in  modu le  
This module receives a sentence represented by a list 
of words and parses it, translates it, produces a re- 
port, computes preconditions and evaluates these in 
a given model. 
6.2 Output  
This module defines how to output programs, ex- 
pressions, categories, trees, words, . . .  It uses the 
facilities of GSdel for manipulating text files. 
6.3 Lex icon  
The lexicon is defined by a predicate Diet with three 
arguments: the word itself, a category and an appro- 
priate lambda expression. 
6.4 Parser  
The parser employs backtracking and unification in 
the usual way. GSdel (as all logic programming lan- 
guages) has these features built in, which makes it 
very easy to implement a parser for a simple frag- 
ment like ours. The parsing of a sentence consists of 
three steps: 
* generate a list of categories corresponding to the 
sequence of words, 
? reduce the list of categories, 
? test if you have a sentence lse retrace your steps 
and try again. 
We use the type categor to represent categories. It 
is defined by the constant S and the functions 
E(nnmber, person, case, nindex, dindez), 
NP (number, person, case, uindex, dindex), 
N(number), 
and so on. The two infix functions / and \ serve to 
build new and more complex categories. 
Sentences axe parsed by building a binary parse tree 
in bottom-up fashion. The binary parse trees are 
represented by a constant Empty and a function A. 
Empty represents the empty tree and the function 
A gives the information at the current node, the left 
subtree, and the right subtree. The information con- 
tent of the nodes is of two kinds: internal nodes carry 
the result of combining the categories of the subtrees 
and leaf nodes carry a pair consisting of a word and 
its category. 
The parse trees are built during the reduction of the 
list of categories, starting with a list of trees corre- 
sponding to the words of the sentence. When we 
reduce two adjacent categories, we replace the two 
corresponding trees T1, 7"2 by a single tree with T1 
and Tz as immediate subtrees. 
6.5 Trans la tor  
The translator uses two types: Program and Ezpres- 
sion. The first represents a DPL-program, the sec- 
ond a complex A-expression. We have left the rest of 
the typing of the lambda expressions implicit. 
The definition of programs and lambda expressions 
is a bit cumbersome, for a A-expression may contain 
a program and vice versa. This complication is re- 
flected in the rules for substitution and reduction. 
For example, it is necessary to define the substitu- 
tion of an expression for a variable in a program, the 
free occurrence of a variable in a program, etc. The 
rules of reduction are a straightforward endering of 
the rules of ~-reduction and 7-reduction in A calcu- 
lus. We do not handle a reduction, as we see no need 
for variable renaming. 
The translation process employs the following pred- 
icates: 
Trad  This predicate translates a parse tree into a 
reduced A-expression. Depending on the information 
at the current node of the parse tree, a lexical look- 
up of the translation takes place, or the translation is
found by reducing the application of the translations 
of the left and right subtrees. 
T rans  This predicate translates a list of parse trees 
for the sentences of a text into the corresponding 
68 
DPL program. It uses the predicate Trad to trans- 
late each sentence, and then links these translations 
by applications. 
Canted This predicates takes a h-expression and 
reduces it using the declarative functional semantics 
of h-calculus. 
6.6 From DPL  to QDL 
We have seen that DPL programs are represented 
as G6del functions. The reduction of DPL to FOL 
by means of QDL gets implemented by defining re- 
duction predicates corresponding to the QDL axiom 
schemata. These predicates call each other recur- 
sively. 
? Fa(Re i (s ,v ) )  is a relational atomic test. 
(at1...t.) 
? Fequal(t l ,  t2) is an atomic test of equality of 
the terms tl  and t2. (tl = t2) 
? Fand(phi l ,  phi2) is the conjunction of two for- 
mulls. (~1 A ta2) 
? For(phi l ,  phi2) is the disjunction of two for- 
mulls. (~1 V ta2) 
? F impl ie (ph l ,ph i2) is  the implication of two 
formulas. (ill --* ta2) 
? Fall(V(i), phi) is the expression (Vvi~) 
? Fexist(V(i), phi) is the expression (3vita) 
? Fonlyone(V(1), phi) is the expression (q!vi~) 
? Fnot(phi)  is the negation of the formula ta. 
? Fpreeexist(pi,  phi)is the expression ((~r)ta) 
? Fprecuniv(pi ,  phi) is the expression (\[~r\]ia) 
? Fpar(pi,  phi) is the expression (-~(Tr)taA-~\[Tr\]~). 
In the course of applying these predicates, formulas 
may get generated with obvious redundancies. We 
have defined a formula simplifier to remove some of 
these. This improves the readability of the output 
(the formulas are output in LaTeX format) and the 
performance of the database lookup on the basis of 
the conditions. 
There is the list of simplifications handled by the 
module Simple. 
? ~# A T +-~ ~# 
? ~# A .L  +-+ J- 
? ~ V T ~ T  
? ~ V-L  ~-~ ~ 
? ( ~ T ) ~ T  
? (T* -  
? (_I_ *- ~) ~-~ T 
? -~T ~ _L 
? (3!v~ A =Ivy,) ~ :l!v~. 
6.7 Evaluation 
The intermediate language QDL allows us to trans- 
late DPL programs into formulas of FOL. These are 
then evaluated in a database model, i.e., a first order 
model which is implemented as a G6del database (a 
G6del program). There we have a so-cMled meta- 
module Evaluation and an object program Logic 
Database, and the meta-program anipulates the 
object program. We translate first order conditions 
into G6del goals, and then apply the goal to the ob- 
ject G6del program, using the possibilities of meta- 
programming offered by G6del. In ordinary Prolog, 
these things could also be done, but they would look 
much less elegant. 
Here is an example of a Gfdel model (the lines pre- 
ceded by % are comment lines): 
MODULE Model1. 
IMPORT Strings, Sets. 
BASE Symbol. 
% We use this base for every kind of term. 
CONSTANT 
John, Bill, Freddy, Borsalino, Myclone: Symbol. 
PROPOSITION Top. 
PREDICATE 
Admire, Cheer, Isof, See, Use : Symbol * Symbol; 
tilt, Man, Adult, King, Pc, Manager : Symbol. 
% The relations defined in the model 
Admire(John,Bill). 
King(Bill). 
Isof(Borsalino,Bill). 
ttat(Borsalino). 
See(John,Bill). 
See(Bill,John). 
Manager(Bill). 
Man(John). 
Man(Bill). 
Man(Freddy). 
Adult(John). 
Adult(Bill). 
Pc(Myelone). 
Use(John,Myclone). 
Top. 
% Top must be defined in every model. 
69 
7 Conc lus ion  
The QDL translation discussed above only handles 
uniqueness presuppositions of definite descriptions. 
The method employed is general enough, however, 
to handle lots of other kinds of presupposition. Lex- 
teal presuppositions, for example, are handled in the 
error state semantics by a slight revision of the se- 
mantic clause for atomic tests. Being a bachelor pre- 
supposes being male and adult, so the test for bach- 
elorhood should give error if it is performed on an 
entity that does not satisfy the test for being a male 
adult. 
Formally, the revision boils down to this. Let At be 
the set of atomic formulae of DPL. Assume a lexi- 
cat presupposition function lp : At ~ DPL mapping 
each atomic test predicate of the representation lan- 
guage to its associated lexical presupposition, con- 
ceived as a program of the representation language. 
For example, here are the lexical presuppositions for 
bachelorhood. 
lp(bachelor x) = (male x; adult x). 
The semantic clause for atomic relations is mod- 
ified to take the function lp into account: 
2'. \ [R ( tx . - .~ . ) \ ]~(A)  = 
{A} if ~lp(Rtl...t,)\]~(A) q~{e} 
and A4 ~A Rta ...tn, 
0 if \[lp(Rtl-.. t,)\]~(A) 9~ {'} 
and .~4 ~A Rta ...t,~, 
{,} if ~lp(Rtl-..t,)\]~(A) C_ {,}. 
This modified definition gives the success and failure 
of the relational test modulo the fact that the lexi- 
cal presupposition of the relational test holds; if the 
presupposition does not hold then the test results in 
error. 
There is no need for any other changes in the rules, 
for the projection of lexical presupposition is taken 
care of by the general principles of error percola- 
tion that are already implicit in the semantic lauses. 
Thus, the DPL error semantics gives us that (28) pre- 
supposes that Jan is male and adult, but that (29) 
only presupposes that Jan is adult. 
(28) Jan is a bachelor. 
(29) If Jan 1 is male, then hel is a bachelor. 
The change in the semantic lause for atomic re- 
lations is reflected in the calculus by replacing the 
schemata for Rtl . . . tn by the following versions: 
1. (Rt l . . . tn)~a ~-+ 
(Rt l . . .  t,, A (p A (lp(Rt~ ? ? ? tn))r) .  
2. \ [R t l . . . tn \ ]~ *-+ 
( R t l  . . . t .  --+ ~)  ^  ( lp (m~ . .  ? tn ) ) r ) .  
In the implementation, lexical presupposition is han- 
dled by a predicate Lp and a modification of the 
reduction predicates for the relational test axiom 
schemata. 
Right now, we are extending the fragment o deal 
with other kinds of presupposition failure, in partic- 
ular failure of presupposition ofaspectual verbs such 
as start and stop. 
References  
\[1\] J. Barwise. Noun phrases, generalized quanti- 
tiers and anaphora. In P. G~rdenfors, editor, 
Generalized Quantifiers: linguistic and logical 
approaches, pages 1-30. D. Reidel Publishing 
Company, Dordrecht, 1987. 
\[2\] J. van Eijck. The dynamics of description. Jour- 
nal of Semantics, 10, 1993. to appear. 
\[3\] J. van Eijck. Presupposition failure - -  a comedy 
of errors. Manuscript, CWI, Amsterdam, 1993. 
\[4\] J. van Eijck and F.J. de Vries. Dynamic in- 
terpretation and Hoare deduction. Journal of 
Logic, Language, and Information, 1:1-44, 1992. 
\[5\] J. Groenendijk and M. Stokhof. Dynamic pred- 
icate logic. Linguistics and Philosophy, 14:39- 
100, 1991. 
\[6\] P.M. Hill and J.W. Lloyd. The GSdel report. 
Technical report, Department of Computer Sci- 
ence, University of Bristol, Bristol, 1991 (re- 
vised 1992). 
\[7\] D.A. Miller. A logic programming language with 
lambda bstraction, function variables and sim- 
ple unification. In P. Schroeder-Heister, edi- 
tor, Eztensions of Logic Programming. Springer, 
1990. 
\[8\] R. Montague. The proper treatment of quantifi- 
cation in ordinary english. In J. Hintikka e.a., 
editor, Approaches to Natural Language, pages 
221-242. Reidel, 1973. 
\[9\] R. Muskens. Anaphora nd the logic of change. 
In J. van Eijck, editor, Logics in AI  / Eu- 
ropean Workshop JELIA '90 / Amsterdam, 
The Netherlands, September 1990 / Proceed- 
ings, Lecture Notes in Artificial Intelligence 478, 
pages 412-427. Springer Verlag, 1991. 
\[10\] R. Muskens. Tense and the logic of change. 
Manuscript, University of Tilburg, 1992. 
\[11\] V. Pratt. Semantical considerations on Floyd- 
Honre logic. Proceedings 17th IEEE Symposium 
on Foundations of Computer Science, pages 
109-121, 1976. 
70 

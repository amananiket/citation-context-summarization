American Journal of Computational Linguistics 
COMPUTER UNDERSTAND I NG OF 
P H Y S I C S  P R O B L E M S  
STATED IN I~ATURAL LANGUAGE 
Computer Science Department 
University of Texas 
Austin 78712 
Microfiche 5 3 
C o p y r i g h t  @ 1976' 
Associa t ion for C o m p u t a t i o n a l  L i n g u i s t i c s  
This  palltar dcsrril)es n conrpu t or program, r i ~  lled ISAA(:. \\*hi~-h ($;In rc!:~(i, 
underst and ,  so lw,  nnt l  draw pic~.t-iil.cs 01' pl~ysicss p s ~ h l c n ~ s  stnt ocl i t a  1S1lglish. l 'he 
program has solsrd t ~vi'nty problems. most of tvhic.11 wcrll' t alicb11 unedit rtl fsonl high 
school and collihge physics t tlxts. Those prohlc~ns  i~lvol\.e taigicl hod icis in st at ic. 
equilibrium, and  i n c l ~ i d t ~  411cbh objec'ts .as Icv~1,s. pivots, ivrights, ~*ol,cs, anti s1)rings in 
various configurations. An exanlpltl of the r.l;tss of' p1.c)t)lems sol\?ecl is the follo\ving 
(from Scilcru nl ',s Out l i r~  of C O I I C ~ C J  /,'/l?si~*s ): 
The foot of n ladtlcr rrsts i t  n vcrtic*nl i and o n  :I t ~ o ~ , i x o ~ ~ t a t  
floor. Thc top of' the l;\clcltlr is s t l p p t n . ~ ~ d  f'ronl tl l t l  \vall t)y n hot%izotlt;\l 
rope 3 0  ft long. l'hc 1;idtlcl is 50 St 10111, \veighs 100 11) \ ( i t \ )  its c,entriS of 
gravity 20 ft fl*om thv foot. ancl a 150 111 marl is 10 1'1 fro111 the to\). 
Deternlinu the tension in the i s o l ~ t ~ .  
In order. to understancl allti sol\.t. such a pi.oblu~n, it is necessar_v to build a n  i t l t rrnal  
model of the problelli ill ivtlic11 the various objt'cts and the11 i~lter~*elationsllips are 
adequately represented. Milny of the ~ . t s l i l  t ionships ;I nd  feat ulwrs o f  the ohjerts a re  not  
specified explicitly in the problein st ; l tc~nrnt hut must  be infe~*re(l by usi~lg conlnloll 
serlse kno\vlccige of what is usual. I n  the al)o\v esamplc, we ;*sume that .the m a r  is 
standing or1 tlie ladtlcr, i~lth(,ugh this is not esl)licitly stittetl. Tt lus ,  the untle~*st;ln(ling of 
a physics psobletn is a n  acti\tPpl-ocess in \Chic11 the Cet~tences of' the prol~lenl statement 
a re  used to guide the construction of a model which roprt.sants the relationships ant! 
features of objects with ~ n u c h  , greater . detail a n d  spcciticity t'halt they a re  specif'iec! in t l ~ c  
original probletn sta t e m e ~ t .  
I n  this l)npf?)., ive in\.estigate ways in which tllr m e a n i t ~ g ~  of pl1rasc.s anti 
sentences may be unclerst~oorl and  related to  a developing n1otle.l of the problem. usltlg 
common sense knowledge (represet~tod 1,. com!rutes progrilrns) t o  aid the un~lel-stand in^ 
process. \Va_vs of representing ot~jects and  rileir relationships tire developecl. These 
representations, which a r e  originally sreated in rehponse to the sentences in the problem 
statement,  a re  further elal)ol*atcd by proc:esses which c0nstruct.n ~eonletricl 11lc,dei ot' the 
problem, associate ca~lonicnl  objerts (such a5.a point mass) 1~ir11 physical objects r s ~ l c . ! ~  
a s  a person), ~vr i t e  aild solve equations which tiescribe the inte1.actio11s of the objects 
and  construct a diagram of the problenl, 
This paper is a slightly etlitcd vel-sio1l i,f tlie ar1tllnr.s Ph.'I). disse!.t a1 ion. I 
a r -  grateful to  11iy co~nmi t t e t  !~~ernt)el s, Prof'6ssors John I,othlin, \\2oodro\v Hler!..;oe, 
and  Nornian Martin, a n d  esl>t'ci:~l\y t o  my super~i.;in;; ~)l.ofus:~oi., Hnbevt F. Simmoils. 
TABLE OF CON'I'ENrl'S 
Page 
LIST OF FIGURES 
1. INTROI)T_JCTION AND O V E I i V I E W  
1.1 Introduction 
1.2 Ovcr\?iew of the Program 
2. REVIEW OF PREVIOUS WORK 
2.1 Natural Language Problem Solvers 
2.1.1 Bobrow's STUDENT 
2.1.2 Chart~iak 's  CARPS 
2.1.3 Gelb's HAPPINESS 
2.1.4 Heidorn's Sirnulation Programmi tlg System 
2.2 Natural Language Processing 
2.2.1 Woods' Augmented Transition Networks 
2.2.2 Winograd's SHRDLU 
2.2.3 Wilks' Prefere~ltial Semantics 
2.2,4 Simmons' Senlantic Networks 
2.2.5 Schank's Conceptual Dependmcy 
2.3 Minsky's Fratlle System Theory 
3. PARSING 
3.1 Introduction 
3.2 Control Structure of *he Parser 
3.3 Data Structures Produced During Parsing 
3.4 Noun Phrase Parsing 
3.4.1 Basic Noun Phrase 
3.4.2 Noun Phrase Co~npou%ds and Modifiers 
3.4.3 Noun Phrase Variants 
3.5 Verb Phrase Parsing 
3.5.1 Basic Verb Group 
3.5.2 Verb Phrase 
3.6 Prepositional Plwase Parsing 
3.7 Clause Parsing 
3.8 Cor~clusion 
4. SEMANTICS 
4.1 Introduction 
4.2 Preliminary Modifier Procwssing 
4.3 Preposition Semantics 
4.3:l Semantic's of the Preposition "OF" 
4.3.2 Semantics of Other I'reposi tio~us 
4 . 3 . 3  Ilefinition and Translatiotl of Pr~posit ions 
4.4 Referent Identification 
4.4.1 Identifying 13hysic;~l Entity Referents 
4.4.2 Identifying Location Ii~furtlnts 
4.4.3 Attachnuent Identification 
4.5 Modifier Senla t ~ t  ics
4.6 Verb Semantics 
4.6.1 Semantics o f  the Verb "BE" 
4.6.2 Selnantics of the Verb "SUPPORT" 
4.6.3 Semantics of 0 t l ~ e r  Verbs 
4.7 Question Semantics 
5. CONSTRUCTION OF OBJECT FRAkIES AXI> THE GEOMETRIC MODEI, 
5 .?1 Introductioh 56 
5.3 Making Canonical Object Frames 57 
5.3 Geometric hlodel Co~lstruction 59 
5.4 Frame Completion (3 2 
5.5 Conclusioi~ 6 3 
6. PROBLEM SOLVING 
6.1 Generation of Equations 
6.2 Equation Solviilg 
6.3 Answer Generation 
7. PICTURE CONSTRUCTION 
7.1 Constructing the PiEture PvIodel 
7.2 Drawing the Diagram 
8. CONCLUSION 
8.1 Methodology 
8.2 Directions for Future Research 

1. Introduct,iol~ i~ i ld  Overview 
'1 ,I Introduct ion 
This paper describes a computer pl'ogram, called ISAAC, which is able to 
read and understand physics problems stated in English, write equations for the 
problems and solve them, and draw diagrams showing the objects i r l  the problr~;ls ~ i n d  
their spatial relntiot~ships. The pro~~ilt11 has*solverl twenty problems. \\*hirh wertr taken 
essentially ulledited born physics textbooks: some iample problems are shown, with the 
drawings and answers generated by the program, in Appcntiis A. 
While the diagram and answer to a problem are the most eas~ly  observable 
outputs of the program, another significant output is its robust intel-11al inodel of the 
objects in the problem and their relationships. It is this model which makes possible the 
generation of the diagram and the answer to the problem. The  internal nlodel is robust 
in the sense that  it represents, in a n  explicit and readily accessible form, nos t  of the 
inrorn~ation which a competent hu~niin reader might be expected to derive from the 
English problem statement. I n  addition to the ways in which it is currently used, the 
model could be used for answering questions about the objects and their relationships, 
or. fbr generating a description of the problem in English or in another language. or for 
generating other types of diagrams (such as a force diagram). Since it makes all of the 
features and relationships of the objects explicit, the internal model is ma 11y t inles 
larger than the original problem statement. which specifies only the major features and 
leaves many details to be filled in by the' reader. 
1.2 Overview of the Program 
The overall organization of the progratn and Its data elements is shown in 
Figure 1.1; programs are represented by boxes with double lines, and data structures by 
plain boxes. In this section, we present an  overview of the functions performed by each 
group of programs and a n  overview of the types of information represented in the data 
structures. 
The process of unders ta~~ding  and solving a physics problem occurs in 
several distinct steps. First, the problem statement is translated fro111 E tlglish into a 
structured par3ing of the sentences, which is iilterpretetl semantically to construct an 
initial intel.1131 model. This nlodel is interpreted to form a model in terms of cclnonif:al 
physical obje :ts (such as  a point mass). A geometric model which reprr.wnts the spatla1 
position and orientation of each object is corlstructed. Equations which descr~be the 
F i g u r e  1.1:  O v e r a l l  Program O r g a n i z a t i o n  
1 
b 
f 
E n g l i s h  
Problein 
S t a t e m e n t  
A ., 
! 
L .  
- I  
I c A 
4 
L 
F 
. 
r 
Y 
) ' Y -  
Semant ic  
Programs 
P a r s i n g  
Programs 
P a r s e d  
S e n t e n c e s  
> I 
T 
' I n i t J a l  
I n t e r n a l  
Model 
Y - - 
C a n o n i c a l  
O b j e c t  
1 .  
EUCLf D Frame 
- C r e a t i o n  1 
Model 
A 
4 
Programs 
.. - 
Geometr ic  
Model ? 
t Problem 
S o l v e r  
P i c t u r e  
Model 
Programs 
I 
+ E q u a t i o n s  
Ad 
r 
S o l u t i o n s  
P i c t u r e  d 
Model . 
< - i 
Answer 
G e n e r a t o r  
.. v 
Picture 
G e n e r a t o m  
_1 , 
I * 
Diagram Answer 
4 A 
- 
, 
8 
interactions of the objects a.ccolbding to physical laws are written and  solved, and 
answers are generated from the solutions. Finally, a pictu1.e model is coustruc~tc~d ant1 
used to guide the draw.ing of a diagram of the problem. 'T'hese processes arc dt.scribed 
below in somewhat grcatel8 dctail. 
The parsing prograals transform each sentence from a linear starill:: of' words 
into a more structured form in whicli the relationships of words and phrases to  enoh 
other are clearly defined. Each type of phrnse is parsed by a specialist i)rogram which 
implements the grammar of the phrase a s  a11 augmented transition network. The 
grammar programs call the semantic programs both t o  interpret the sel~lalltic network 
structure produced Bs a result of the parsing and to guide the parsing process itself, 
Whether a particular modifier can be used t o  rnotiify a noun phrase, For example, may 
depend on the actual relatio~lships l~etwern objects in the model of the problen~. Af ter  
each clause has been parsed, the semant io lqout ine associated with the mni 11 \terb is 
called to cotnplete the setnantic processi~lg of the clause. This 3et11antic processing 
transfers the illformation provided by the sentence to' a growing model of  the objects in 
the proble~rl and their relationshiljs. Once the se~narltic processing is colnpleted. the 
semantic netxark str~lctures produced by the parser are  no longer used. All of the 
sentences ill the problem statement are parsed and processed semantically before the 
remaining parts of the program are executed. 
T h e  routines grouped under the heading of "Semantic Programs" perform a 
variety of tasks. Semantic routines are associated with verbs and  prepositions, and 111 
some cases with other words. Preposition senl~antic routines must deternline the 
appropriate sense-nleaning of the preposition (using n decision net work based or1 rough 
semantic classifications of the nlodif'ied phrase and the object of the prepositic,~) anri 
then make the, appropriate changes 111 the semantic network token of the modified 
phrase. Verb semantic: ruUMnes typically act to tr:~nsft.r inforrn;~tion from the semant ir 
network ta the internal mtrdul. or dtll'itle relationshil~s anlong objects i11 the model; 
determinatioll of the proper dense-meaning o f  the verb is often uileded as well. Another 
major semautic task is the identification of the referent of a noun phrase. Given a nou~ l  
phrase which denotes a n  object or a location, i t  is necessary to de.c~de whether the 
phrase refers to an  object or location wlilch already exists in the nlodel (and if' there are 
several possibilities, which one it refers t.01, or whether a new object or location must he 
created as the referent of.the phrase ancl axlded to the model. 
After all  the sen'tences of the problem statement have been read, the frame 
creation programs are called to assign to each object a ca~lonical object type (s~icll  a:: a 
point mass or an  "ideal" spring) which represents thr behavior of the ohject as  ~t 
Pppears in the problem. The same t>-pe of actual ntlject nnay hr represented 1 ) ~  clifk~.etlt 
canonical objects. depenciing on  its contest  in the pr,obietn. Thus, a ;~ei.son .n::i be 
represented as a pivot wheir carryllg a plank,  o r  as  n point moss ~ v h e n  standing on ,x:e. 
Once a canonical object frame !1t1i heen selected. the model of rile object is es,inlinri, to  
r C -
22 
-4 
P 
a 
- 
- 
=L 
. . 
4-- 
+ 
+-r 
3 
4 
S 
n 4 
L' 
's 
3 
Z 
C 
- +
I: 
0 
2. 
.A 
3 
3 2 
'r, 
2 C
-fi 
-37 
3 
-L' 
- 4
- 
2 
'I; 
. .-. 
r. 
-
d 
* - 
+ 
-d 
5 
.C? 
s 
n 4
2 
C 
2 
5 
3 
'I? 
P 
C 
P -
-- 
u 
d 
'3 
0 
4
a 
d 4
.c, 
rd 
S 
cd 
2. Review of Previous Work 
This review of previous work, is grouped illto three sections: progriims which 
solve proble~ns tated ill natural lnngunge, natural langui~a processing, allti thcoreticol 
work. 
2.1 Natural Language Problem Solvers 
2.1.1 Bobrow's SfI'UI)I.:NT 
The first natural  language problem-sol~ing progmm \r7ns the STUDENT 
system of Bobrow [Robrow 681 for solving algebra story problems. The natural 
language processing of this program is based on pattern matchillg around key words 
and phrases. The  phrases around the key words become the "variables" in the 
equations which are  constructed from the sentences. Thus. in one of Bobrow's 
examples, 
If the number of customers Tom gets is twice the squirre of 20  percent of 
the number of advertisements he runs, and the number of advertisements 
he runs is 45, what is the number of custom el*^ Tom gets? 
the two phrases "the number of customers Tom gets" and "the number of 
advertisements he runs" are treated as  variables. This problem is thus treated as if it 
were stated 
If x is twice the square of 20 percent of y, and y is 45, what is x? 
The pattern-matching rules break the input sentences into a possibly embedded set of 
"kernel sentences", in an order determined by priority values assigned to the keywords. 
I n  the above example, since "percent" has the highest priority, it would be processed 
first. There is a fairly direct transformation from English sentences into equations: In 
fact, the transformatio~ls are made upon the input sentences themselves until the 
sentences become the equations used in solving the problem. Large segments of the 
original sentences remain a s  "variables" in the equations. 
When the equations constructed from the input are insufficient to find a 
solution, other equations can be retrieved (based on words in common with "variable" 
phrases) expressing general relationships, such as 
(EQUAL (DISTANCE) (TIMES (SPEED) (TIME))). 
Bobrow's program was impressive for its time (about 1965). Howev9r. this 
type of approach has  definite limitations. The technique of transforming sentences 
directly into equations works only when the sentences express algebraic relationships 
among quantities. T h e  "variable" phrases must be similar in each occurrence so they 
can be matched properly, and the key words must, not be used in multiple ways which 
might confuse the pattern matcher. These limitations make it difficult to extend the 
techniques Bobrow used to more.cotnplex problem areas. 
2.1.2 Charniak's CARPS 
Charhiak's CARPS program [Charniak 681 is a program for solving calculus 
rate problems. In many ways, it is an extension of Bobrow's STUDENT program. The 
analysis of the English input sentences is done by pattern matching which is slightly 
more sophisticated than that of STUDENT. The type of' rate problem (distance or 
volume) is determined by the occurrence o f  certain key words in the problem statement. 
Two sets of patterns are used to analyze the sentences appearing in the two types of 
problems. Many of the patterns used are very ad hoc. 
The CARPS program builds a structure (generally a single tree) containing 
the information derived from the problem statement. This structure is used to generate 
the equations required to solve the problem. Additional equations may be derived from 
"world knowledge", but this is again very ad hoc. Thus. while the problems solved by 
CARPS appear very impressive, the program is tailored so closely to this specific set of 
problems that it would be difficult to extend it to additional problems or problem areas. 
2.1.3 Gelb's HAPPINESS 
HAPPINESS [Gelb 711 is a program which solves basic probability problems 
stated in English. This program seems much like Charniak's: it build's a single tree 
structure representing a single problem. and selects a solution method based on the 
occurrence of keywords in the problem statement. The input sentences are broken into 
simple clauses and phrases by pattern matching. These simple clauses are then 
analyzed by a context-free grammar to extract the  canonical verb and its voice. subject. 
and predicate. If certain key words (e.g., those referring to dice and coins) are found, a 
special search for possible modifiers of these words is made. 
This program, like Charniak's. is tailored very closely to a small set of 
specific problem types. It wobld be difficult to extend a program using these techniques 
to handle a new problem area. 
2.1.4 Heidorn's Simulation Programming System 
The NLPQ system of Heidorn [Heidorn 7'21 aqcepts an English statement of a 
queueing simulation problem, and produces from it a program in the GPSS simulation 
language which will simulate the problem. The system is interactive: it requests 
additional information from the user when the problem statement is incomplete. allows 
the user to ask questions about the simulation model, and can generate a complete 
problem description in English from its internal model. 
English sentences are parsed and gei~erated frotn two interpreted phrase 
structure grammars augmentetl by some semantic programs. These grammars go down 
to the character level, and  handle English morphology as well us phrase structtire. 'l'he 
grammar is based in part on the theory of  stratificatio~lal inguistics. The basic unit of 
storage in the internal tnodel is the "record", which is komputationally equivalent to a 
LISP atom with its property list. 
This program represents an  advance over those considered previously in this 
section. It uses a legitilnate grammar to parse the inpup sentences, and can constrtict a 
mpdel which expresses relationships among a number of ot)jjects. The grammar is 
specialized for simulation problems, and  would have to be modified to extend the 
program to other areas. However, the performance of this system is quite impressive. 
2.2 Natural Language Processing 
2.2.1 Woods' Augmented Transition Networks 
Thc Augmented Transition Network (ATN) of Woods [Woods 501 is a 
powerful formalisnl for representing grammars. The grammar of ISAAC, while written 
in "pure" LISP, is equivalent to an  ATN grammar. A transition network consists of a 
set of nodes (representing states) and a set of directed arcs between the nodes which 
specify transitions between states based upon the input string being scanned. An ATN is 
augmented in several respects. The test associated with a state transition may be 
arbitrarily complex, depending on the previously parsed structure as  well a s  the input. 
T h e  test may be the name of another transition network, in which case control is given 
to tha t  network a t  a lower level, effecting a "subroutine call" to the subordinate 
network. These calls may be recursive. Transition arcs may also be augmented by 
arbitrarily complex strhcture-building actions: The  structures so built are  passed 
among network levels in designated registers. If a n  attempted parsing of a subnet fails, 
the ATN interpreter automatically handles backup from the failure point and tries 
another possible transition. The automatic backup and clearly defined interface (via 
named registers) between network levels make the ATN a very "clean" formalism for 
writing grammars. 
2.2.2 Winograd's SHRDLU 
Winograd's widely known SHRDLU program [Winograd 721 allows a person 
to converse with a simulated robot about a "micro-world" consisting of various colored 
blocks on a table. The  robot may be asked to perform actions such as  moving blocks or 
building structures and  to answer questions about the state of the micro-world or about 
its motivatiolls for performing particular actions. The system employs a large grammar, 
based on Halliday's theory of Systemic Grammar. Much of  the knowledge in t hc system 
is represented in the form of MICRO-PLANNER theorems. This miikes it easy for 
programs to be generated to find the answers to questions about the world model, and 
allows a number of logical forms such as conjunction. disjunction, and qu:\ntification to 
be handled naturally. The  theorem prover base is a source of consider~~ble  power for 
certain types of semantic operations. The  semantics is made much easier hv the small. 
finite world of very simple objects (colored blocks). Still, the SHRDLU svstpm remains 
one of the largest and most powerful natural language systems produced to date, anti its 
fame is well deserved. 
2.2.3 Wilks' Preferential Semantics 
T h e  work of Wilks [Wilks 751 is unique among "artificial intelligbnce" 
approaches to  natural language processing in that  Wilks is interested primarily in 
machine translation, rather than in deep understanding of natural I anquage by 
computer. However, there is a n  interesting parallel between the semantic templates 
used by Wilks and some of the semantic processing done in ISAAC. which is of course 
concerned with deep understanding. 
In Wilks' system, a sense meaning of a n  English word is represented by a 
formula, which is a list of element names. The  elements are approximately 70 semant~c  
classes which roughly classify the entities, qualities. actions, etc. which occur in English 
sentences. Examples of such elements are MAN (human being), STUFF (substances), 
KIND (qualities), and CAUSE (cause to happen). These elements may be combined into 
a formula to represent a word meaning, as  in (FLOW STUFF) for the word "liquid". 4 
sentence is analyzed by trying to  fit a template (whicliis a list of element types) to some 
of the possible sense meanings of the words occurring in the se~ tence .  The  templates a re  
intended to represent the basic types of "messages" that people wish to convev in 
language. For example, the template MAN BE KIND would represent the class & 
messages in which the sentence "My sister is pretty" is included. 
After (possibly several) templates have been fitted 3 a piece of text, 
"preferences" of parts of each template are examined to s e e  if they are satisfied. A verb. 
for example, may prefer a n  animate subject. The template for which the greatest 
number of preferences are fulfilled will be chosen as  the intended meaning; however, 
possible fillers for the template slots will be accepted even though they do not meet the 
preferences, provided that  the template a s  a whole is the best match. 
There is considerably more detail to Wilks' system which will not be covered 
here. We mention Wilks because there seem to he parallels between some o f  his 
techniques and  techniques used in ISAAC. One such parallel is the use of rough 
seinantic classes to distinguish between sense mea~lings of worcls, which we follt~tl-to he 
particularly useful for determining pr.cl~osition meanings. Othurs hove rev-tninljt uxrtl 
rough seninntic classes tn distinguish srllse melulings in sporial applichtions: \Yilksl 
work is valuable for investigating this techllicluu over a large subset of3Rnglish. 
A second parallel lies in the ncreptnnce of 11 tvord (or lr~rger uni t )  which t'ails 
to meet the preferences of the template which rovers it. 111 the ISAAC system, this 
acceptance is an active process in which a11 acceptable it~terpretntion n u s t  hr 
constructed fro111 the given unit. These proccssrb ilre ciiscussed in more drtclil 111ter. 
2.2.4 Sinlmons' Senlt~ntio Nettvorks 
The Semantic Network formnlism of Sio~mons [Simmons 7:l: S i m m c ~ ~ s  and 
Bruce i l l  provides n po\verful and convenient method for representing the elements of a 
sentence and the semantic relations (deri\-ed from a variety of syl~tactir forms) \ ~ h i r h  
hold between them. 111 effect, it prodL~ces at1 ordei Tng of the argulhents ofLa ~ t ; . l ~ l a t ~ t l ~ '  
grouping (guch as a verb and its case arguments, modality, and optional modlfieraj 
which is invariant cnrer the various syntactic orderings which express the same 
relationships. Thus. 
John gave Mary the book. 
John gave the book to hIary. 
The  book was given to  hlary by John.  
would al l  generate the same semnntir netv-ork structure. The semantic netwo1.k 
formalism has beell used for language gene]-ation [Simmons and Slot~~1111 721 AS \v(3ll 3s 
parsing. [Simmons and Bennett-Novak 751 shows how these structures may he usetl to 
produce a small natural language understanding system with a minimum of effort. 
The  structures used by ISAAC in understanding sentenc'rs are ,a na tu ra l  
extension of Semantic Networks as used by Simmons, In  order to handle unultiple 
s ~ n t e n c e  discourse, links are made from tokens in individuai senterlces to the refel-mts 
of the tokens in the problem model which is being co~lstructed. Semantic interpretations 
are placed on some tokens as their meani~lgs are determined: Particular semantic 
interpretitions may be specified based on information from many different sources. 
Making an interpretation of a token may cause links to be made from that token to 
objects not mentioned in the sentence and may generate additional inferences about the 
relationships of the objects involved. These processes are discussed in derail in later 
chapters. 
2.2.5 Schank's Conceptual Dependency 
" w The Conceptual Dependency system of Roger Schank [Schank 73.  , a ]  is a 
theory (embodied in a series of computer programs) which postulates that the concepts 
transmitted in natural language can be reyri?setlted as col-11plex structures bnsecl on a 
small number of primitive actions. The primitive actions are linketl by named links t o  
their case arguments (some of which are other primitive action groups) and to other 
groups to which they are related, e.g.; causally. Some case arguments we mal~datory,  so 
that ih "John hit Mary" we must infer a n  instrument in this case John's  Ililnd) used i n  
performing the action. 
While the structures and actions used by S c h ~ n k  are not very useful for 
physics problems, some of the concepts he uses (such as inferring a required 
semantic object when it is u nspecifird) are basic to  almost any language u nclerst antler. 
&hank's work is also importfa nt  because l ~ e  has defined a set of' primitive concepts and 
actions which can be used to express a fairly wide rmge  (though certainiy 11ot all)  of 
natural language sentences. 
2.3 Minsky's Frame System Theory 
Minsky's frame system theory [Minsky 741 pi-oposes that knowledge i s  
9 
organized (in humans and, potentially. in computers) in terms of interconnected 
elements called Frames. 
A frame is a data-structure for representing a stereotyped situation, like 
being in a certain kind of living room, or going to a child's birthday party. 
Attached to each frame are several kinds of information. Some of  this 
information is about how to use the frame. Some is abgut what one can 
expect to happen next. Some is about what to do if these expectations are 
not confirmed. 
A frame may have "slots" which can be filled by the particular "arguments" invc~lved 
in an instantiation of the frame. There may be procedures associated with n frame to 
determine the suitability of proposed arguments and to infer values for those which are 
unspecified. 
Minsky also makes some general comments about how frames may be used 
in computational linguistics. 
. . . in understanding a discourse, the synthesis of a verb-structure with its 
case-assignments may be a necessary but transient phase. As sentences 
are understood, the resulting substructures must be transferred to a 
growing "scene-frame" to build up the larger picture. 
Minsky's frame system theory has been immensely popular-so popular that 
many people are claiming thatframes are exactly what they bave been doing all along. 
There are many similarities between the processes and data structures used by ISA.4C 
and the frame systems described by Minsky, and the term "frame" will be used in 
describing some of them. The interpretations given will of course be those of the author. 
The idea of frames is a powerful one. but the mechanics or their implementation 
remains a problem for research. 
3. Parsing 
3.1 Introductiol~ 
Parsing, as used in this chapter., means the process of assigning a structure to  
the linear string &of words rotnprising a sentence so that the syntactic relationships 
among the words and phrases in' the sentence are tnade explicit. The  processes of  
relating the structures in the  sentence' to parts of the developing model of the problem 
and of determining the meaning of the structures will be treated in the chapter 011 
Semantics. Obvionsly, there is no clear division hetween what  is syntas and what is 
semantics; many constructions could be claimed to be either. In the sentence processing 
done by ISAAC, syntactic and se111~1ltic processing are frequently intermixed. We shall 
describe the two parts separately to make them easier to understand, while trying to 
indicate the points a t  which they interact. How to best organize th8 interactions of 
syntactic and semantic processes in a language understanding program remains an 
unsolved problem. 
Although the parsing programs in ISAAC are written in "pure" LISP, their 
structure is strongly influenced by the Augmented Transition Network (ATN) 
formalism of Woods [Woods 701. An ATN grammar allows sub-grammars for phrases 
to be called (recursively) as subroutines by other grammars. A grammar program may 
build structures which are passed back to the program which calls it. I n  case an 
attempted subgramrnar fails. the grammar interpreter automatically backs up  from the 
failure p o i ~ t  and tries the next possible alterllative which is specified. These features of 
ATN grammars are also present in the parsing programs of ISAAC. The grammar 
programs are organized as  a set of parsing functions, most of which parse a single 
functional unit, such as a noun phrase. This orga~lization in terms of functional units 
seems natural because it allows the grammar functions to communicate with each other 
by passing pointers to complete, well-defined functional structures. A noun phrase, for 
example, causes the production of a noun phrase token structure which has a standard 
form, independent of the function of the noun phrase in the sentence. Grammar 
functions which parse larger syntactic units, such as  a clause, connect the smaller 
structures, such as noun phrase and verb phrase tokens, by means of named links which 
specify the relationships of the phrases in the sentence. 
The structures which are produced by the parsing programs bear a strong 
resemblance, to the semantic networks of Simmons [Simmons '731. The grammar 
functions which parse the major phrases. such as noun phrases and verb phrases, 
produce,"token" structures which represent the itlforlnation in the phrase in a standard 
and readily accessible form. Other grammar functions, such as  those which parse 
prepositio~lal phrases and other modifiers, may make changes anti add information to 
the modified token structures rather than creating new structures themselves. The  links 
between token structures may specify semantic relationships (for example, that one 
noun phrase namesea location on the object referred to by another noun phrase) as well 
as  syntactic relationships. In  some cases (e.g., w i th  prepositional phrase modifiers), the 
semantics may be done at onct, so that  semantic links among the tokens are not needed. 
A s  semantic processing proceeds, the token network structure is elaborated by adding 
semantic intelbpretations to some tokens a ~ l d .  by creating links between some tokens and 
the objects to which they refer in the program's model of the kvorld. These semantic 
processes may render a toke11 unnecessary and leave it unlinketl to thL: rest of the  
structure. After all the semantic processing has been done, the information in the 
sentence has been transferred to the world nlodel, and the network of toker~s is no 
longer needed. 
3.2 Control Structure of the Parser 
T h e  parsing programs are  written a s  LISP functions. without using an  
additional interpreter as a Woods system does. Automat~c backup and control of the 
scanner which points tq the current position in the sentence being parsed are  
accomplished bv - a set of small functions which are called from within the individual 
parsing programs. These functions set the system registers (global variables) 
appropriately for the current state of the parser. 
A sentence is represented internally as an ordered list of ~vords. As the 
sentence is scanned from left to right, the global variable SENT is set to point to the 
current position in the sentence. The  current word (or multi-word unit) being scanned is 
put info the * register. Thus, a grammar program could test whether the word currently 
under the scanner is "and" by using the LISP code (EQ * "AND), where the quotation 
marks are a n  abbreviarion for the function QUOTE. The  parsing of a sentence is 
initiated by setting SENT to the sentence and calling the function S E T V o  set the :': 
register. When a grammar program wishes to move the scanner one position to the right. 
i t  does so by calling the function ( => ). The  next word to the right and the second word 
t o  the right may be gotten by using the functions (NEXT) and (NEXTS), respectively, 
without affecting the position of the scanner. The function CAT (category) is frequently 
used to test whether the word currently under the scanner is in a particular category, as 
defined in the lexicon. Thus, (CAT "ADJ) may be used to test whether the current word 
is a n  adjective. 
Since the parser operates from left to  right, it sometimes happens that  a 
grammar program fails tojfind the type of phrase it expects, after it has moved the 
scanner from its initial position. For example, in parsing the sentence "To err is 
human", the parser might first a t , t e ~ i ~ p t  to pilrse a prepositional phrase. The preposition 
would be found, and the noun phrase parsel would be cnlled after nroving the scanner. 
The noun pllrnse parser woulcl finti the verb "err", and so, it a n d  the prepositional 
phrase parser wnuld fail. In  order to handle such cases, it is necessary to l ~ e  able to save 
the current y~si t ion in the sentence so that the  purser can bark up and try something 
else when an  attempted parsing fails. This is nccornplishetl by calling three smitll 
functions, SAVE, SIJCCESS. ant1 FAIL, within each parsing function. Nornmally, n 
parsit~g Rulctiun i l l  esecute (SAVE) ils its firsl.action and esecutc either \ FhII.) or 
(SUCCEBS), as appropriate, immedintely before it esits. SAVE s:nPes the poil~tcrs t o  the 
current point in the sentence on a push-down stark. In  atitfition, it saves the current 
point in the list of generated atqms,  so that ntly atoms gene~ated  by a ftlnction a hich 
later fails can be deleted. SUCCESS removes one set of pointers from the stack: since 
the attempted parsing was successful, these pointers are no longer needed. FAIL 
restores the pointers to the sentence to their original position, and calls SET to restol-r 
the * register. In addition. it releases any atoms which may have bee11 generated by the 
function which failed. 
In order to illustrate how the parsing functions are actually written, a simple 
function to parse a noun phrase (using the same conventions as the parsing programs of 
ISAAC) is shown below. This program parses a simple noun pht-afe consisting of an  
optional determiner, zero or more adjectives, and a noun. The program s~lcceeds and 
returns True if it finds such a ph~+ase:  otherwise, it restores the pointers uslng FAIL and 
returns NIL. No structures are built by this program, but it is easy to see how structure- 
building code Could be added. 
(NP (LAMBDA ( ) (PROG ( 7 
(SAVE) 
(COND ((CAT WET) (=> )) )  
A (COND ((CAT "ADJ) ( => ) (GO A ) )  
((CAT "NOUN) (=> ) (RETURN 
(SUCCESS))) 
(T (RETURN (FAIL))) )  
1)) 
This pmqram accepts a noun phrase equivalent to that accepted by the 
following grammar: 
Using the Woods ATN formalism, such a program could be written as  followkr 
(NP/ (CAT DET T (TO NP1)) 
(TST T T (JUMP NP-1 ) ) I  
(NP1 (CATADJ T (TO NPI ) )  
(CAT NOUN T (TO NP2))) 
(NP2 (POP T T)) 
Our method of writing pnrsing-functions requires t h ~  writing of slightly more 
code than is required for a Woods interpreter system, but s i t  avoids the overhead of 
interpretive execution. 
The functibn SET*, which sets the value of the 'X register, checks for 
maltiple-word units, and replaces them with single words in the * register. "As much 
6 6 as", "center of gravity", cross section". "point of application", and "so that" are 
recognized as multiple-word units. These gl-oupiqgs could have been lrandled by other 
methods, but replacing themby a single "constructed" word is a convenient way to do 
it. A large parsing system wpuld need to be able to back up ?n case the multiple-word 
interpretation was incorrect; in our limited field of physics problems no such 
ambiguities accurred. Becker [Becker 751 has argued that such groupings play a major 
role in language. 
Values are passed between levels of the grammar using the normal LISP 
conventions of function arguments and returned values. A returned value of NIL 
always indicates failure of a grammar program. A grammar program which succeeds 
may return a generated token atom (as in the case of a Noun Phrase), or it may attach 
its results to existing atoms and simply return True (as  in the case of a Prepositional 
Phrase). Some grammar functions have no arguments. but others (such as the Verb 
Phrase) have quite a few. 
3.3 Data Structures Produced During Parsing 
As a sentence is parsed, the grammar programs create a set of intertinked 
nodes representing the major phrases (primarily Noun Phrases and Verb Phrases) of a 
sentence. These networks initially bear a strong resemblance to the Semantic Networks 
of Simmons [Simmons 731. As semantic pmc:essing of the sentence progresses, modifiers 
of the nodes are removed or changed in form, semantic interpretations are added, and 
links are made from the nodes to objects and relations in the developing model of the 
problem. Finally, after execution of the verb semantics, the network is discarded. 
Each node in the parse network is a GENSYM atom whose name is TOK 
followed by a number. Features of the node (also called a "token atom" or "token") are 
stored on its property list. The "main" word of the phrase (usually, but not always, a 
word from the sentence) is stored under the indicator TOK. The type of phrase is stored 
2 0 
under the indicatcjr LFRAME (Linguistic Frame); the poltsible types o f  LFRAMEs a r*r 
NP ( N o ~ i n  E)hrase), VP (Verb Phrase), QNP (Q\iestio~z No~in  I'l~rase), and IIEIINP 
(Relative Noun E'hrase). The noun phrase "each end'' in P;3", for ~ x a r ~ i p l e ,  w o ~ i l d  
generate the fo l lowi~~g token: 
TOK89 TOK END 
LFHAME NI1 
NBR (Ns) 
MODS ((,QNTFIZ EACH)) 
SFRAME LOCPARrr 
SEMOBJ (SCAFI+'OIJD85) 
RFNT (LOG91 L0C:lo) 
The first four items 011 the property list o f  the token,are cre:~trd by the 
parsing program. NRR.is the Nuntbur ( N o u n  Singulm),.nntl h1OI)S is n list of modifiei*?;, 
in this case the quantifier EACH. ' I 'he~emnining property list items are ~tl(lrti tluring 
semantic processing: S FRAME (Semantic Frame) is LOCat ion PART; .$E:hlO BJ 
(Semantic Object) is a link to the object in the  problenl ~llotlel which the location refvrs 
to, in this case the scaffold SC'AFF0LYH;'r. RFN'I' (Referent) is a list o f  painters t o  the 
items in the problemmodel to which the phrase refers: the  locarions LOC91 and LOC!)O. 
When the semantic function for the verb is exec~ited. it will dehl tllrcctly with the 
Referents of the phrase, independent of the syntactic construction in the original 
sentence which caused those referents to be selected. 
:3.4 Noun Phrase Pmsing 
In this section w e  will esalnine in some detail the parsing of the noun phrase 
anci its modifiers. 
3.4.1 Basic Noun Phrase 
A flowchart of the  NP parsing program is shown in Figure 3.1. A flo6chart is 
used to describe the program because a transition nkt of this size would be unlvieldy. 
and because a flowchart can mare closely folloiv the actual program structure. ti few 
nonstandard conventions a re  used in the parser flowcharts in *this chapter. A test 
consisting of a word in capital letters indicates a test of whether the word currently 
under the scanner (the word in the '$ register) is in that  category. (NEXT) indicates the 
next word to  the right, and (NEXT" indicates the second word to the 1-ight. The symbol 
=> appearing next to a line indicates that  tohe scanner is moved to the right along that 
control path. The symbol +- indicates that  the right part is appended to the lett: 
* References to  the example problems are  denoted by the letter P f o l l o ~ ~ e d  
by the problem number. 

Proper Noun 
" A t  (B) che ocher end 
Y P  TOK - (NPAPP NIVIEY 
P I 
HODS 4 ("NAME NMLE) 1 
Figure 3.1 (page 2 )  
Put NAME on TOK 0 

generally, A +t- B is implemented ss 
(SETQ A (NCQNC A (LIST B))). 
Phrases in quotes next to corltrol paths are examples of phrases which would follow the 
indicated paths. 
The initial tests in the flow diagram tgst for proper nouns, geometric names, 
and pronouns, which are handled separately. [Geometric names, as in  "AT END (A)", 
are represented in LISP as lists containing the names; in the original sources from 
which the problems were taken, such names were written as italic capitnls.] The 
determiner, if present, is saved. A series of tests separates the use of a measurement 
(e.g., "10 ft") as  a noun phrase by itself or as a modifier ("a 10 f~ pole"), while 
prohibiting it if it precedes a relative preposition (as in " 10 f t  from . . .") since this form 
is more easily handled as  part of the prepositional phrase. Adjectives which are marked 
NULLADJ are ignored. Thus, "a tapering wooden telegraph pole" (PI 1) is treated the 
same as  "a pole". This is one of the few cases in the parser where information from the 
problem stqtement is ignored. Possessive pronouns are rewritten a t  once; the referent of 
the corresponding root pronouh is found, and a modifier of the form (POSSBY referent) 
is constructed. This modifier retains the ambiguity of the type of possession. Not 
surprisingly, there is considerable similarity between the semantics of POSSBY and 
some of the sense meanings of OF. Thus, for example, "its end" and "the end of the 
lever" will be reduced to a n  identical form when processed semantically. 
When the noun is found, a token atom is created for the noun ph ra~e ,  usually 
using the singular form of the noun as  the token name. In some cases, however, an 
expanded definition is used, resulting in the use of a different token name and the 
generation of additional modifiers. Thus, PAUL becomes PERSON, (SEX MALE), 
(NAME PAUL) and BOY becomes PERSON, (SEX MALE), (AGE YOUNG). This 
expansion eases the identification of the same object when it is referred to by different 
words; the identification of these two tokens will result in the inference that Paul is 
young. The modeling of words as carriers of modifiers to be applied to their root 
concepts is an interesting area of research; [Simmons and Amsler 751 are investigating 
this type of modeling for verbs of 'motion and communication. 
After the noun token is made, an  attempt is made to execute the semantics of 
each of the modifiers which have been found. Some modifiers will make changes directly 
to the NP token; others will create new modifiers which are saved for later processing. 
9 1 
"Both",-for example, will create modifiers equivalent to "Each of the two . . . . 
The pronoun matching algorithm which is used is very simple. A pronoun 
which was previously used is matched to the same referent as  before. Otherwise, the 
last-mentioned candidate which matches the pronoun in number and is appropriately 
human or inanimate is chosen. This technique is fairly crude, but it worked for this class 
of problems. In  general, finding pronoun referents can be very difficult. [Charniak 721 
considers this problem in some detail. 
3.4.2 Noun Phrase Compounds and Modifiers 
Conjunctions and modifying phrases int ~oduce  many potential ambiguities 
into the parsing of a sentence. In  a noun phrase containing two prepositional phrases, 
for example, the second prepositional phrase (Pp) might modify either the top-level 
noun phrase or the noun phrase in the first PI?. A conjunction het*ween two noun 
phrqses might join them into a compound noun phrase, or it might connect two top?level 
clauses containing the noun phrases. Although syntactic constraints' may select the 
correct interpretation in some cases, in many other cases the choice cambe made only on 
semantic grounds. For example, in 
Lowering the level of the lake allows city officials to kill weeds and 
residents to repair their docks. 
we must use semantic interpretations to reject the possibility that "weeds and 
residents" is a compound noun phrase. People seem to make these choices easily and 
correctly the first time they read or hear a sentence; only rarely do they have to back up 
and re-parse a sentence in order to interpret it correctly. The parsing programs of 
ISAAC rely heavily on,semantic tests to reject incorrect combinations of phrases. 
A noun phrase may be' modified by a prepositional phrase,, an adjective 
phrase, or a dependent clause. In each case, the parser for the modifying phrase is called 
with the NF token as  an argument. The modifying phrase parser may reject the 
combination on semantic grounds even though the appropriate syntactic constituent is 
found. This is especially important in the case of prepositional phrases. Compound 
modifiers, as in "a uniform scaffold 12 ft long and weighing 100 lb" (P5), are permitted. 
Conjoined noun phrases are required to all  be members of the same semantic 
class, which may be one of the set PERSON, PHYSOB (physical object), LOCNAME 
(location name), ATTRNAME (attribute name), or MEASU (measurement unit). 
Pronouns are prohibited as members of dompound noun phrases. These tests handled 
almost all cases which OCCUII-ed in the set of test problems. One pathological sentence 
required additional treatment: 
If it is placed on the edge of a block 1.5 m from the light end and a weight 
of 750 nt added to the light end, it will be balanced. . 0'14) 
Since the auxiliary "is" is omitted in the second clause, "added . . ." could be 
considered a dependent clause modifying "weight", and "blork" and "weight" could be 
combined as a compound noun phrase under the above rules. This problem was solved 
by a semantic test associated with the preposition "of' which prohibits a compound 
object noun phrase for such cases. This is not a very pleasing solution. People probably 
accept "edge of a block" as  a well-formed unit  before reaching the secuand clause, and 
thus do not consider combining "block" and "weight". The depth-first operation of this 
parser allows it to go fairly far afield in such cases; additional semantic tests to allow 
some constituents to be combined earlier would be a desirable, but difficult, 
improvement. 
3.4.3 Noun Phrase Variants 
There are three *small parsing programs which accept variants of noun 
, 9 phrases. THERENP accepts "there" as a tloun phrase in cases such as  "there is . . . . 
9 Y QNP accepts a noun phrase beginning with a question word, as in "what force . . . , 
RELNP parses a "relative noun phrase" containing "as much as", as in "the man 
supports twice as much as  the boy" (P7). The multiplicatioll factor is saved, and a link 
is made to the noun phrase involved in the comparison. 
3.5 Verb Phrase Parsing 
3.5.1 Basic Verb Group 
The verb group, which is parsed by the program VG, consists of a set of 
auxiliary verbs, a main verb, and optional adverbs. The flowchart of VG is shown in 
Figure 3.2. Since tense and modality are not needed for our type of physics problems, the 
auxiliary verbs are ignored except for determining whether the verb group is active or 
passive. Other authors (for example, [Winograd 721 ) have given procedures for 
determining verb tense f r o q  the auxiliary verbs. 
The program VG has six arguments. NPHD is a noun phrase token which is 
the syntactic subject of the verb. VPHD (if specified) is a verb phrase token which is 
either the first part of a compound verb phrase or the initial auxiliary verb which is 
separated from the rest of the verb group in a question. CMPND is a flap which is true if 
the verb group is part of a compound verb phrase. DCLF is true if the verb group is part 
of a dependent clause; DCLP is true if the dependent clause construction is passive. 
QFLG is true if the verb group is a top-level verb group in a question. 
The flowchart of VG is fairly straightforward. If a previous verb phrase is 
available from a separated verb group in a question, it is deleted and incorporated into 
the main verb group. The syntactic subject is attached to the verb phrase as  subject or 
object depending on whether the verb is active or passive. This transformation frees the 
verb semantic programs from-having to concern the~se lves  with the voice of the verb. 
In  a compound verb phrase without a subject (object if passive), the corresponding 
phrase from the first verb phrase is used. Thus, in "John was tarred and feathered", 
"~ohn" would be used a s  the object of "feathered". 

3.5.2 Verb Phrase 
A flowchart of tlre verb phrnse parsing program, Q1', is shown in Figure :I.:). 
VP first parses n verb group by calling VG, then i*ollcrts tllt.' rennt~inillp prt1dic;ltc. 
phrases and modifiers and attaches them to the verb phmsu loken. These phrnses 
include tho syntactic object noun phrase oradjeciive phrase, an i~lfiniti\+e verb phl*nse 
object (as in "they wlui~t to go . . ."), and prepositiollnl p11r~ses o r  adverbs modifying 
the verb, 
After parsing a verb group, VP calls VPMODS t o  collect \*erb modifiers 
(adverbs and prepo~it~ional phrases). An  infinitive verb phrnse objort is r0llt3rted if 
present and attached to the \perb phrase token under the indicator INFOBJ. If a 
question is being parsed, the  subjecb and the remainder of the separated group are 
collected. A prepositional phrase on HOLD (that is, one which occurred at the st art of 
the sentence and could not be attached to anything, e.g. "At (B), the other end of the 
pole, there is , , ." (P15) is attached to the verb phrase if possible. The predicate noun 
phrase or adjective phrase is collected, along with any remaining modifiers. If the verb 
phrase is part of a dependetlt clause, it is required to  contain more than just a verb. A 
dependent clause (DCLAUSE) is attached to the t o k k  of the phrase it modifies. 
3.6 Prepositional Phrase Parsing 
The  structure of the prepositional phrase is fairly simple. I n  addition t o  the 
usual PP consisting of a preposition and noun phrase, the PP parser accepts a phrase 
involving a measurement and a preposition and noun phrase (as i n  "10 ft from one 
end") a s  a single prepositional phrase. Hoth t -yes  may involve question phrases, as  in 
"at what ppint" (P7) and  "how far from the center" (P20). 
T h e  PP parser behaves differently from the other parsing programs in that  it 
saves a well-formed result which cannot be attached to the head token which was 
specified, due to semantic constraints. If the  PP parser is called again to reparse the 
same phrase (as  it surely will be), it applies the semantic tests to its previous result and 
the new head token. This not only saves the work of reparslng a n  identical phrase twice, 
but more importantly, it  prevents side effects which occur during the parsing from being 
repeated. These side effects (such as  the creation of a new object in the model of the 
problem) violate the restriction on a pure Woods net parser tha t  all results be passed 
between programs in designated registers; hence, the effects are not undone when 
backup is made from a failing parse attempt. We could make all such actions reversible, 
as in CONNIVER [McDermott and Sussman 721, but such arl approach exacts a high 
penalty in computational overhead. Our approach is probably safe for prepositional 
phrases, which cannot in general be parsed a s  anything else. The pure Woods net 
approach makes it difficult to mix syntactic and  semantic processing. More research is 

needed on ways to intermix the two and still be able to bnck up when necessary, without 
incurring too much overhead. 
Preposition semantics are executed, when possible, as soon as  the 
prepositional phrase has been parsed. In some rases, the se~nontic routine will electlo 
delay the s e m ~ n t i c  processing. In these cases, the PP is saved on the head token under 
the indicator' PPS for la&r processing. 
3.7 Clause Parsing 
The clause parsing programs, CLAUSE and QCLAUSE. are relati\?ely 
simple programs which accept the several for~ns of declarative, ia~perative, u i ~ d  
question clauses. An iuitial prepositio~~nl phrase, if present, i s  placed on n HOI,D list for 
later processing. A noun phrase or question phrase is parsed and then used as all 
argument for calling the verb phrase parser. The result of parsing a clause is the verb 
phrase token, which contains pointers to its various arguments. This verb phrase token 
is passed as an argument to the verb serna~ltics driver, EXVBSEM, which completes 
semantic processing of the sentence. 
Figure 3.4 shows the structure formed after parsing and seniantic processing 
of a complete sentence. Much of the information iri the structure is produced by the 
semantic programs after parsing, but we will describe it briefly as an introduction to the 
semantic processes. The root of the parse tree (the value returned by the SEWTENCE 
parsing function) is TOK185, the verb phrase token for the main verb of the sentence. 
The object of the verb is TOKltll ,  which was the syntactic subject (since the verb phrase 
is passive); the subject (agent) of the verb is TOK186, which was intl~oduced by the 
preposition "by". The semantic routine for "by" sinlply attached its object phrase 
token, TOK186; to the verb phrase token as the subject of the verb; hence, there is no 
need for "by" to appear anywhere in the structure) T O K l 8 l  is the noun phrase token 
produced from the initial noun phrase of the sentence; it is a TOKen of the word 
SCAFFOLD, is a Linguistic FRAME of t-ype NP (Noun Phrase) has an  INDEFinite 
DETerminer, and has a NBR (number) of NS (Noun Singular). The modifier "12 f t  
long" has been converted to the form (LENGTH 12 FT); the same modifier form would 
be produced for the phrase "a 12 f t  scaffold". TOK181 is the syntactic subject of a 
DCLAUSE (Dependent CLAUSE) whose verb token is TOK182. The SFRAjWE 
(Semantic FRAME) interpretation of TOK181 is PHYSENT (PHYSical ENTity), and 
its RFNT (Referent) is SCAFFOLD184, which is a n  object in the model of the problem. 
The remaining tokens shown in the figure have a similar structure. The modifier 
"vertical" of TOK186 has been converted to the form (ROTN 90); this token has two 
referent objects. The modifier*"its" of TOK188 was converted to a modifier of the form 
(POSSBY SCAFFOLD184), which was semantically processed to make TOK188 a 
LOCPART (LOCationlPAIiT) SFRAME whwe SEMOBJ (SEMantic ODJect) is 
SCAFFOLD1 84; idelltif'ication of the location referents of TOK 188 yieldad the two 
locations LOC190 and LOC189, which are locations on SCAFFOLD184 in the model of 
the problem. Since TOKIBN was the object of a preposition, semantic processilig of the 
prepositional phrase transferred its referents to a modifier of the verb phrase TOK187; 
this left TOK188 unconnected to the rest of the structure. 
3.8 Conclusion 
The computer time required for parsing and semantic processing averages 
about one second per sentence, running on a CDC 6600 and using interpreted LISP. The 
parsing programs constitute only about 15% of the total; the semantic programs are 
twice as  large. Syntactic processing is thus a -relatively small part o f  the complete 
process of language understanding. On the other hand, this program has convinced the 
author thax even in so constrained and well-defined an area as  physics problems, 
syntactic processing cannot reasonably be isolated and done without recourse to 
semantic tests, some of which ultimately involve reasoning based on the particular facts 
which are known about the objects being discussed. 
"A uniform scaffold 13 ft long and weighing 100 lb is supported horizontally by two 
vertical ropes hung from its ends." 
TOK181 TOK182 
TOK SCAFFOLD TOK WEIGH 
LFRAME NP LFRAME VP 
DET INDEF MAINVB WEIGHING 
NBR (NS) DCLAUSE ?'T* 
MODS (UNIFORM (LENGTH 12 FT)) INTRANS *T* 
DCLAUSE (TOK182) ACT *T* 
SFRAME PHYSENT SUBJ TOIC181 
RFNT (SCAFFOLDl84) COMP TOK183 
TOK183 
TOK LB 
LFRAME N P  
QTY 100 
TOK185 
TOK SUPPORT 
LFRAME V P  
MAINVB SUPPORTED 
AUX (1s) 
TRANS *T* 
PASV q* 
OBJ TOK181 
SUBJ rOK186 
TOK187 
TOK HANG 
LFRAWE V P  
MAINVB HUNG 
DCLAUSE *T* 
INTRANS *T* 
PASV *T* 
OBJ TOK186 
MODS (LOC FROM (LOCI90 LOC189)) 
TOK186 
TOK ROPE 
LFRAME NP 
QTY 2 
NBR (NPL) 
MODS ((ROTN 90)) 
DCLAUSE (TOK187) 
SFRAME PHYSENT 
RFNT (ROPE192 ROPE191) 
TOK188 
TOK END 
LFRAME NP 
NBR (NIX,) 
SFRAME LOCPART 
SEMOBJ (SCAFFOLD184) 
RFNT (LOCI90 LOC189) 
Figure 3.4: Structures Produced for a Complete Sentence 
It may be helpf'ul a t  this stage to realize that the primary form of 
mathematical communication is not description, but injunction, i n  this 
reppect it is comparable with practical art forms like cookery, in  which 
the taste of a cake, although literally indescribable, can be conveyect to a 
reader in the form of a set of i~~junctions called a recipe. 
-G. Spencer Brown 
4. Semantics 
4.1 Introduction 
Semantics, for our purposes, is the procr.ss of constructing the meaning of a 
sentence: the process of relating the objects in the sent.cnce to objects in the world model 
of the reader, and of updating the world model to reflect the meaning of the sentence. 
The sentence itself is not a description of the meaning, but rather a set of injunctions, a 
recipe which can be followed to construct the meaning from what the reader already 
knows. 
As the above definition implies, the way in which a sentence is interpreted 
depends strongly on the knowledge, intelligence, and inclinations of the reader. As is 
well known, different readers will interpret the same text (even in physics problems) in 
different ways. A semantic interpretation of a sentence may, be viewed as  satisfactory or 
unsatisfactory for a particular purpose, but it would be difficult to judge it as "right" or 
1 4  wrong." 
Updating the world model to reflect the meaning of a sentence can be a very 
involved process, since the meaning of a single sentence call have many consequences. 
In  our physics problems, these deductions do not propagate very far beyond the 
immediate understanding of a sentence during the time when the sentences are being 
read. In this chapter, then, we will primarily discuss "linguistic semantics," which we 
may define as  the semantic processing up to the point a t  which the parsing of a sentence 
may be discarded. This distinction is well defiried within the computer program. Under 
this heading there are a number of distinct semantic processes: determining the 
meaning of ambiguous words and phrases; finding anaphoric referents (such as  
pronoun referents) and elliptical referents (such as  the physical object referred to when 
a location is named alone as  in ('one end"); determining the meaning of groups of 
words whose meaning in combination is more than a combination of tkeir individual 
meanings; determining the meanings of modifiers of nouns and verbs and saving the 
meanings so that they can be effective a t  the proper place in the processing; determining 
whether an  object or location mentioned in a sentence is a new one, or whether it refers 
to one mentioned previously; adding objects and relations to the world model, and 
updating existing ones to reflect new information; expanding the model of a11 object so 
that its subparts may be referenced; testsing n modifier to determine whether it can 
reasonably 111odify a given phrase (which may require reasoning based on the 
particulars of the world nlodel); interpreting all object of a given type as a11 obdect of a 
desired type (for exa~nple, interpreting an object as a locnt.ion or vice versa), All of these 
processes will be discussed in this chapter, 
4.2 Preliminary Modifier Processing 
Adjective and adverb modifiers of  noun and verb phrases frequentlv have 
their effects a t  a relatively late stage of semantic processing: the idulltification of the 
referent of a noun phrase, or the execution of verb semantics. These modifiers must 
therefore be saved for later reference. In  some cases, a semantic routine will be 
associated with the modifier itself; ill other cases. it is more convenient for a larger 
routine to look for the existence of certain modifiers to guide its processing. Preliminary 
modifier processing puts modifiers of certain classes into a standard form so that they 
will be easy to identifv or so that a single semantic routine can be used for the whole 
class. I n  some cases, different meanings for a modifier may be selected depending on the 
modified phrase. 
Adjectives such as "one", "other", "first", and "second" are put directly on 
the noun phrase token under the indicator DET2. These modifiers are referenced in 
determining the referent of the noun phrase. Adjectives such as  "heavy", "left", and 
"upper" are converted to modifiers of the form (SELECT adj); they are used in 
selecting a particular referent from several possible ones. Quaritifiers such as "each" 
become modifiers of the form (QNTFR adj). Adjectives such as "horizontal", 
"vertical", and "upward" are converted to rotation modifiers of the form (ROTN ang), 
where "ang" is the appropriate angle. 
Adjective phrases indicating measurement (as in "a 10 ft pole" or "a pole 10 
f t  long") are converted to modifiers where the measured quantity is made explicit, e.g., 
(LENGTH 10 FT). When the referent of the noun phrase is found, the modifier is 
transferred to the property list of the referent. In the case of unspecified force 
measurements, tests are made on the modlfied noun phrase to determine the rrleasured 
quantity. Thus, a 150 lb man is a man whose weight is 150 lb, while a 150 lb force is a 
force vector whose magnitude is 150 lb. 
4.3 Preposition Semantics 
Preposition semantics is an interesting area. A single preposition can have a 
number of sense-meanings (as many as seven in our set of physics problems) depending 
on the types of objects it connects. The actions required of the semantic routine are in 
general quite different for each sense-meaning; for our purposes, sense-meanings are 
differentiated by the different actions required to process them adequately. 
Discrimination net tests based on rough semantic classifications of the phrases 
connected by the preposition were found to be adequate to distinguish the preposition 
sense-meanings in our sample problems. We shall discuss in detail the semantic 
procesbing for some prepositions, auld then compare our sense-meaning classificatiol~s 
with dictionary classifications and postulate that techniques similar to ours may be 
useful fqr machine translation of prepositional phrases. 
4.3.1 Semantics of the Preposition "OF" 
The sense-meaning classifications for the prepositions were determined by 
listing the occurrences of each preposition together with the modified (or "head") 
phrase and the object phrase of each. Occurretlces which seemed to be af the same 
semantic class were grouped together, and a set of discrimination net tests was 
developed which would distinguish between preposition uses in each of the diffe~ent 
classes. Using this procedure, seven distinct sense-meanings of the preposition "OF" 
were found in our small sample of twenty physics problems-a surprisingly large 
number considering that the problems are all of a similar. type. The seven sense- 
meaning classes are listed below with examples. Although the classes were determined 
from our physics problems, it is easy to think of examples of each class which are in 
common usage and are not limited to the narrow area of physics problems. 
1. < quantifier> OF < objects> each of the ropes 
2. < measurement> OF < value> a length of 10 ft 
3. < object> OF < value> < attribute> a pole of uniform cross section 
4. < location> OF < object> the left end of the lever 
5. < attribute> OF < object> the weight of the lever 
6. < group> OF < objects> pair of legs 
7. < part> OF < object> hinges of a door 
The semantic classes for the head and object phrases are given for each 
sense-meaning in the left-hand column; the discrimination net at the beginning of a 
preposition semantic routine uses tests for these semantic classes to determine the 
proper sense-meaning for a given use of the preposition. Once the proper sense-meaning 
has been determined, the processing required is fairly simple. For sense-meaning 1 of 
"OF", <quantifier> OF < objects>, the quantifier token is replaced by the object 
token, and the quaritifier is made a modifier of the token; thus, "each of the ropes" is 
put into the same form as "each rope". For sense-meaning 4, <location> OF 
< object> , the SFRAME (Semantic Frame) of the head is set to LOCPART, and the 
referent of the object phrase is put on the head token ynder the indicator SEMOBJ 
(Semantic Object). [The process of referent identification is discussed in a later section.] 
In cases such as  this one, the determination of the prepositsion sense-meaning also serves 
to determine the proper sehlantic frame for the head phrase. The prepositional phrase 
itself serves to supply one of the nrglimehts of the semantic frame. Just ns parsing makes 
explicit the syntactic relations which hold among the words in a sentence, the reduction 
of phrases to their semantic frame form makes explicit the semantic relations which 
hold among the objects referred to '(explicitly or implicitly) by the phrases. The semantic 
frames constitute a set of standard forms into which phrases representing similar 
meanings are translated; thus, nulnerous different ways of expressing the same 
meaning can all be translated into an  identical semantic frame form. 
In the case of senge-n~eaning 7, < part> OF < object> , a special semantic 
routine may be calledinto play to define the parts and their relation to the object they 
are part of. In  our example, "the hinges of a door" (P9), the correct formulation of the 
problem requiresbthe use of world knowledge that'a door has two hinges (if the number 
is unspecified) which are arranged vertically and attached to the door on one side. This 
pragmatic knowledge is contained in a semantic routine for defining parts of doors. By 
representing the knowledge in this way, it is possible to refer to the parts of a complex 
object if necessary without expanding the i n t e~na l  model of the object into its parts if 
they are not referenced. 
In ,our sample problems, there was'only one case where a prepositional 
phrase modified a conjoined noun phrase: "magnitude, direction, and point of 
application of the equilibrant" (PI3 and P15). In this instance, the prepositional phrase 
"of the equilibrant" should be assumed to modify each of the three conjoined phrases; 
this is handled within the semantic routine for "OF". I t  would be desirable to handle 
such cases at a higher level and thus in a more general fashion. More research is needed 
to  find rules to govern the interpretation of prepositional phrases which modify 
compound phrases. 
4.3.2 Semantics of Other Prepositions 
In this section, we will briefly describe the sense meaning classifications and 
semantic processing for the remaining prepositions. In each case, of course, there are 
some sense-meanings of the preposition which are not handled by the program; we 
discuss only those which are. 
BY is used only to specify the agent of the verb in a passive verb phrase. The 
object of the preposition is put on the verb token under the indicator SUBJ. 
AGAINST is used to specify a case argument for a verb, as in "rests against a 
vertical wall" (P8). The referent of the object phrase is identified, and the preposition 
atld referent are put on the verb token as  a modifier under the indicator CASEARG. 
CASEARG modifiers are processed by the verb semantic routines, which may have 
specific interpretations for case arguments illdicated by certain prepositions. 
TO with a location object is used to specify a location for a verb phrase. The 
location referent is identified, and the preposition and refhent are used as a-modilier 
under the indicator LOC. Since lnodifiers are kept as "a list under the property list 
indicator MODS, there can be multiple LOC modifiers. The preposition is kept in case 
the verb semantic routine can derive additional information from it; usually, however, 
only the location referent will be used. 
Proposed LOC modifiers are tested against the head phrase to determine 
whether the modification is acceptable; this is done by a function called LOCTSI'. If the 
head is a verb phrase, the verb is tested to see whether it can properly take a location 
modifier. For example, in the sentence "There is a man weighing 150 ib a t  one end", the 
LOC modifier "at one end" would be rejected as a modifier of "weighing", while in the 
sentence "There is a man standing a t  one end" the LOC modifier would be accepted as 
a modifier of "standing". If the modified phrase is a noun phrase, the object referred to 
(explicitly or implicitly) by the location modifier is tested against the head object; if they 
are the same, the modification is rejected. Thus, in the sentence "one- 
painter . . . stands on the scaffold 4.0 ft from one end" (P3), the location modifier "4.0 
f t  from one end" is rejected as a modifier of "scaffold", since its implicit object referent 
is the scaffold. This rejection on semantic grdunds (making reference to the 
relationships among objects in the model of the problem which has been constructed,so 
far) will cause the parsing in which the prepositional phrase modifies "scaffold" ta be 
rejected, so that the prepositiopal phrase will eventually be interpreted as a LOC 
modifier d the verb "stands". In the case "a boy 3 ft from one end" (PT), the location 
modifier is accepted since different objects are referenced by the head and object 
phrases. 
FROM (without a measurement phrase preceding it) modifies a verb as a 
CASEARG, as  in "supported from the wall" (P8), or a LOC, as in "From end ( A )  a 
weight of 2500 nt is hung" (P15). FROM2 (preceded by a measurement phrase) always 
specifies a LOC; the measureme~lt phrase may be a question phrase, a8 in "how far from 
the center" (P20). If the object of FROM2 specifies a physob rather than a location on a 
RELPOBJ (an object on which relative positions are defined), a a  appropriate object for 
the location to be on must be found. This is done by finding an attachment point 
between the specified object and a RELPOBJ; thus, "0.5 m from Paul" (P ly)  specifies a 
location on the pole Paul is carrying which is 0.5 m from the point of attachment 
between Paul and the pole. The semantic routine for FROM2 must interpret the given 
object (a physob) as  a n  object of the desired type (a location on a different physob of a 
particular type), 
PETWEEN occurs only once in our problems: "on a pole between them" 
(P17). When it connects a single physob and two physobs, as  in this case, BETWEEN is 
interpreted to mean that the first object is attached to  (.he other two a t  the "usual" 
places for the object (in this case, the ends of the pole). 
A T  always specifies a lo~at ion,  which may be a question phrase, as in "at 
what point" (P7). 
IN specifies either a location, as  in "stand in the center", or an attribute of 
an object, as in "the tension in each rope" (P5).  In the latter case, the SFRAME of the 
head noun phrase is set to ATTROF and its SEMOBJ is set to the referent of the object 
noun phrase. The same semantics are used for sense-meaning 5 of OF, < attribute> OF 
< object> , and for one sense-meaning of ON. 
WITH may be used to connect a n  object with an attribute and value, as in ' 'a 
spring with a constant of 40 Iblft" (PI), or to connect a second participant in a 
relationship with the relationship, as  in "an angle of 60 deg with the horizontal" (P4). 
The latter sense-meaning is frequently used in English to define the participants in a 
relationship, usually using the verbs "have" and "make". 
There are five sense-meanings of ON which are recognized by the program: 
1. < physob> on < loc> the rope on the left end (P4) 
2. < attribute> on < physob> the tension on each of the ropes (P3) 
3. < action> on < physob> the forces on the supports (P6) 
4. < verb> on < physob> stands on the scaffold (P3) 
5. < verb> on < loc> placed on the edge of a block (P14) 
Sense-meanings 1 and 5 are processed as LOC modifiers; meaning 2 is 
converted to an ATTROF SFRAME; nleaning 4 is converted to a CASEARG modifier. 
Meaning 3 is converted to the SFRAME ACTON, with the referent of the object noun 
phrase as  its SEMOBJ. 
4.3.3 Definition and Translation of Prepositions 
Out of curiosity, the sense-meaning classificatior~s for the preposition OF 
(which had the most sense-meanings of any in the program) were checked against the 
definitions given for OF in several dictionaries. The agreement with the dictionary 
definitions was very poor. Often, several of our classes would fit in a single dictionary 
class, or one of our classes would fit in several dictionary classes. Prepositions are of 
course hard to define, and native speakers of a language rarely need to look them up in 
a dictionary. However, in translating from one natural language to another (whether 
done by a human or by a machine), the correct translation of prepositional phrases is a 
difficult problem. For example, the preposition OF can be translated into about a dozen 
different prepositions in German; some uses of OF are translated into the genitive case 
or other constructions which do not use prepositions. It seems plausible that 
discrimination nets similar to those used in our preposition semantic routines might be 
used to discriminate preposition sense-meanings for machine translation. Hopefully, 
sense-meaning classes could be found such that all usages of a preposition which fall 
within each class could be acceptably translated into the same form in the target 
language. 
4.4 Referent Identification 
Referent Identification is the process of associating the phrases in a sentence 
with the objects and relationships they refer to (explicitly or implicitly) ih the reader's 
model of the world. Such a process involves a number of possible steps. Candidate 
referents must be found. In  some cases the candidates will be identified by the same 
word used in the sentence, or will be members of the same class which can be matched 
together (e.g., "Paul ' and "boy", both of which are members of the class PERSON with 
the restriction (SEX MALE)). In other cases, the phrase in the sentence identifies the 
candidates implicitly by identifying their relationships or attributes. (For example, in 
(P17) the word "load" refers to a sack which is being carried on a pole.) In such a case, 
the candidate can be considwed a n  instance of the phrase in the sentence in its 
particular instantiation, but not in general. If there are no candidates (or if there are 
not enough), a referent must be created and added to the model. If there are several 
candidates, it may be necessary to select a particular one, either arblitrariiy or based on 
modifiers of the phrase in the sentence. If modifiers are used, problem solving may be 
required to determine which of the candidates satisfies the modifiers. Once the 
referent(s) of the phrase have been identified, modifiers of the phrase must be processed 
to  add information t o  the referent as appropriate. 
ISAAC contains programs to identify three types of referents: Physical 
entities (objects and non-material physical entities such a s  forces), locations, and 
attschments. These referent identification programs are described below. 
4.4.1 Identifying Physical Entity Referents 
Physical entity referents are identified by the function IDRFNT. Sf the 
refe~ent  was previously identified, it is retrieved from the noun phrase token's property 
list. Okherwise, the referent is identified using the function PHYSNP and put on thg 
tok~n's  property list under the indicator RFNT. (The "referent" is a list of pointers to 
each of the objects or relations denoted by the noun phqase.) If the noun phrase& 
compound, the referent of each component noun phrase is determined, and the 
concatenation of all the referents is used as  the referent of the compound. 
A flowchart of PHYSNP is shown in Figure 4.1. The first step in identifying 


the referent is to find the existing objects in the world model to which the  noun phrase 
might refer. (If the dcternliner is indefiilito, it is assumed that a new object is bring 
referred to, and this step is bypassed.) The list of esisting object& is sea~ched first for  
objects with the satne token word ns the noun phrtlse. ant1 then for ot~j,jr~lts \vhosr token 
words are synonyms of the token word of  the noun phrase. I f  no cnndid~tvs are foutld by 
either of these searches, n semantic routine associated with the nourl phrase token word 
is executed (if available) to see if there is a suitablereferent for that \yard in  the tncldr.1. 
Such a semantic routine allows the noun phrltse "the load" in (PIS) to be mntched to 
the object whose toke11 word is "snck" The referent semantic r o u t i ~ ~ e  for "load" selects 
an object which is a physical entity, is not R person, is supported by something, and c to~s  
not support anything itself. The  semantic routine for "support" selects the appropriate 
number of  objects which all support the same objwt. If candidate objects are found by 
any of these searches, they are subjected to further testing beg i~~r~ ing  at the floivchart 
label (B) (page 2 of Figure 4.1). 
If no candidate objects are found, or if all candidates are rejected on 
semaatic grounds, new referent objects must be created. The number of objects to be 
created is set equal to the QTY (quantity) attribute of the noun phrase if specified (as in 
"two boys" (P20)), to two if the noun phrase is plural and not compound, to the number 
of locations if there is a locatiorl modifier (as  in "a pier at each end" (P13)), or to one 
otherwise. The proper number of objects is then created using the function MAKENT. 
In most cases, MAKENT simply creates a GENSYM atom, sets its token 
word appropriately, and adds it to the libt of created objects. Provisio~~ is made, 
however, for special semantic routines to  create referents for particular words. A 
seesaw, for example, is not a single object, btit E\ rigid plank pivoted at  its center. The 
semantic routine to make a referent for "seesaw" creates both objects and specifies their 
attachment. Similarly, an equilibrant is a force which is applied to a rigid body to 
produce equilibrium. The semantic routine to create a referent for "equilibrant" creates 
a force, finds a n  appropriate rigid body, and specifies the attachment of the force to the 
rigid body at an unknown position; 
When the refererits of the ,noun phrase have finally been determined or 
created, the function DOMOUS is called to execute the nlodifier semantics for each of 
the modifiers which remain on the noun phrase token. Modifier semantics is discussed 
in a later section. 
The second page of Figure 4.1 shows the tests which are performed on 
candidate referents for a noun phrase in order to reject those candidates which are 
clearly inappropriate on semantic grounds and to select the proper candidate(s) from 
those which remain. First, each candidate is subjected to RSTRTEST (restriction test) 
and NAMETEST. RSTRTEST requires that if the candidate and the noun phrase have 
RESTRKT modifiers with the same indicator, the restriction values must be equal. 
Thus, " ~ a u i "  and "boy", both of which have thefmodifier (RESTRICT (SEX MALE)), 
would match, while "Paul" and "girl" would not. NAMETEST requires that if both 
the candidate and the noun phrase token have names, the names must match. 
After any candidates which fail RSTRTEST or NAMETEST have been 
removed, thearemailling candidates ace examined to see if they constitute the proper 
number of referents. If there is  onry one candidate, if the quantifier "each" is present, if 
the number of candidates matches the QTY (quantity) of the noun phrase, or if the noun 
phrase is plural and there are two candidates, then the existing set of candidates is 
accepted without further tests. If a determiner adjective is present, the corresponaing 
candidate is picked: the first for "one" or "first", or the second for "other" or "sepond". 
Otherwise, the candidates are tested against modifiers of the noun phrase. If a 
candidate is found which has a matching modifier (e.g., both have the modifier 
(WEIGHT 125 LB)), that candidate is selected. If a candidate has a rqismatching 
modifier (e.g., (WEIGHT 150 LB)), that candidate is removed from the list of 
possibilities. Some modifiers, such as location modifiers, may have special semantic 
routines fbr selecting candidates. A candidate is selected by the location semantic 
routine Bif the location referent of the location modifier is a member of one of the 
attachment relations of the candidate. Thus, "the rope on the left end" (P4) will select 
the rope which is attached to the left Bnd of the bar. If multiple candidates remain after 
all the modifiers have been tested, the first one is selected arbitrarily. 
Inl some cases, the number of referents created for a noun phrase is not 
enough when the context of the noun phrase is considered; in such cases, the function 
MORERFN? may be called to create additional referents. For example, "the pier a t  
each end of the bridge" (P18) will cmse two "pier" objects to be created because of the 
two locations in the location modifier generated by the prepositional phrases. However, 
in "a plank . . . . supported at  each end by a stepladder" (P19), the locatian modifier is 
attached to the verb phrase, so that initially only a single "stepladder" referent is 
created. The verb semantics for SUPPORT, however, requlres a separate supporting 
object for each specified location, so that MORERFNT will be called to make a second 
"stepladder" referent. 
4.4.2 Identifying Location Referents 
There are two primary functions involved in the identification of location 
referents, IDLOC and LOCNP. IDLOC identifies a location given the object to which the 
location is relative, the location name, a n  optional SELECT modifier, and an optional 
list of location frames to be excluded from the selection process. For example, the 
phrase "the left end of the lever" would result in a call to IDLOC with the referent 
object for "the lever", the location name "END'', the SELECT modifier "LEFT", and 
a null exclusio~l list as~arguments.  IDLOC is used both by iilternnl pimcesses R I I ~  by 
LOCNP* 
LOCNP identifies the locqtion(s) referred to by a noun phrase. $' 1 1 1 ~  a 
locatioll may be specified by a wide variety of syntactic forms, LOCNP lnust identify the 
form of the t ~ a u n  phrase and the features of the lor~t io l l  which arq specifietl. These 
features a re  collected, and missing features a re  filled ill by inaking inferences; finally, 
IDLOC is called to identify the location referents. 'I'hus. LOCNP serves as an  interface 
function to collect the nrguments for IDLOC tltld put tlletll into a standard form. 
IDLOC and LOCNP are described in detail \)elow. 
A flowchart of IDLOC is shown in Figure 4.2. IDLOC first examines all the 
existing locations on the specified object to see if one of them is suitable. An existing 
location is rejected if it is a member of the excluded locations list, if it has the wrong 
location name, or if it has a relative positio~l (displacement) from the named position. If 
the location passes these tests, it is examined for the specified SELECT value. In most 
cases, the SELECT semantics consists of a test for a n  identical SELECT modifier (e.g., 
RIGHT or LEFT). In some cases, however, a special semantic routine must be used to 
test the world model and determine whether a location meets the selection criterion. T o  
find "the heavy end" (P12), for example, it is necessary to esamine the object frame for 
the object involved; the "heavy" end is the one which is closest to the center of gravity of 
the object. Which end is the "heavy" one could be changed by changing the numeric 
value of either the length of the bar or the distance from one end of the center of gravity, 
while leaving all the English words the same. Thus, numerical problem solving by a 
specialist program, based on the particular values specified for certain parameters, is 
required to  determine the proper location referent. 
If no SELECT parameter is specified to IDLOC, or if the object being- 
examined has  no SELECT modifier, the object is saved as  a second choice in case a 
better candidate is not found. Thus, if a SELECT value of LEFT is specifitxi, a l l  the 
locations on the object with the proper location name (e.g., END) will be examined for a 
SELECT LEFT modifier. If none is found, a location with no SELECT modifier will be 
chosen; when the modifiers of the noun phrase are processed, the select value will be 
added to that  location frame. 
In addition to its use by LOCNP, IDLOC is used internally by semantic 
routines to identify particular locations on objects. For example, when a referent object 
for "seesaw" is created, IDLOC is called to create a location frame for the center of the 
newly created seesaw plank; this location is then used in specifying the at tachme~lt  of 
the plank to the pivot which is created. 
LOCNP identifies the referent(s) of a location noun phrase; such a location 

may be denoted in many different ways. If the location has  a name, the name alone may 
be used (as in "80 cm from (A)" (PG)); the ol~ject o which the location is relative lnhy or 
may not be named ("the left end of the lever" or simply "the left end"); a physicnl 
object name may be used to specify n location, since every physical object occupies a 
position in space.Most of the function LOCNP co~lsists of code to make the 'inferet~ces 
and collect the argutnents.needed t o  identify a location when the location is dci~oted by 
any of the noun phrase forms mentioned above. 
A flowchart of 1,OCNP is shown in Figure 4.3. If the referent of the noun 
phrase is known, it is returned a t  once. Otherwise, a series of tests is made to determine 
the type of location noun phrase. If n location is specified by name, the existing location 
frames are  searched for a location with tha t  ~-rame. When the correct location is found, it 
is saved on the noun phrase token under the indicator KFNT, and the function 
DOMODS is called to process any modifiers of the noun phrase. If the noun phrase is 
already marked as being a LOCPART SFRAME, the object to which the location is 
relative is already known; this will be the case if a modifier of the location noun phrase 
specifies the object, as  in "the end of the lever" or "its left end". In such cases, LOCNP 
transfers directly to the label "B" (page 2 of Figure 4.3). If a location is named without 
a n  object (as  in "one end"), it is necessary to find a n  appropriate object. This is done by 
examining the GEOMODEL (geometric model) of each object in the model of the 
problem until an object for which the location name is appropriate has been found. 
Once the appropriate object for the location has been inferred, the noun phrase token is 
converted to a LOCPART SFRAME, and control is transferred to label "B". If tfie 
noun phrase names a physical object or person, IDRFNT is called to identify the 
physical object referent. If the object to which the location is relative is specified in the 
call to  LOCNP and is different from the object named by the noun phrase, a search is 
made for a location at  which the named object is attached to the desired object; thus, in 
"0.5 m from Paul" (P17), which specifies a location on a pole which Paul is carrying, 
"Paul" is interpreted as a location on the pole by finding the point on the pole where 
Paul  is attached to it. If the  desired object is unspecified, a location is made for the 
default lacation of the  named object. 
At label "B" of the flowchart, where LOCPART SFRAMEs are processed, a 
test is made ?0 see if the noun phrase is plural or modified by the quantifier EACH, a s  in 
"its ends" or "each end". If sa. the number of such locations is gotten from the 
GEOMODEL of the object, and that number of locations is identified by calls to 
IDLOC. Thus, "wch end" (P3), referring to a scaffold, will cause two "end" location 
frames to  be generated. If the noun phrase is singular, IDLOC is called to identify a 
single location referent. If a location name is specified, the location found is required to  
pass NAMETEST, having either the correct name or no name. Once the proper referent 

P HD Is a LOCPART SFWIE 
HD plural  Get  t h e  number of c h i 3  
tvpe of l o c a t ~ o n  for 
chis object 
IDLOC 
I d e n t i f y  locat ion  
referent 
Ident~fv proper 
number o f  locations 
Figure 4.3 (page 2)  
has been found, control is passed to the label "H" to save the referent and process 
modifers of the noun phrase. 
4.4.3 Attachment Identification 
An attachment relationship among two or more objects is identified by the 
function IDATT. Attachment relations are not the direct referents of phrases in a 
sentence, but are defined by verb semantic routines or modifier semantic routines. The 
argument of IDATT is a paired list of objects and locations on the objects; one member 
of each pair may be nil. IDATT identifies an attachment frame which specifies the 
attachment of all the objects in the list; if no such attachment frame exists, one is 
created, along with links between it and the objects involved. (The structure of 
attachments and other frames is described in Appendix B.) If an existing attachment 
which matches the 1is t . i~ found and the list contains locations which were previously 
unspecified, the locations are put into the existing attachment frame. Thus, in cases 
such as 
A painter . . stands on a plank . . . 
If he stands 1.0 m from one end of ?he plank . . . (P19), 
the second attachment will be identified with the earlier one and will cause the location 
on  the plank to be added to the attachment frame. The order i~ which the 
objectllocation pairs are specified in the call to IDATT is unimportant. 
A second parameter in the  call to IDATT is the type of attachment: 
CONTACT (as in the above example) or PINJOINT. The type of attachment is not used 
by IDATT, but is saved with the attachment frame for later use. The interaction of 
objects a t  an attachment point may depend on the type of attachment. A CONTACT 
attachment with a "smooth" surface, for example, implies that the force exerted by the 
surface is nonnegative and perpendicular to the surface. A PINJOINT att,achment may 
transmit a force in any direction, but may not transmit a torque. Although other types of 
attachments could be used, CONTACT and PINJOINT are the only ones used by the 
program in its present form. 
4.5 Modifier Semantics 
Modifiers of noun phrases are savedi after some preliminary processing 
(Section 4.2), on the property list of the noun phrase token under the indicator MODS. 
After the referent of the noun phrase has been determined, the semantic routines. of 
these saved modifiers are executed so that  the appropriate changes may be made to the 
referent of the noun phrase. (Some modifiers, which are used in selecting the proper. 
referent, are deleted before this stage is reached.) 
Modifier semantic processing is controlled by the driver function DOMODS, 
which calls PUTMODR for each modifier.. PUTMODR (which is also used for modifier 
processing by some verb semantic routines) transfers the modifier to the property list of 
each referent, or executes a special semantic routihe if there is one associated with the 
modifier. Thus, in simple cases such as "a 150 lb man", the modifier (WEIGHT 150 
LB) generated from the adjective phrase is transferred to the referent's property list as 
the value (150 LB) under the indicator WEIGHT. In other cases, semantic routines may 
make inferences from modifiers, e.g., that a n  object which is at a location on another 
object is attached to the other object at that location. 
RESTRICT modifiers are cotlcatenntcd and y laced on the referent object 
under the indicator RESTRICT; this allows an object to have multiple RESTRICT 
modifiers, which are used in determining 110~11 phrase referents. 
Measurement modifiers are transferred directly to the property list of the 
referent. In  the process, the measurement units for each type 6f measurement are saved 
for use in answer generation. I t  would be easy to modify the measurement modifier 
semantic routine to allow differing units (e.g., feet and meters) to be used in the same 
protilem. 
NAME modifiers are processed in different ways depending on the type of 
name and the type of object which is named. Simple names are transferred directly to 
the property list of the named object. Geometric names which modify locations are 
distributed to the named locations. I-f geometric names are assigned to a physical object, 
as in "a uniform bar (A  B)" (P6), location referents are created for the appropriate 
locations on the object (in this case the ends of the bar) as determined by the object's 
GEOMODEL, and the geometric names are assigned t o  the location referents. 
An APART modifier gives the distance between twb' locations, as in "the 
hinges of a door . . . are 12 ft apart" (P9). This modifier not only gives the distance 
between the two locations, but also implicitly determines the size of the object if the two 
locations are on the same object. In the above case, for example, we can infer that the 
door is at least 12 f t  tall. The semantic routine for APART modifiers consults the 
GEOMODEL of the object, calculates the overall size dimension which would give the 
specified distance between the two points, and assigns that size to the object. 
In our set of physics problems, a location modifier of a noun phrase always 
implies that  the referent object is attached to something a t  that location, as in "an 
automobile . . . which, is 30.0 ft from one end of the bridge" (P18). The modifier 
semantics routine for location modifiers calls IDATT to define the attachment. In  a 
larger system which handled a wider range 6f problems, some additional semantic tests 
would be needed to determine whether an attachment was actually implied by the 
location madifier. 
4.6 Verb Semantics 
The semantic functions performed by verbs are very diverse. Some verbs (for 
example, certain sense-meanings oE the verbs "is'', "have", and "make") serve only as 
function words which c o n ~ ~ e c t  o her phrases; the semantics of such verbs resides 
primarily in the phrases they connect. Other verbs (e.g., "need" or "wish") intrdduce 
verb phrases to which they pass some of their case arguments. Some verbs carry case 
arguments and other inferences to be used with their "underlying*' verbs; for e x m p k ,  
"stand on . . ." specifies an attachment by contact between the feet of the subject add 
the object of "on", with the subject in a standing position. A single verb may have 
multiple sense-meanings; as  in the case of prepositions, we found that discrilnit~atio~l 
net tests based on rough semantic classifications 61 the case arguments of the verb were 
sufficient to differentiate the sense-meanings. 
In this section, we will describe the semantic functions for a number of verbs 
as  they are implemented in the program. In the cases where a verb appeared 
infrequently in the s a m ~ l e  problems, the verb semantic routines handle only the limited 
sense-meanings necessary for those cases; often, there are not many error checks to keep 
the program from going astray if it were presented with different cases. Some of the verb 
semantic routines handle a number of variations in the types of their case arguments; it 
seems likely that general rules for handling different types of arguments which would 
be applicable to classes of similar verbs might be found. This would be an interesting 
area for further research. 
The execution of a verb semantic routine is initiated by EXVBSEM, which is 
called when a clause or dependent clause has been parsed. 'EXVBSEM executes the 
semantic routines for any prepositional phrases or adverbs which modify the verbi It 
then binds some of the case arguments of the verb (and their referents) to global 
variables so that they will be easily accessible, and calls the semantic function 
associated with the main verb of the verb phrase. 
4.6.1 Semantics of the Verb "BE" 
There are seven sense-meanings of the verb "BE" which are recognized by 
the program; the sense-meaning classes are listed with examples below. 
1. THERE BE < physob> < l o o  At @)...there is a weight (P15) 
2. < physob> BE < loc> a man is 10 ft from the top (P8) 
3. < physob> BE < adj  phrase> the door is 3 ft wide (P9) 
4. c attrof> BE < measurement> the weight of the lever is 8 lb (PI)  
5. < attrof> BE WHAT what is the weight of the bar (P4) 
6. < locpart> BE < lot> its center of gravity is 6.0 ft from one end (PI 1 ) 
7. < subj> BE TO < verb phrase> the bar is to be supported ...( P6) 
These sense-meanings are easily separated by a set of discrimination net 
tests, most of the sernantic classes being tested a t  this point are SFRAME types, so that 
any of the syntactic forms which result in the creation of a particular SFRAME will be 
accepted. Once the sense-meanings have been separated into these classifications, we 
find happily that most of the semantics has already been done: it is only necessary to 
pass the arguments of the ver,b to routines which were written to do the same semantics 
for different syntactic forms. Sense-meaning 1 is changed to the same form ns 2; IDATT 
is called for both cases to define an attachment of the object a t  the location specified. 
For sense-meanings 3 and 4, PUTMODR is calleil to esecute'the semantics of the 
modifier for the referent of the object involved. For sense-meaning 6, the argume~lt is 
converted to arguments for the question routine WHATIS; WHATIS is expiained in q 
later section. For sense-meaning 6, the location is saved on the property list of the object 
referent using the location name as the indicator. For sense-meaning 7, the function 
SUBSTINF is called to substitute the subject of the verb as the syntactic subject of the 
infinitive verb phrase and execute its verb semantics. Thus, in "the bar is to be 
supported" (P6), the subject "the bar" is substituted as  the syntactic subject of the 
passive verb phrase, so that the referent of "the bar" becomes the semantic object of the 
verb "support". 
4.6.2 Semantics of the Verb "SUPPORT" 
Six sense-meaning classes of the verb "SUPPORT" are recognized by the 
program; these are listed with examples below. 
1. < physob> SUPPORT < physob> the lever is supported by a spring (PI) 
2. < physob> SUPPORT < N the boy ... supports '6 as much as the man (P2: 
times > AS MUCH AS < physobs 
3. < physob> SUPPORT WHAT what load does each pier support (P13) 
c force> 
4. < nil> SUPPORT < physob> a beam ... is supported dt both ends (PIG) 
5. c physob> SUPPORT < locpart> the top of the ladder is supported from the wall by 
a horizontal rope (P8) 
6. < physob> SUPPORT < a t t r o b  the weight of the door is supported by the upper 
hinge (P9) 
It might be argued that these are not distinct sense meanings, but rabher six 
different ways of specifyiflg the arguments for a single sense-meaning. Essentially, the 
verb SUPPORT (for our purposes) specifies an  attachment of two objects at  a particulan 
location on each object; a force is exerted on one object by the other object in order to 
support it. For sense-meaning classes 1,4, and 5, the arguments of the verb are arranged 
to serve a s  arguments for IDATT so that the attachment relation may be specified. (In 
the case of sense-meaning 4, a pivot object is created to serve as  the unnamed supporting 
object.) In  the remaining sense-meaning classes (2. 3, and 6), the force exerted in the 
attachment relation is referenced. Such a force is identified by the function IDFORCE, 
which creates variables for the force vector and adds them to the attachmefit relation if 
necess-ary. for sense-meaning 2, < physob> SUPPORrr < N times> AS MUCH A S  
< physob> , equations are written which relate the two force vectors so that one is N 
times as much as  the other. For sense-meaning 6, < physob> SUPPORT < attrof> , an 
equation is written equating the force and the specified force attribute. For sense- 
meaning 3, < physob> SUPPORT WHAT < force> , the force vector variables are 
marked as  desired unknowns, and an entry is made to use the force vector values as  a 
reply. (The latter opera t io~~s  are discussed in more detail in the section on question 
semantics.) 
4.6.3 Semantics of Other Verbs 
Verbs such a s  WEIGH and STRETCH express attributes in verbal form. 
T h e  semantic routines for these verbs call the function ATTRVBSEM with the 
appropriate case argument of the verb (subject for WEIGH, object for STRETCH) 
specified as  the object which is modified. ATTRVBSEM uses the attribute associated 
with the verb to make a modifier, whose semantics are executed by PUTMODR. ( In  the 
case of a question, the case argument and attribute are used as parameters for the 
function WHATIS.) Thus, a semantic transformation is used to transform the verbal 
form into a modifier form for which the semantics already exists. The forms "a man 
weighs 150 lb", "a 150 lb man", and "the weight of a man is 150 lb" are all reduced to 
an identical "semantic deep structure", which cotlsists of the referent object for "a 
man" and the modifier (WEIGHT 150 LB), by the time the semantics of the modifier 
are to be executed. A single modifier semantic routine performs the final semantic 
operations for all three cases. 
In addition to the verb SUPPORT, the verbs REST, PIN, BALANCE, SIT, 
HANG, CARRY, ATTACH, STAND, LIFT, and EXERT can all be used to specify 
attachment relations. S IT  and STAND imply that particular locations on the person 
who is sitting or standing are involved in the attachment, and that the attachment is of 
type CONTACT. (These verbs could also determine the person's posture for the picture- 
making programs, but that  is not done in the present system.) A number of the verbs 
imply that one of the objects iil the attachment relation supports the other. These 
support relations are marked by SUPPORT and SUPPORTBY links among the objects; 
they are used in later inferences, such as  inferring whether a person shoul'd be modeled 
as a pivot or a s  a weight by the problem solver. The verb PIN implies (as  used in these 
problems) a pivot object which must be created as the other object for the attachment 
relation. CARRY, if used with an instrument, implies that  the subject, is attached to the 
instrument and that  the object i5 attached to and. support etl hy the instrument, as in 
"Paul and Henry carry a sack . , on pole between them" (P17). 
The verbs WISH NEI':D. w~ul REQCIIIIE nre used in the sample prohlems 
with infinitive verb phrase objects, as ill "two boys . . . wish to btalance on n seesaw" 
(P20). For our purposes, the "modal" il~formatioil provided by these verbs can  be 
ignored. The  verb seloanti6 routines far these verbs call the function SUHSTINF to 
substitute the appropllinte argument as the syntactic subject of the infinitive verb phrase 
and execute its verb se~nnntics. The  above example is processed as if it were simply "two 
boys balance on a seesaw". 
HAVE appears with only one sense-mennit~g, < physob> HAVE 
< locpart> < loc> as in "a bar . . . has its center of gravity 1.5 m from the heavy 
end" (P4). The  location is put on the property list of the subject referent using the 
LOCPART name as  the indicator This sense-meaning is similar to sense-meaning (i of 
the verb BE, < locpart> BE < loc> , escept that  the arguments are in a different order. 
MAKE is used with a relation name a s  an object, as  in "the rope . . . makes 
a n  angle of 45 deg with the horizontal" (P4). In such cases, the semantics is determined 
primarily by the relation involved (in this case, "angle"). The verb semantic routine for 
MAKE calls the semantic routine for the relation, passing to it the arguments of the 
verb. The semantic routine for "angle" creates a relative rotation modifier and attaches 
it to  the former subject referent. The ambiguity of the direction of rotation is maintained 
by the relative rotation modifier; later,, absolute rotations are chosen (based on 
symmetry considerations) to provide a plausible interpretation of the problem. 
FIND, CALCULATE, COMPUTE, and DETERMINE are &ll handled by 
a common semantic routine. If the object of the verb is an ATTROF SFRAME. as in 
"find the tension in each rope" (P5), the object and attribute are used as argumrlts  for 
the question routine WHATIS. If the object of the verb is an ACTON SFRAME, as in 
"compute the forces on the supports" (P6),  thp desired force is identified using 
IDFOHCE. The force variables are marked as  desired unknowns, and an entry is made 
to print the value of the force as  a reply. 
4.7 Question Semantics 
A question of the type found in our physics problems specifies two t-ypes of 
information: a set of variables whose values rnust be found in order to answer the 
question, and the manner in which the information provided b y t h e  variablesois to be 
presented in the answer. For example, the sentence "T>etermine the magnitaide, 
direction, and point of application of the equilibrant" (P15) identifies the two variables 
in the equilibrant's force vector and the distance variable in the equilibrant's 
attachment relation as "desired unknowns", or variables whose values are required to  
generate the answer. In a(lditio11, the sentence specifies that the inagnitude anci 
-* 
r m  
3 
C 
; 
3 
hJ; 
%I 
cj 
'I: 
cF 
- 
a, 
a 
z 
Q, 
s 
t, 
c. 
-CI 
5r, + 
C, 
Q, 
-- 
% 
L, 
;3r 
a 
C 
*k 
", 
w 
s 
G 
C + 
m 
i 
a 
- 4 2  
s 
- r. 
h V
$2 
A 
c.1 
.u 
3 
II) 
a 
5 
-+ 
4 2  
3 
0 
& 
E= 
0 
I CI 
* 
E 
0) 
E: 
a 
M 
5. Construction of Object Frames and the Geometric Model 
5.1 Introductiox~ 
In reading the English problem statement of a physics problem, ISAAC 
builds an internalmodel of the problem in which most of the objects nnd re la t i~ t l sh ip~  
in the problenl are ~qepresented. A n ~ i n b e r  of steps are tlecessnry to ronrtert this t ~ l o t i ~ l  
into a model for which equations describing the i ~ ~ t c r a c t i o ~ ~ s  of the objects mn be 
written. I t  is necessary to determine for each object thr. canotlical object frame which 
represents tht? object in its particular instantintion in the problan for the purpose of 
solving a physics problem. (The fr'amr representing 3. similar40bject in n different 
situation or for a different purpose might be a completely difftrent type of ct\i~onical 
object.) A person, for example, might be modeled as n weight when sitting on a pole, or 
as a pivot when carrying it. Qnce the ca11onic~L object frame has beerr selected, it is 
necessary to make appropriate assumptions to fill in information qecessary for the 
canonical frame which may not be present in the original problem statement. A 
"weight" object must have a weight, although it heed not have a geometric size, ifi the 
weight is unspecified and is not a variable, a symbolic constant is created for it. A 
"lever" object lieed not have a weight, but must have a length. 
Once the canonical object fraines Kave been selected for all the objects in the 
model, a geometric model of the problem in which the locations and orientations of the 
objects are made explicit must be constructed.,Since the sizes of some objects may be 
symbolic constants, the geometric locations for some points mby contain algebraic 
expressions. Problem solving by specialist programs (for example, solving a triangle 
given two sides and an angle) may be necessary in order to create a complete geometric 
model. 
After the geometric model of the problem has been created, the canonical 
frames for each object are completed by filling in any necessary information that 
remains unspecified. The weight of an  object, for example, is modeled as a force exerted 
on the object a t  its center of gravity. (The geornetric model is needed to determine the 
location of the center of gravity.) Attachment relations are completed by creating force 
variables for each object involved in the attachment. After all of these processes have 
been completed, the problem solver is called to write equations for the interactions of 
the objects and solve the resulting equation set. 
This chapter describes the processes of making canonical object frames, 
creating the geometric model of the problem, and completing the frames which were 
created. 
5.2 Making Canonical Object Frames 
A Canonical Object is a n  idealizatio~~ of an actual physical object which 
represents its salient characteristics for a particular physics problem. A pole, for 
example, may be represented as a weightless rigid body; this i s  an  idealization of an 
actual pole, which has a finite weight and is not perfectly rigid. The idealized canonical 
objects used in physics problems, such as weightless poles and frictioilless pulleys, 
rarely exist in the real world, but often give good approximations to the behavior of 
real-world objects. The same object may be representecl in different problems by 
different canonical object frames, depending on its relationship to other objects in each 
problem. For each object in the problem, it is necessary to decide which canonical frame 
should be used to represent it, to mark the object with the canonical frame type, and to 
fill in any information necessary for the frame which is missing. 
The function MFDRIVER calls the appropriate frame making routine for 
each physical entity in the model of the problem. Associated with each physical entity 
token word is a list of the frame-making routines which might be applicable to that- t-ype 
of object; there may be a specialist routine for a particular object (as in the case of a 
person) which decides which of several possible canonical object frames to use, or there 
may be a list of more general routines Svhich can fail if they are inappropriate for- a 
particular object in a particular context. In  the present system, only a single frame- 
making routine is needed for each physical entity token. 
The functions REQUIREVAL and REQUIREVAR examine a n  object frame 
for a specified quantity; if the quantity is unspecified, they create a symbolic constant or 
a variable, respectively, to represent the missing quantity, and add the constant or 
variable to the property list of the object frame atom. A constant or variable is a 
GENGYM atom which is added to the list of objects in the model; it has property list 
values which tell the canonical object frame it is associated with, the quantity it 
measures (e.g., TENSION), the units (e.g., LB), and whether it is a constant or variable. 
There are seven canonical object types in the present system: LEVER, 
WEIGHT, SPRING, PIVOT, ROPE, SURFACE, and FORCE. The simplest, the 
PIVOT and SURFACE frames, do not require any attributes. A WEIGHT is required 
to have a weight; if absent, a constant is generated for it. A SPRING or ROPE must 
have a TENSION (variable); a SPRING must also have a STRETCH (variable) and 
CONSTANT (constant). [The type of symbol generated for each quantity if it is 
unspecified is given in parentheses.] A SPRING or ROPE must have a LENGTH 
(constant) only if it is attached to more than one object. CKROTATION is called to 
check and disambiguate the orientation of a SPRING or ROPE, and DISAMLOCS is 
called to disambiguate locations; these functions are described below. A FORCE frame 
is required to have a11 orientation; if. absent, a n  orientat,ion of zero i s  assumed. A 
LEVER (actually, rigid body) frame is required to have a IXNGTH (consttint). If a 
width is specified (as in the case of the door in (P9)), it is used in ~nnk i~ lg  the geometric 
size vector; otherwise, n width of zero is assumeci. Unless n LEVER is oriented 
vertically, it is required to  be attached a t  more than one point; if i t  is not, a PIVOT 
object is created and attached to a point similar to the existing attachment point. Thus, 
in a problem such as  "What force is needed to lift one end of [a beam]" (PI  0): n pi\rot is 
created to hold up the ather end of the beam while one end is being lifted. IIISAMLOCS 
is called for a LEVER frame to disalnbiguate its locations. The function MFPEIISON, 
which makes a frame for a PERSON, esnmines* the contest to determine whether to 
model the PERSON ns a WEIGHT or as (1 PIVOT. If the PERSON is supported by 
something or supports somethi~lg, a WEIGHT or PIVOT model is used, respectively: 
Otherwise, the objects the person is attached to are examined to see whether they 
support something or are sup~or ted .  A person is assumed to be supported by an object 
which is supported, and to support an object which supports something. ( A  function to 
infer support relationships based on "usual" relationships and a more careful 
examination of the known relations of objects in the problem would not be too difficult, 
and would give correct answers in more general cases than the above heuristic can  
handle,) 
CKROTATION examines a n  object to see if its orientation is specified by a  
relative rotation, as  in "the rope on the left end makes an angle of 45 degrees with the 
horizontal" (P4). If so, the relative rotation is oo~~vertecl to  an absolute rotation. 1x1 
addition, the objects to which the specified object is attached are examined to see if a 
similar object is attached to one of them with a relative rotation; if so, the rotation of 
the other object is made absolute in a direction symmetrical to that  of the first object. 
This insures that if an object is hanging from two ropes, for example, the orientations of 
the ropes will be made symmetrical: 
Right Wrong 
DISAMLOCS disambiguates locations by assigning specific locations on an 
object to location frames which were originally specified by ambiguous location names. 
The ends of a bar, for example, may be specified by "one end . . . the other end". "the 
left end . . : the other end", "ends ( A )  and (B)", and so forth. These locations must be 
assigl~etl to specific locations on the object so that geometric positions can he computed. 
DISAMLOCS First assigns location names to locations which have specific SELECT 
modifiers; the appropriate SELECT motlifiess and correspontling absolute location 
llames are specified as part of the  GEOMOIIIGL of' the object.  thus,^ location with the 
name END and the modifier (SEI,ECT I,EFT) is assigned the absolute location name 
LEFTEND. After those locations which have specific SELI3CT values have been 
assigned, the remainilig locations are given unique absolute location names; thus, "the 
other end'' would be given the absolute name RlGHTENL) if it appeared with "the left 
end". Absolote location names are propagated to locatiolls relative to  named locations 
(e.g., "2 m from the right end" (P4)) by the fut~ction RENAMELOC. 
5.3 Geometric Model Construction 
After a canonical object frame has been made for an object, its geolnetric size 
and (frequently) its absolute rotation are known, and absolute location names are 
assigned to all of its locations.   his information is sufficient to construct a geometric 
model of the problem in which absolute locations (coordinates which are numeric or 
composed of expressions involving constants or variables) are assigned to each object 
and (implicitly) to all of its locations. The geometric model is two-dimensional. The 
position of an object is completely specified by three quantities: the coordinates of its 
starting poinF, its rotation relative to its standard orientation, and its geometric size. 
The GEOMODEL of the object gives the coordinates relative to the starting point f ~ r  
each named absolute location. The geometric position of a named point on the object 
can be found by taking the coordinates of the point relative to the starting point, scaling 
this vector by the geometric size, rotating it by the object's rotation, and adding the 
resulting vector to the geometric coordinates of the starting point. This process is 
illustrated in Figure 5.1. The vector V, which is the position of the point P relative to the 
starting point S in the GEOMODEL of the object, is scaled m the appropriate geometric 
size and rotated through the angle 6 to give the vector V'. Adding V' to St, the geometric 
starting point of the object in the problem, yields Pt, the coordinates of the point 
corresponding to the point P. 
Once a n  object has been added to the geometric model by specifying values 
for its GSTART, GSIZE, and ROTN (rotation), the geometric coordinates for any 
location on the object may be obtained by calling the funtion EXECLOCA with the 
location frame as an  argument. If the location specifies a position relative to a named 
location, EXECLOCA calls itself to find the position of the named locatiotl. A relative 
position vector of the appropriate size is created and added to the geometric position of 
the named point to give the position of the relative point. The direction of the relative 
position vector is taken as  the direction of a vector from the named point toward the 
center of gravity of the object; if the named point is the center of gravity, the direction of 
the rotated x-axis of the object is used. 
Construction of the geometric model is performed by the function EUCLID. 
When EUCLID is initiated, every object has a geometric size (in terms of length units, 
e.g., meters) specified under the property list indicator GSIZE. The GSIZE of each 
object is recomputed by dividing each component by the corresponding scale factor 
(stored under the indicator FRMSCL) for the GEOMODEL of the object. After this has 
been done, a relative position vector from the GEOMODEL can be multiplied by the 
object's GSIZE to yield the corresponding vector in length units. 
The geometric model is built up by repeatedli adding objects which are 
attached to objects which are already part of the model. (The first object is selected 
arbitrarily and assigned a starting point of (0 O).) In order to add the object to the 
model, its rotation must be determined. If the rotation is unspecified. the futlction 
TRITEST is called to test whether the abject is part of a triangle; if so, its rotation is 
computed by the function TRIANGLE. Otherwise, the "tlormal" rotation for the object, 
or zero, is assumed. Given the rotation and geometric size of the object, its starting point 
f 
S S '  
GEOMODEL of Object Object as it appears in problem 
Figure 5.1: Finding Relative Position on an Object 
< 
can be calculated from a point of attachment to an object which is already in the model. 
Tlle coordinates of the pomt are calculated for the object in the model, and for the new 
object assuming a starting point of zero; subtracting the latter vector from the former 
yields the starting point for the new object. This is illustrated in Figure 5.2, where the 
new object 02 is to be added to the model based on its attachment to the existing object 
01 a t  point P. The coordinates of the point P in the geometric model are computed, and 
the vector V2 is calculated by finding the coordinates of P relative to 0 2  with 52 
assumed to bB zero. Subtracting Vp from the geometric model coordinates of P gives the 
geometric coordinates of the new starting point, Se. 
After the starting point of the new object has been determined, the 
coordinates of all of its attachment points are computed and saved. Any objects to 
which it is attached which are not part of the model or on the waiting list are added to 
the waiting list. Finally, the next object from the waiting list is selected to be added to 
the geometric model. When the waiting list has been emptied, the model is complete. 
If three objects are attached to each other so that they form a triangle, it will 
generally be necessary to solve the triangle for one or more sides and angles in order to 
properly construct the geometric model. Since the triangle may be implicitly specified by 
specifying the attachments of the three objects, it is necessary to test object,s which have 
a finite size to see if they are part of a triangle; this test is performed by the function 
TRITEST. Given a n  object A, TRITEST looks for objects B and C such that.A is 
attached to B and C and B is attached to C; if such a set of objects is found, TRITEST 
returns a list of the three objects as its value. This list may then be used as  the argument 
C 1 
Figure 5.2: Calculating the Starting Point for a New Object 
4 * 
for the function TRIANG1,E. 
Given a list o f  three objects which are attached so that thev form a trinngle, 
the function TRIANGIX attempts to solve the triangle to find the unknowtl sidcs and 
angles. Since a triangle is solvnble given three sidcs, two sides and a n  angle, or a side 
and two angles, there are u number of ways in which the known data for a solvable 
triangle may be present. TRIANGLE first enumertltes the kno~\w data for the three 
objects in the order in which they are given. The  funct,ion GDIST cnlculntes the 
geometric distance bet~veen the two nttauhment points for each object. The function 
GANGLE conlputes the angle between two objects whose rotations are known. 
(GANGLE as itnplerne~lted does not 11nndle all possible riiscs, but it would be fairly 
straightforward to malte it do so.) Lists are made of  the sides and angles, and a tsanskr 
is made to the appropriate subsection based bn the types of known quantities. (Only the 
section for solvillg triangles for which two sides and a n  angle are  given is coded, but 
provision is made for the other sections.) The triangle is "normalized" by circularly 
shifting the order of the sides so that  the single known quantity (e.g., the  known angle) is 
in the first position; this makes it relatively easy to test for the remaining unknown and 
solve the .5 triangle. After all unknowns have been found, the triangle is un-normalized by 
shifting back to the initial order of the objects, and the newly found information is 
transferred to the objects which comprise the triangle. In the case of computed angles, 
the function DEFANG defines the rotation of the object based on the angle it makes 
with other objects in the triangle. 
The geometry found in elementary physics problems is usually fairlv simple; 
the solution of a triangle is the ~ m s t  difficult geometric problem which is typically 
found. EUCLID and its subroutines solve such problems in a general way which is 
based on legitimate geometric rules, rather than on "canned" forn~ulas which work for 
particular problems but are not true in general. Geometric programs like EUCLID {but 
much more sophisticated) might be of great benefit to scientists and engineers for 
A 
solving problems in geometry, just as  symbolic manipulation packages are now used to 
aid in solving algebraic problems. 
Although the present program does not do so, it would be easy to generate a 
geometric diagram, similar to the "force diagrams" often found in physics texts, from 
the geometric model of the problem. Such a diagram would be useful if a program 
similar to ISAAC were to be used for computer-assisted instruction in physics. 
5.4 Frame Completion 
After the geometric model has been completed, the function CFDRIVER is 
called to complete the cauonical object frame for each object. Since the canonical object 
frame has  already been selected for each object, CFDRIVER simply calls the frame- 
completion routine associated with the canonical frame for each object. 
The primary operation performed during frame complctioh is the completioxl 
of attachment relations by associating appropriate force vectors for each object ~ v i t  11 the 
attachment frame. In some cases, the geometric model is* requlred i n  comp~lti~lg the 
force vectors. The function CMPA'I'T, which is used for LEVER and PIVOrI' frames, 
associates a two-variable f ~ r c e  vector with each attachment for which the force vector is 
unspecified. (A separate force vector is added to an attachment frame for each object 
which is dttached there.) The forces exerted by the object and t,hc geometljic position of  
the point a t  which each force is exerted are  collected and saved on the 111y)prrty list o f  
the object under the indicator FORCES. For a LEVER frame, the location of a PIVOT 
attached to it is noted if there is one. The function MKWTFRC makes a weight f@>rec, 
exerted on the object a t  its center of gravity, for a lever ob,ject if it has a weight. 
In the case of a WEIGHT object, the weight of the object (which must exist 
since the frame creation routine requires it) i s m e d  to make a downward force vector. 
This vector is inserted directly into the attachment frame. 
In  the case of a spring (or rope), the force exerted by the spring is equal to the 
tension in the spring and directed from the end of the spring toward its center. ~ h ; s  law 
is so "obvious" that it is almost never s t ~ t e d  in a physics text; nevertheless, it is w 
physical law of the SPRING and ROPE canonical objects, and is necessary to solve the 
problems. The frame completion routine for SPRINGS and ROPES calculates the unit 
vwtor from each attachment point to the center of the object. Each component of the 
hnit vector is mul.t.iplied by the tension, and the resulting force vector is put into the 
attachment frame. 
A FORCE may be specified as  a two-component force vector, or in magnitude 
and direction form. If the vector form is specified, it is used directly. If the xnagnitude 
and direction are used, they are .converted to vector form for use in the attachment 
relation. 
A SURFACE is assumed to be a "smooth" surface as  found in physics texts: 
that  is, it can only exert a force perpendicular to the surface. The unit vector 
perpendicular to the surface is calculated and multiplied by a single force variable to 
give the force veetor. 
Once the canonical object frame for each object has been completed, the 
problem model is ready to be turned over to the problem solver. 
5.5 Conclusion 
The processes of frame selection, geometric model construction, and frame 
completion which were described in this chapter are relatively simple processes: yet. 
they are crucial for solving physics problems. We shall argue that  selecting and 
completing canonical object frames is a primary skill which is taught in a physics class, 
that this skill is taught mostly by example rather than explicitly, and that  failure to 
learn the skill from the examples is what causes people to  be "bad" a t  physics. 
6. Problem Solving 
Problem solving, a s  described in this chapter, is the process of writing 
equations which describe the interactions of objects according to well-known physical 
laws, solving these equations for the deqired unknowns, and printing the answer in the 
desired form. Compared to the processes of' language understanding and frame 
construction which precede it, the problem solvix~g process seems very simple: it consists 
mostly of elementary algGbra, which is well understood. 
6.1 Generation of Equations 
Some equations may have been generated directly in Eesponse to statements 
in the prablem, e.g. "the man supports twice as much as the boy" (P7). Any existing 
equations such as these are passed to the equation solver, SOLVEQ, a t  the beginning of 
the problem solving process. The remaining equations are generated and solved by the 
functions ATTDRIVER and PSOLVER. 
ATTDRIVER writes equations for eqch attachment relation according to 
the physical law that the sum of the x forces and the sum of the y forces must each be 
zero for a b ~ d y  in static equilibrium. The x and y components of each force involved in 
the attachment are added to two accumulators using the function SPLUS (symbolic 
PLUS);.two equations are then written setting each of the accumulators equal to zero, 
and the equations are used as arguments in calls to SOLVEQ. These equations are 
generally quite simple, and result in a numeric value for a variable or a substitution 
equation which allows one variable to be rewritten as a function of another. The 
following equations from the set generated for (P4) are typical of the types of equations 
generated by ATTDRIVER: 
(EQUALS 0 FORCE179) 
(EQUALS 0 (PLUS -100 FORCE180)) 
(EQUALS 0 (PLUS (TIMES TENSION173 ,7071 ) FORCE175)) 
The first two equations give numerical values for the variables, and the last 
equation allows FORCE175 to be expressed a s  a function of TENSIONl'i3, thus 
reducing the number of active unknowns by one. 
The function PSOLVER calls the problem-solving functions which are 
associated with some canonical object frames to write equations for objects of that t-ye 
and solve them. The objects which have desired unknowns associated with them are 
selected first, followed by objects which involve other unknowns. After a problem- 
solving function has been called for an  object, a test is made by TESTSOL to see 
whether values have been found for all of the desired unknowns; if-so, PSOLVER 
returns, without requiring that values be found for the other variables. In  the present 
system, there are problem-solving functions for SPRING and LEVER cauonical objects. 
SOLVESPRING generates a single equation for the spring law, which states 
that the tension on a spring is equal to the spring constant times the distance the spring 
is stretched. The other laws which apply to a spring, namely that the sum of the forces 
exerted on it must be zero (in static equilibrium) and that  t h e  force exerted by the spring 
is directed from the end*of the spring toward its center, are made true implicitly by the 
way the force vectors are generated by the frame completion routine for springs. 
SOLV$LEVER generates the three equations, which govern a rigid body in 
static equilibrium, namely that the sums of forces (in the x and y directions) must be 
zerb and that the sum of moments on the body must be zero. If a PIVOT object attached 
to the LEVER was found by the frame completion routine for the LEVER, the pivot 
point is chosen as  the point around which moments are summed; otherwise, a point 
whose position is known and which has one or more unknown forces exerted there is 
chosen. 
The number of equations generated for a single problem is surprisingly 
large: between seven and thirteen equations per problem, with an average of about ten 
equations per problem. For a reasonably skilled human problem solver, all of our 
sample problems can be solved using two equations except for (P4), which requires 
three. This large discrepancy suggests that the human problem solver performs a 
number of steps (which become largely subconscious with practice) to reduce the 
number of equations which must be written. Some equations, such as  those involving 
horizontal forces in a problem where all the significant forces are vertical, are simply 
ignored. Others, such as  our attachment equations, are eliminated by substitution of 
variables which is done mentally. Since these processes are largely subconscious in a 
skilled person, it may be difficult to teach them to a person who is unable to acquire the 
skill by watching the solution of example problems. A program such as  ISAAC, which 
makes all of the steps explicit, might be useful for teaching physics to such persons. 
6.2 Equation Solving 
The equations which are generated to describe the interactions of objects in 
the model of the problem are solved by a set of routines for simplifying expressions and  
solving linear equations. This small symbolic manipulation package is fairly primitive 
compared to the state of the ar t  in symbolic manipulation. Much more powerful 
packages exist, such as MACSYMA [Moses 741; a more powerful program for soJxring 
physics problems could easily be interfaced to such a system (as was Charniak's CARPS 
program), allowing problems involving more complex mathematics to be solved. 
Equations are solved by the method of substitution, that  is, by expressing 
one variable as  a function of another variable and substituting this fur~ction for the 
variable when it occurs in other equations. Since this reduces the number of active 
variables by one, the process can be repeated until a value is found for sollle variable, 
This value can then be substituted illto the f ~ ~ x ~ c t i o t ~ s  t  calculate the values of other 
variables, and 80 forth until values have been calculated for all of the variables. This 
method is the one generally used by humans for solving simple equations. For equations 
as simple as  those generated for our sample problems, the method works well and is 
reasonably efficient; for more complex equations, other methods (such as Gaussian 
elimination) would be needed. 
Equations are written using the five functions SPLUS, SMINUS, SDIFF, 
STIMES, and SQUOT. These functions perform some elementary simplifications on 
their arguments when possible; for example, (SPLUS 0 x) = x, where x is any 
expression. If no simplification is possible, these functions construct a prefix 
subexpression using the corresponding LISP function name. 
The function SIMPLIFY may be used to simplify an  expression (not 
necessarily a n  equation) by operations such as  removing double negations, combining 
constant factors of a variable, and so forth. SIMPLIFY is used in making the geometric 
model as well as in the problem solving process. The function SIMVECT simplifies a 
vector by callihg SIMPLIFY for each component. 
The function COPYSUB copies an  expression, substituting the VALUE of 
each variable (gotten from its property list) for the variable if the value is defined. Such 
a value may be either numeric value or a substitution function in terms of another 
variable. 
SOLVEFOR solves a n  equation for a given variable. which should occur 
only once in the equation. This is easily done by finding a path from the root of the tree 
representing the equation to the desired variable. Inverse operations are then generated 
along this path to bring the desired variable to the top. For example, to solve the 
equation (EQUALS A (TIMES B C)) for C, we generate the inverse operation 
QUOTIENT to obtain (EQUALS C (QUOTIENT A B)). A similar process is easily 
applied to an  arbitrarily large expression. 
The function LISTVC examines an expression and const'ructs a list of all the 
variables and constants used in the expression and the number of times each symbol 
appears. This list is used by SOLVEQ to guide the equation solving process. 
The function SETEQUAL is used to define the value of a variable based on 
an equation. The equation is solved for the value of the variable using SOLVEFOR; 
this value is put on the variable's property list under the indicator VALUE. The value 
is then substituted in the value expression for each variable whose value is expressed as  
a function of the variable just defined; a list of all such variables is stored on the 
property list of the variable under the indicator USEDIN. For each such variable, 
COPYSUB is used to copy its value, substituting the new value of the variable just 
defined. The resulting expression is made into an equation, and SETEQUAL is called 
again (recursively) to define the new value of the variable. In this way, a new definition 
of a variable is propagated to all the variables whose values are dependent on it. Since 
the new definition of a variable may make some saved equations solvable, each 
equation on the list EQUATIONS is copied using COPYSUB; S O L V ~ Q  is then called 
to  solve the resulting equation. 
SOLVEQ attempts to solve an equation; if it succeeds, the results are 
propagated to related equations and variables, which may lead to the solution of 
additional equations. SOLVEQ first uses COPYSUB and SIMPLIFY to substitute 
values for any variables whose values are known or defined in terms of other variables 
and simplify the resulting expression. LISTVC is then called to list the number of 
constants and variables in the expression and the number of times each occurs. If there 
are more than two variables, the equation is considered temporarily unsolvable and is 
put on the EQUATIONS list. If there is only one variable in the equation, SETEQUAL 
is called to define the value of the variable based on the equation; SETEQUAL will 
propagate the consequences of this definition, possibly causing SOLVEQ to be called 
again. If the equation involves two variables, an attempt is made to solve for one 
variable in terms of the other. (If both variables occur more than once in the equation, it 
is saved on the EQUATIONS list). After defining one variable as a function of the other 
and adding it to the USEDIN list of the other, the new value of the variable is 
propagated to all members of its USEDIN list, which is then set to NIL. The 
propagation is done by using COPYSUB and SIMPLIFY on the value of each variable 
on the USEDIN list to substitute the value of the new variable, then adding the variable 
to  the USEDIN list of the other variable in the equation. Thus, for example, if a were 
defined in terms of b as  a = f(b) and b was then redefined as b = g(x), we would 
redefine a as  a = f(g($) and put both a and b on the USEDIN list for i . ' ~ f  theaewly  
defined variable is used in any of the equatibns on the EQUATIONS list, the new value 
is substituted using COPYSUB, and SOLVEQ is called recursively to attempt to solve 
the resulting equation. 
The time required to solve a set of equations varies, but typically is about one 
second (using interpreted LISP on a CDC 6600) for our sample problems. 
6.3 Answer Generation 
Once the values of the desired unknowns have been calculated, answer 
generation is fairlyeasy. The name of a n  answer-generation routine rind the object to be 
used as  its argument are saved (for each part of the answer) on the list SYSREPLY in 
response to the question asked in the problem statement. The functiot~ PRTSOL 
evaluates each of the members of this list in turn, putting commas between the 
generated answers. 
PRTVAR prints the value of a variable and the w i t s  associated with it, If 
the answer is an  expression which contains constants, the f~ilnction EXPLCON is called 
to explain each constant. EXPLCON gets the object with which the constant is; 
associated and the attribute which it measures from the constant's property list, and 
outputs these in a standard format, e.g., "where 1 ENGTH'iG is the length of the pole'' 
(P2). EXPLCON is called by most of the answer generation routines if the answer is an 
expression involving constants. 
PRTFV prints the two compo~lellts of a force vector in parerrtheses, 
separated by a comma. PRTMAG and PRTDIR compute and print the magnitude and 
direction, respectively, of a force vector. 
PRTLOC generates a description of a location; typically, a location which is 
the object of a question will be represented as a point which is a certain distance from a 
known point, with the distance an unknown. PRTLOC pri~nts the distance from the 
known point, then generates a description of it. If the known point has a name, the name 
is printed following the location name, as  in "end (A)"; if it has a meaningful SELECT 
modifier, the modifier is printed with the location name, as in "tha heavy end". 
Otherwise, an attempt is made to find an  object which is attached a t  the known point; if 
such an object is found, it is used to describe the location, as in "7.4 Et from the boy" 
(P7)* 
All of the answer generation functions comprise about two pages of LISP 
code, compared to 44 pages of code for input parsing and semantics. Language 
generation to describe the answers to physics problems is a relatively easy task, since 
the "objects" to be described are so simple. [Simmons and Slocum 721 describe a 
method for generating fairly complex sentences using semantic networks and an ATN 
grammar. 
7. Picture Construction 
The process of constructing a picture from the internal model of the problem 
is in many ways similar to the process of constructing the geometric model of the 
problem; however, there are some significant differences. While a WEIGHT object is 
represented as a point in the geometric model, it must be drawn a,t a reasonable size. A 
size must be chosen for each object whose size is a symbolic constant, and relative 
pusitions on the object must be scaled accordingly. The size of the picture must be scaled 
to the space available for the drawing, independent of the size of the objects in the 
problem. 
Construction of a picture is done in two stages. First, a picture model is 
constructed, specifying the position and size of each object. From this model, global 
offsets and a scale factor are computed to properly scale and position the picture withirl 
the drawing area. Finally, picture generation functions are. called to generate each 
object in the picture. 
7.1 Constructing the Picture Model 
The picture model for the problem is constructed by the function DIAGRAM. 
Each object in the picture is assigned a starting point and a size, which are stored under 
the property list indicators STVAL and PSIZE, respectively. The rotation, stored under 
the indicator ROTN, is the same as for the geometric model. A set of objects arranged in 
a picture is represented by a "picture frame", or PFRAME, consisting of a set of 
minimum and maximum x and y values which bound all 6f the objects in the picture, 
and a list of the objects in the picture frame..The starting point value for each object is 
relative to  its picture frame set. Two picture frame sets niay be combined by specifying 
the coordinates relative to each of a point which is to be made common tcr both. A new 
set of bounds is computed, and objects from one picture frame set are incorporated into 
the oiher by adjusting their starting points and adding them to the object list of the 
other picture frame set. 
DIAGRAM first calls the function PICSCALE to determine the picture 
scaling factor for each object. Some objects are scaled according to the value of a certain 
attribute: poles according to their length, weights according to their weight, springs 
according to their spring constant, and so forth. If such an attribute is defined for an  
object and the attribute has a numerical value, the attribute name and value are saved 
on the property list of the object under the indicator SIZEDET. In addition, PICSCALE 
keeps a list of the different attributes and the maximum value found for each attribute. 
This list and the saved SIZEDET value are used later to determine the scale factor to 
be used for each object in the picture. If R scaling attribute is not specified for an object 
or is not defined as a numeric value, a test is l~ lade  to see if there is n special Rinctidx~ to 
determine the scaling factor for the object: such fut~ctiotls exist for FOIiCE i ~ n d  ri8id 
body objects. PSIZEFORCE computes the magnitude of t~ two-rompdnent forre vector 
and returns this value as the scaling factor. I11 additicln, it computes the rotation of the 
force vector and storus this 011 the force object's property list under the indicator ROTN. 
PSIZERB is used to compute the scaling factor for rigid body objects, includillg both 
SURFACE and LEVER objects. The attachment points of the object are esamined. If 
the attachment goints have ntimcric geonletric posit ions, then the largest distance in the 
x or y directions between two att~chrnent points is used 8s a LENGTH srnlc factor. 
Thus, in the picture for (PX), the uilspecified length of the vertical wall is set equal to the 
distance between the rope and ladder which are attached to it. If numeric values are not 
available for the attach~nent points, but there are some numerical relative positions, the 
minimum distance from the center of gravity of the object to i t s  boundaries in the s 
direction is made equal to the maximum relative position offset: this guarantees that all 
of the relative positions will be drawn within the area of the object in the picture. Thus, 
in the picture for (P2O), the seesaw is made large emugh so that both boys are drawn as 
being on the seesaw, with their relative distances from the center in correct proportion. 
If neither of the above methods can be used, the rnaxi~num dimension of the dra\ving of 
the object is used as the scaling factor with the artificial attribute name CLENGTH. 
This will cause objects of unspecified size to be drawn at a size proportional to the 
unscaled size produced by their drawing programs. 
Once the picture scaling factors have been conlputed by PISCALE, 
DIAGRAM constructs the picture model in a manner similar to the way the geometric 
model is constructed by EUCLID. An initial object. is chosen arbitrarily to start the 
picture. Objects are added to the picture by combining a new object with the existing 
picture a t  a point of attachment between the new object and an object already in the 
picture. Objects which are attached to the new object but are not in the picture are 
added to the waiting list of objects to be added to the picture. The subroutines which are 
used in performing this process are described below. 
MAKEPF is a function which makes a picture frame for a single object. In 
order to do so, it must compute the drawing size to be used for the object and a set of 
picture frame boundaries which will completely enclose the drawing of the object,. Some 
objects, such as  a door or person, have special size computation routines; these are used 
to compute the size for an object if they are defined. If a SIZEDET attribute and value 
were found for the object, its size is scaled in proportion to the rnasimurll value found 
for that attribute in the problem. (For some objects, such as WEIGHT objects, the 
picture could be made more realistic by using a special function to make the picture size 
proportional to, say, the square root of the weight proportion. This was done in a n  
earlier version of the program, but is not in the present version.) If all else fails, the 
scale factor is set to one. The size computation routine for a doorbcomputes separate 
scale factors for the height and width of the door. The picture making function for a 
door draws a square, but with separate scale factors for the x and y coordinates; this 
allows a door to be drawn to scale for the specified width and height. The size 
computation routine for a person uses the SIZEDET value if it is available. Otherwise, 
a test is made to see if the person has a RESTRICT YOUNG modifier; if so, the size is 
reduced slightly. Thus, in (P2) the boy is drawn slightly smaller than the man. If the 
size of an object is defined in terms of length, tho scale factor between length and picture 
site is computed and stored on the object's property list under the indicator PSCALE. 
The picture size (which is s vector, although in most cases only one component is used) 
is stored under the indicator PSIZE. The initial picture frame is computed by scaling 
the basic picture size (stored under the indicator FRMSCL in the GEOMODEL of the 
object) by PSIZE; the minimum values and'starting point are defined by convention to 
be (0 0). i f  the object is rotated, its picture frame is recomputed by ROTPF. This is done 
by computing the positions of the corners of the picture frame after rotation, and 
computing a new .frame which encloses all of these points. Tbis process is illustrated in 
Figure 7.1. As the figure shows, the-rotated picture frame may be somewhat larger than 
needed to contain the object. However, it is easily computed-in this manner, and is 
certain to be large enough. The only effect on the final drawing from a picture frame 
which is too large is to make the drawing slightly smaller than it might have been. 
Figure 7.1: Computing Picture Frame for a Rotated Object 
> - 
After a picture frame has been made for an object by MAKEPF, DIAGRAM 
searches the attachment rclutions of the object to find a pbint a t  which it is attached to 
an object which is al~*eildy in the picture. Whrn such an attachment is found, PICTI,OC 
is called twice to find the position of the point of nttnchment on the new object relative 
to its picture frame and the point of attachment on the other o\)ject relative to thc lurgcr 
picture frame. These two positions are then used in a rill1 to  COMPFHM to combine t ha 
new object's picture frarl-le into the total picture fra111~ which is being r\onstrwtr.d. 
Finally, objects which are att>ached to the new object c1nd are not ~ l r e ~ d y  it1 the picture 
or on the waiting list are added to the waiting list. After all the ub,iects on the waiting 
list have been processed, DIAGRAM esits with the completed picture frame set as its 
value. 
PICTLOC calculates the position of a point on an  object relative t o  the 
object s picture frame. When the geometric size of the object and the name of the 
location are specified, the position is calculated by simple vector operations as described 
in section 5.3 and illustrated in Figure 5.1 for geometric positions. If there is a relative 
position offset from a known location and the geometric size of the object is R symbolic 
constant (as in (P2), where the weight is attached 0.75 times the length of the pole from 
the boy), PSIZERB will have made a CLENGTH size factor for the object. When it does 
so, PSIZERB also defines the VALUE of the length constant to be the same factor. 
Thus, by performing COPYSUB and SIMPLIFY on the relative position expression, the 
correct proportional length on the object in the diagram is obtained. (If the relative 
position were a function of other constants, this procedure would fail, and the relative 
position would be ignored. This does not happen in our sample problems.) If no location 
name is specified for the object, a default location must be found for the object's point of 
attachment in the picture. (This is not usually necessary in the geometric model, where 
such an object is typically treated as a single point.) The defaultn location for the object 
may be stored on the property list of its token word, or there may be a function to 
compute it. Such a function is provided for PERSON objects; this function selects 
HANDS as  the default location if the person is modeled as a PIVOT object, or FEET 
otherwise. (Some verbs, such as SIT and STAND, specify the location as  part of the verb 
semantics, so that  a default location is not needed.) 
COMPFRM combines two picture frame sets, given a point relative to each 
picture frame which is to be made a common point in the combined picture frame. A 
constanttranslation vector is easily computed from the two givein points; by adding this. 
vector to the coocdiriates of each point in the second picture frame, the coordihates of 
the eonresponding point in the first picture frame (which will become the combined 
frame) are obtained. Since the position of each object is relative to its .starting point, 
only the starting point coordinates of the objects in the second picture frame need to be 
recomputedq. A simple loop is used to  recompute thP starting p ~ i n t  of each objcct in the 
second picture frame and add it to the ohject set of the first picture frame. The picture 
boundaries are recomputed by clrlculati~lg the offset positions of the boundaries of  the 
second picture frame, then choosing boundaries for the combined set which e~\close both 
of the component picture frames. This process is illustrated in Figure 7.2, where the 
frame drawn with solid lines is the cot~~bined frame for the two smaller frames drawn 
with dotted lines. (The solid lines are drawn outside of the dotted lilies for clarity where 
they would be in the same place.) 
Many of the functions used for constructing the picture model and drawing 
the pictures are similar or identical to those used in (Simmons and Bennett-Novak 751. 
The picture frame concept used in constructing the picture model is so simple and 
obvious that  it probably is not new; it is described here for completeness. 
7.2 Drawing the Diagram 
The completed picture frame set is passed as a n  argument to the function 
DRAWPICS, which control$ the drawing of the picture. The size of the picture frame in 
the x and y directions is computed from the frame boundaries. These size values are 
used in conjunction with the size of the available picture area to set the global constant 
GLOBALSIZE so that  the finished picture will occupy 0.9 of the available space along 
its maximum dimension. The frame boundaries and global size are used to compute an  
offset base vector so that  the picture will be centered in the available area in each 
dimension. For each object which is to be drawn, DRAWPICS calculates the proper 
offsetstarting position, sets the initial position and heading, and calls the program to 
draw the object with the size a s  an argument. 
The functions used from LISP to  draw the pictures have a structure similar 
to the LOGO language of Papert [Papert 721. The "turtle" concept of plotter commands 
used in LOGO is convenient for drawing objects because an object can be drawn in any 
orientation if the turtle is initially pointed in the right direction. 
Figure 7.2: Cohbining Two Picture Frames 
J 
8. Cox~clusion 
In  the preceding chapters, we have described a particular pi*ograrn which is 
capable of reading, understanding, solving, anti drnwirlg pictures of  a class of physics 
problems which are stated in English. I n  this ~1111pt~'r, \YO shall exatnine the 
methodology of this research, some directions t'or future research \vl~ic'h are suggested by 
this work, and- potential al)plic:\tintls of programs similiti* to this one. Finally, \vu 
present some data  on the progrn,m's sixe und execution time, and exanrille what 
extensions would be necessary to handle ciddit ional problems. 
8.1 Metfiodology 
The  area of physics problems invol~ing rigid body statics is certainly a 
"micro-world", and a fairly sniall one a t  th t~ t ;  howevtlr, in the opinion of this authnr. it 
is a fruitful one for research in computational linguistics. The area is sufficiently -- 
circumscribed to be tractable for progranlnling, but still involves a number of 
interesting problems-many more than a casual glance at the sample problems ivould 
suggest. In some cases, the correct parsing of a sentence depends on the particular 
relations of objects in the model of the problem, thu3 forcing the integration of syntax, 
semantics, and world knowledge in the parsing program. The difficult problem of 
referent identification must be solved (though of course in a limited way) for both 
physical objects and locations. Different sense-meanings of words (particularly verbs 
and prepositions)  nus st be disambiguated. C;tnonical object frames must be selected to 
represent objects in the model, and inferences nlust be niade to construct a corllylete and 
consistent model. Geometrical models of the probleln must be constructed both for 
solving the problem and for drawing the picture. Thus. although the problem sol\ying is 
specific to the area of physics problems, the process of understanding the English 
statement of the problem involves a number of interesting sub-p~*ocesses which are 
likely to be important in any language-understanding program. The area of physics 
problems is a good one for investigating these sub-processes because there is a relatively 
clear urlderstanding of what the result of understailding a physics problenl must consist 
of: a model of the  problem in which the attributes and relationships of objects are 
represented with sufficient specificity to allow equations to be written describ~ng the 
interactions of the objects and to allow a diagram of the problem to be constructed. 
The twenty sanlple problems used to test the progrnrn were selected before 
the major version of the program was  written. (When the program was almost complete, 
one problem which involved a great deal of worlcl.knowledge required only for that 
problem was deleted and replaced by another problem.) Thus. iil a sense. the program 
was written to solve twenty specific problems-not a very large number. However. we 
trled to solve the pr6blr.m~ it1 a legitimate. general way, using a lnitlimum of "tricks" 
We hope (but have not yet shown) that the program could be espanded considerably 
without rewriting very much of the existing code, and that it could be made to solve 
twellty more problems of the same type with relatively little difficulty. (Atlding the 
problem which replaced the deleted one required only a semantic routine for (,nu word.) 
The use of twenty preselected problems by several different authors actually niatle the 
program much more clifficult than it might have been. Almost every problem had some 
idiosyncracy which required additional capabilities of the program or prevented a11 easy 
trick from being used in a superficially similar situatio~l in another p rd~ lem.  On the 
other hand, the diversity of  the problems led to the discovery of many interesting 
regularities which would have been missed if we had (say) selectcd problems that  an 
existing program could solve or edited the problel~ls to make it easier otl the program. 
Thus, in a sense we are treating computational linguistics u s  an  e x p c r i ~ ~ ~ e l ~ t a l  science, in 
which the experimental data are existing examples of linguistic yerformuncr hy 
competent native speakers, and in which the goal of the research is the production of 
progra~ns which can adequately understand the examples of language perfo14rnance. In 
this author's opinion, this is a valuable approach. Many interesting problems which 
would never have been noticed were made glaringly apparent when the program Sailed 
to work. Likewise, many regularities were found bx suddenly rmlizing that  a subroutine 
almost identical to the one needed for the current task was written earlier. This 
approach does'not replace theory, but rather lays the g r a ~ n d w o r k  for theories which 
can be powerful because they account for a large number ~f exarpples of l i~~guist ic  
performance. Because a program such a s  this one deals with the whole process of 
understanding language, it can serve as the basis of a more complete theory of language, 
rather than a theory which deals only with a narrow aspect such as syntax. 
8.2 Directions for Future Resltzarch 
In this section, we will comment briefly on some interesting possibilities for 
future research which are suggested by some af the techniques used in this program. 
The SFRAME (semantic frame) concept. in which a sernantirl interpretation 
is assigned to a phrase, inferences are made to fill in missing arguments of the semantic 
frame, and specialist routirles are associated with the frame to perform tasks associated 
with that  type of semantic object, is au  interesting one. Only a few types of SFKAMEs 
are used in ISAAC; it would be ihteresting to see if this technique is useful for 
understanding language in other areas besides physics problems, and to investigate how 
the use of SFRAMEs might be integrated into the parsing process. 
The process of referent identification is an important one for understanding 
virtually all types of language. The procedures used for referent identification by 
ISAAC are fairly rudimentary, are specific to the area of physics problems, and deal 
only witb extensionally specified referents. This area deserves much more research to  
determine rules for referent identification in wider contexts and ways to represent and 
use intensionally specified referents. (For example. when identifying the phrase "the 8 
million people of New York", we would like to create an  intensional referent, rather 
76 
than creating 8 million PERSON referents.) While a PLANNER theorem can be used as  
an intensional representation, it would be desirable to have a representation which is 
more accessible QS a data object than a PLANNER theorem is. 
The concept of the cal~oniral object frame (due primarily to Minsky) is o 
powerful one. The  canonical frames dealt with in ISAAC are particularly simple ones. 
It would be interesting to develop canonical frames for more complex objects in physics 
and engineering. Analpis  done by engineers is based very heavily on the use of 
canonical object frames; it would be interesting to study how such frames are selected 
and used, and how such frames are used when the modeled object doesn't fit the 
canonical frame very well (as, for example, when piecewise lillear analysis is used to 
simulate a nonlinear device charactefistk). 
Since the model of n problem is constructed before equations nre written to 
solve the problem, the existing program could be used as s test bed fcr in~es t iga~iqg  
other strategies for solving this type of problem. It is clear that the prqsent method 
generates many more equations than are usually generated by humans; it would be 
interesting to investigate how the fey critical equations could be writ ten more directly, 
and what rules might be used to select and inhibit such shortcut methods. 
It would be interesting to extend ISAAC to additional tvpes of physits 
problems. Although the present program handles only static problems. most dynamic 
problems are handled as a sequ-ence of (usually two) "static" situations with a specific 
relationship (such as a conservation law) which holds between the two situatiol~s. 
[de Kleer 751 investigates the interaction of qualit nt ive and q u ~ n t i t  at i v r  knobv!c)dye in 
solv i t ~ g  dynan~ic problems. 
8.3 Potential Applications 
Programs similar to ISAAC, but with expanded capabilities, might find 
useful application in two arcas: a s  engineering assistants, and in technical education. 
There are many specialized programs to aid in the analysis of engineering 
problems. 'Often, however, these progrqrns are not used for problems of small to 
moderate size, either because considerablb knowledge of a system is required in order to 
use it (and it isn't worth the effort-to acquire this knowledge for a small problem), or 
because the data  must be laboriously prepared i n a  rigidly specified format. A program 
which, like ISAAC, could accept a problem statement id English could overcome these 
problems. 
Another patential application of a program stlch as ISAAC is in computer- 
assisted instruction (CAI). Other CAI progra~n's using natmal language, such as the 
SOPHIE program [Brown and Burton 753 for teaching electronic circuit analysis, have 
been successfully developed and used. ISAAC is particularly interestit~g for application 
in this area because of the insights it give$ into the problem solving process. The 
primary skill $hich is taught in a physics class to enable the students to solve problems 
is the application of physical laws to actual prob1t.111~. The physical laws themselves are 
of less importance-in fact, not all of the laws uecessary to solve a problem are taught 
explicitly (such as, for example. the "laws" that  the force exerted l ~ y  a rope is d i rec t~d  
toward the center of the rope and cannot be negative). Many of' these laws are "bu~aied" 
in the procedures for setting up  a problem sol'utioll. These p~ocedures are usually taught 
by example-often with Inany steps left out. The stutlent who does not understand how 
the missing steps are being skipped may become completely lost. A program such as 
ISAAC could be valuable for teaching physics (and similar subjec.ts) because it could 
present all of the steps in detail, progressing to Inore abbreviated forms onre the studc~lt  
grasped the steps that were to be skipped. 
8.4 Program Statistics 
The time required by the program to process a complete problem (including 
parsing, semantics, problem solving, and picture generation) averages about 10 seconds 
per problem, using interpreted LISP on a CDC 6600. This is really quite fast. By using 
compiled LISP instead of interpreted LISP, an  iiwrease in speed of several times might 
be obtained, so that the processing time per problem in a "production" system might be 
reduced to a second or two. I t  took the author about 45 minutes to solve all  the 
problems (drawing only minimal diagrams a6 a innemonic aid);  two of the answers were 
wrong due to "careless" errors. Thus, even in its present form, the program is more than 
ten times as fast as a human test subject and (assuming the problem is within its range 
of competence) more accurate. 
The program fs coded in U T  LISP 1.5, using a virtual memory package for 
function definitions which was written by Mabry Tyson. Virtual memory is particularly 
good for programs such as this one because it allows se~nantic  functions for a large 
vocabulary to be available without clogging the machine when they are not in use. Some 
of the standard transcendental functions needed for the geometry and picture 
generation were coded in LAP to ir~crease their executiotl speed, 
The complete program comprises about 5000 lines of LISP source code, 
including comments. (This is admittedly a n  impl~ecise measure of the program's size.) 
Breaking the program down roughly into functional categories, the percentages of the 
total code in each of the categories are approximately as  follows: 
Syntax 
S e m  ntics 
Canonical Frame Programs 
Geometric Model 
Problem Solving 
Symbolic Algebra Package 
Answer Generation 
Picture Model 
Picture Genera tion 
Lexicon and Other Data 
Miscellaneous 
78 
The current version of the program has a vocabulary of about 2000 words. 
Some of these (for example, different ways of writing tnensurement units) d o  not appear 
in the sample problems. Not counting different forms of' the same root word, tile twenty 
sample problems use a total of 138 words. It  is interesting to graph the number of wortis 
required as  a function of the number OF problems, even though this is somewhat 
dependent on the arbitrary ordering of the problems. Such a graph is s h o \ ~ n  in Figure 
8.1; the graph is extended to include the vocabulary for fi\re udditionnl prnhlems, which 
are discussed in the next section. The graph suggests that twenty pl-oblems (even though 
they are of the same type) are not enough to read1 a plateau where the esisting 
vocabulary will handle many new problems. I n  the next section, we discuss the 
program's ability to handle new problems. 
- 
a 
I I 1 
O 0 
1 
1 1 I I ., 
5 10 15 20 25 
Problems 
Figure 8.1: Required Vocabulary as a Function of Number of Problems 
6 
8.5 Handling Additional Problems 
The ultimate test of an artificially intelligent program is its ability to handle 
new situations for which it was not specifically programmed. Unfortunately, many 
artificial intelligence programs turn out to be "toy'' programs which cannot solve many 
new problems beyond the few test cases used and cannot easily be extended. I t  is of 
interest, therefore, to examine the ability of ISAAC to solve new problems and, more 
important, to examine the specific improvements (in the many abilities of the program) 
which are required to handle new problems. In  order to do this, we asked our colleague, 
Michael K. Smith, to select independently five additional test problems. The 
restrictions on this selection were that the. problems ~ h o u l d  be problems involvillg rigid 
body statics, and that they should be stated in English without requiring a diagram as 
part of the problem statement. The five additional problems are reproduced below. 
P21. A uniform steel meter bar rests WI two scales at its ends. The bar weighs 4.0 lb. 
Find the readings on the scales. 
P22. A 60 ft ladder weighing 100 lb rests against a wall a t  a point 48 ft above the 
ground. The center of gravity of the ladder is one-third the way up. A 160 lb 
man climbs halfway up the ladder. Assunling thut the wall is Erictio~~less, find 
the forces exerted by the system on the ground and the wall. 
P23. A uniform beam is hinged a t  the wall. A wire conne'cted to  the wall a distance d 
above the hinge is attached to the other-end of the beam. The bean1 makes an 
angle of 30 deg with the horizontal when a weight w is hung from a string 
fastened to the end of the beam. If the beam has a weight W atid a length I, find 
the tension in the wire and the forces exerted by the hinge 011 the beam. 
P24. A door 7.0 ft high ant1 3.0 ft wide weighs 60 lb. A hinge I .O ft from the top and 
another 1.0 ft from the bottom each support half the door's weight. Assume 
that the center of gravity is at the geometrical center of the door and dete1;lnine 
the horizontal and vertical force components exerted by each hinge on the door, 
P25. An automobile weighing 3000 lb has a wheel base of 120 in. Its center of gravity 
is located 70 in behind the front asle. Determine the force exerted on each ofthe 
front wheels (assumed the same) and the force exerted on each of the back 
wheels (assumed the same) by the level ground. 
These problems are taken from Physics [Halliday and Resnick 67]*, pages 
327-339, This is a somewhat harder book than the texts from which cc: took the origillal 
twenty sample problems; nevertheless. all of the new problems except (P23) are within 
the existing capability of the problem-solving, geometry, and picture-generation parts of 
the program. However, the program could not complete any of these problems without 
some modifications. In order to solve all five of these problems, it would be necessary to 
extend the capabilities of the program in the areas of vocabulary, grammar. world 
knowledge, and algebraic manipulation. We do not feel that these modifications would 
be too difficult, and we believe that they could be made within the existing framework of 
the program. In the sections below, we consider the specific extensions needed in each of 
these areas to solve the additional problems. 
"Copyright 1967 by John Wiley & Sons, Inc. Used by permission. 
8.5.1 Vocabulary 
Each of the new problems requires additional vocabulary. The average 
increase of seven words per problem is higher than that of the last few problems of the 
original set, probably due to the fact that the problems are written by different authors 
and are somewhat harder. The new words required for each problem are listed below. 
Of the thirty-six words, ten (those-marked with an asterisk) could be added trivially as 
simple lexicon entries or as synonyms of existing words. For example, "one-third" could 
be defined as a nun~ber with a value of 0,33333:33:3; "connect" could be made 
synonymous with "attach", and "wire" and "string" could be made synonymous with 
"rope" 
P21 meter bar'" P23 hinge [verb]* P25 wheel base 
scale wire* front 
reading connect* axle 
distance wheels 
P22 above string* same 
ground fasten* back 
one- third* length level* 
way behind 
UP P24 another 
climb* each [proizoun] 
halfway ha lP  
assume geometrical 
frict~ionless force [adj] 
system component 
high 
bottom 
Of the remaining words, some (such as "wheel base") are useful only for 
individual problems; however, there are still a number of more general words (such as 
"above" and "distance") which are likely to be used in a number of problems out of a 
large sample. This seems to indicate that it would take a much larger vocabulary 
(perhaps twice as large) to include most of the "general" wordslikely to be encountered 
in this type of physics problems. I t  also indicates that  several times more than twenty 
test cases would be needed before we could have confidence in the program's ability to 
solve a new,, independently selected problem, 
There are several constructions in the new problems which are not handled 
by the existing grammar. We shall discuss these below, w t h  the caveat that it is easy to 
overlook subtle features of sentences which might confuse the existing grammar and 
require some debugging. 
In  (P22), the phrase "one-third the way up" would not be handled by the 
present grammar. Such a phrase would become a type of LOCPART SFRAME, with 
inferences required to determine the object involved, the starting point for the relative 
position, and the length of the object. A slight grammar extension might be required to 
9 1 handle the initial clause "assuming that . . , . 
In (P24), an  extension would be necessary to accept the "each'' ill the second 
sentence. Extensions would also be aeecied to accept "half the door s weight", both to 
handle the "half '  and to 'iiccept the possessive form of 11ouns as an adjective (this would 
not be hard, since possessive pronouns are already hanciled). An extension would be 
needed for the compound adjectives in "horizontal and vertical farce components". 
In  (P25), it would be necessary to handle the two parenthetical expressions 
"(assumed the same)". 
8.5.3 World Knowledge 
"World knowledge", as we use the term here, is knowledge of the usual 
relationships and. features of objects which is used in making inferences used to 
understand a problem. Additional world knowledge is needed for several of the new 
problems. 
In (P22), we need to infer that the bottom of the ladder is resting on the 
ground. Similar knowledge is needed for (P26), where we need to infer that the ground 
supports the automobile in four places (the four wheels). In  (P24), we need to know that 
(whatever their vertical position) the hinges are on one side of the door. This would 
require additional semantic routines to control the generation of these locations. 
Additional research on  ways to represent and control world knowledge such 
as that  described in this section would be-very valuable. 
8.5.4 Comments on Individual Problems 
(P21) is of course very simple. If we substituted another word (say 
"supports") for "scales" and substituted "forces" for "readings", the present program 
could solve it. To handle the problem as stated, we would need to add a SCALE 
canonical object (which has a reading equal to the force on it) and add a drawing 
program to draw a scale. 
In (P22), we could take a static view of "climbs" and make it equivalent to 
"stands". Although the program automatically assumes that walls are frictionless, it 
would be easy to write a semantic routine to set a zero coefficient of friction if desired. A 
semantic routine would be needed to identify the referent of "system". 
(P23) is beyond the algebraic capabilities of the present program, since it 
involves algebraic arguments bf transcendental functions. It wo\ild not be hard to allow 
this, although the resulting expressions might be intractable for-the present expression 
simplifier and equation solver. The present prograrri would work if d and. 1  ere 
constants. 
(P24) would present no problems beyond the ones previously mentioned. 
For (P25), a semantic program (or a more general program which referenced 
the object's GEOMODEL) would be needed to correctly define the wheel base of the car 
as the distance between the two axles. The car's GEOMODEL would have to be 
expanded to include wheels and axles. I t  would be desirable to he able to handle an 
object such as a car either as a single point, as in (el@, or as a lever system in its own 
right, as in (P25). 
(F1 LEVER 10 FT LONG IS PINNED FIT I T S  LEFT END 
1 ITHE LEVER I S  SUPPORTED BY fl SPRING WITH R 
CONSTFINT OF 40 LB/FTI [THE SPRING IS  ATTRCHED 
6 FT FROM THE LEFT END OF THE LEVERI[f l  NEIGHT 
OF 20 LB I S  RTTRCHED FIT THE OTHER END OF THE 
LEVER) (THE NEIGHT OF THE LEVER I S  8 LBI(H0W 
MUCH IS THE SPRING STRETCHED) 
ANSWER: 1.00000 FT 
P2 SCHRUM" PAGE 12 NUMBER Ll 
[WHERE MUST A UEIGHT BE HUNG ON A POLE . OF 
NEGLIGIBLE NEIGHT SO THAT THE B O Y  RT O N E  
END SUPPORTS 113 RS MUCH RS THE HflN f lT THE 
OTHER END) 
RNSWER: [TI I IES LENGTH76 7.50000E-1) FROV THE 
BOY . MHERE LENGTH76 IS THE LENGTH OF THE 
POLE 
*Problems marked SCHAUM are from College Physics [Schaum 611. Copyright 1061 by 
McGraw-Hill Book Company. 
Used by permission. 


Appendix B: Object Frame Representations 
This appendix briefly describes the representat ions of objects and their 
relationships which are constructed by the various parts of the program. The vnrious 
items of information associated with each object are stored in its property list under 
named indicators; in describing each type of information, we give the name of the 
indicator under which it is stored, followed by a description of the information itself. 
B.1 Physical Entity Representation 
The property list indicators for physical entities (which include ezplieit 
forces as well as physical objects) and the type of information stored under each one are 
described below. 
ENTITY: PHYSENT 
TOK i word 
WORD word 
NAME: name 
RESTRICT: ((attribute value) . . .) 
SELECT: (selection) 
PARTOF: object 
PARTS: (object. . .) 
COFG: (location) 
LOGS: (location . . .) 
ATTACH: (attachment. . ,) 
Identifies the object as a physical 
entity. 
Identifies the tokenbword of which this 
object is an example. Usually the word 
representing the object in the sentence. 
Identifies the specific word describing 
the object in a sentence, if different 
from the TOK. For example, "boy" 
would be represented by TOK: 
PERSON and WORD: BOY. 
Name of the object if it has one. 
Restrictians on the TOK f o ~  this 
object. For example, "boy'' would have 
(RESTRICT (SEX MALE) (AGE 
YOUNG)). 
Selection used to select a particular 
object. For example, "the upper hinge" 
would have SELECT: (UPPER). 
Object which this object is a part of. 
List of all objects which are part of this 
object. 
Location object dhich is the location of 
the center of gravity of this object (if 
specified). 
List of all locations on this object. 
List of all attachment relations which 
invoIve this object. 
SUPPORT: (object . , .) 
SUPPORTBY: (object . . .) 
UNKNOWNS: (variable . . .) 
CONSTANTS: (constant . . .) 
ROTN: (angle) 
FRAME: frame 
GSIZ E : (sx sy) 
GSTART: ( X  Y(.) 
PIVOT: (x Y) 
FORCES: ( ( C X  y) (fx fy)) . .) 
SIZEDET: (measurement . value) 
PSCALE: scale 
PSIZE : (sx sy) 
STVAL: (x Y) 
IMLACXTEM: *T* 
LENGTH:" (value units) 
WEIGHT: (value units) 
TENSION: (value units) 
CONSTANT: (value units) 
B.2 Location Representation 
ENTITY: LOCATION 
FRAME: LOCATION 
OBJECT: object 
LOCNAME: word 
NAME: name 
List of objects which this object 
supports. 
List of objects which support this 
object. 
List of all variables associated with 
this object. 
List of all constants associated with 
this object. 
Rotation of the object. 
(counterclockwise in degrees) from its 
GEOMODEL orientation. 
Name of the canonical object freurne 
which represents the object in its 
current instantiation, e.g., LEVER. 
Geometric size scaling vector. 
Geometric starting point. 
Preferred pivot kcation for a rigid 
body object. 
Position and force vector for each force 
exerted by the object. 
Measured quantity and value for this 
object, used to determine picture sizt 
scaling. 
Scale factor between geometric-length 
and picture size. 
Picture size scaling vector. 
Starting point for object in drawing. 
True if the object has been drawn, Not 
really used in current system. 
Measurements of various attributes, a s  
appropriate for a particular type of 
object. 
Identifies the object as a location 
entity. 
Identifies a location frame. 
Identifies the object with which the 
location is associated. 
Location name, e.g,, END, 
Name of the location, if specified. 
SELECT: 
REFLOC: 
REFLOCS: 
RELPOS: 
(selection) 
location 
(location . . .) 
(type (quantity units)) 
POSITION: ( s  y) 
Selection used to select this particular 
location. For example, "the ltlft end" 
would have SEIIX;'ICT: (Ll.(=lJrr), 
Location to  which this locnt ion is 
relative. 
List of all locations which nru relative 
to this 10ca t ion. 
Specifies posit ion relnt i1.e t o  the 
r e f e r m e  locntion. For example, "ti f t  
from on@ en(.\" ~ \ * n u l d  hrt\-e l3E:I,l3C)S: 
(FROMLOC' ( 6  FT)), 
Gcornetric posit ion of t hc loc.nt ion. 
FRAME: ATTACH Identifies this as an attachment frar-r~e. 
T Y  PEATT: type Type of attachment. e.g.. PINJOINT 
or CONTACT. 
LOCS: ( (object 1ocatio11 (fx.fj7)) . . .) Specifies each object involved in the 
attachment, along w i t h  the location on 
that object and the force vector for the 
force exerted by the object a t  that 
location. 
B.4 Constant or Variable Representation 
ENTITY: CONSTANT 
or VARIABLE 
SYSTEM: object 
MEASURE] attribute 
UNITS: units 
VALUE: value 
Geometric position of the point of 
attachment. 
Identifies this object as a constant or 
variable. 
Physical entity object with ~vhich the 
constant or variable iS assocla~ed. 
Attribute which is measured, e.g., 
TENSION 
Units of the measurement. e.g., FT. 
Numeric or symbolic espression which 
is the calculated value of a variable. 
Appendix C: Generated Structures for a Sample Problem 
This appendix contains snapshots of some of the major data structures 
produced by ISAAC a t  various stages in the processing of the sample problem (P8). The 
first part of the listing shows the st?uctures produced by the parsing and semantic 
processing of each sentence. After each sentence, the result of the parsing is shown; 
< S> indicates that a major clause was parsed, and the list of tokens which follows 
gives the root of the parse tree (the verb) for each of the major clauses which was parsed. 
This is followed by a listing of each of the tokens produced during parsing. The dump 
follows all of the semantic processing: the tokens are not used thereafter except in 
finding pronoun referents. 
Following the dump of the parse structures is a listing of the internal model 
of the problem as it exists just after all of the input sentences have been processed, but 
before frame creation and all the subsequent processing. Each of the GENSYM atoms is 
a separate object in the model. The four atoms UNKNOWNS, DESUNKS, SYSREPLY, 
and SYSUNITS are global variables whose bindings are the list of all unknowns, the 
list of desired unknow~~s ,  the reply to be generated once the problem is solved, and the 
measurement units used for various types of measurements, respectively. 
The next part of the dump- shows each of the equations presented to 
SOLVEQ for solution, followed by the answer generated by PRTVAR. The equation 
(EQUALS 0 0 )  is caused by a deficiency in CFSURFACE (complete frame for 
SURFACE) which went unnoticed because it didn't cause any problems. CFSURFACE 
requires that the force exerted by a surface be perpendicular to the surface; this is fine 
for an  attachment of type CONTACT, but not for one of type PINJOINT, such as the 
attachment between the rope and the wall. Thus, one of the zeros should be a variable 
representing the vertical force exerted by the wall. The other zero, representing the 
vertical force exerted by the rope on the wall, is correct. 
The final part  of tlle dump shows the model of the problem a t  the end of the 
problem solving and picture generation processes. It can be seen that a great deal of 
information has been added to the model beyond that which was  available immediately 
after the problem statement was read. The meaning of the information associated with 
each of the objects in the model is explained in Appendix B. 
'3 0 
Sentence Structures After Parsing and Semantics 
( T H E  FOOT O f  A LADDER RESTS AGAINST A V E R T I C A L  WALL AN0 ON A 
HORIZONTAL FLOOR) 
TQK289 ( ( T O K  e FOOT) (LFRAME NP) I D E T  * DEF) (NOR Y S )  
(SFRAME . LOCPART) (SEMOBJ LADDER2913 (RFNT L O C 2 9 7 ) )  
TOK290 ( (TOK . L.ADOER) (LFRAME NP) ( D E T  . INDEF) (NSH NF)  
(SFRAME PHYSENT) (RFNT LADDER291 1 
TOK292 ( (TOK . REST) (LFRAME , VP) ( Y A I N V B  . R E S T S )  
( I N T R A N S  * T * )  ( A C T  * T * )  (SUBJ * TOK289) (MODS.  
(CASEARG AGAINST (WALL294)) {CASEARG ON IFLOOR296)l)) 
T O K 2 9 3  ( ( T O K  WALL) (LFRAME NP) (DET INDEF)  (NBR N S )  
(MODS (ROTN 90)) (SFRAME PHYSENF) (RFNT WALLZ94)) 
TOK295 ( (TOK FLOOR) (LFRAME NP) ( D E T  INDEF)  (NBR N S )  
(MODS (ROTN 0)) (SFRAME . PHYSENT) (RFNT F L O O R 2 9 6 ) )  
(THE T O P  OF THE LADDER I S  SUPPORTED F R O M  THE WALL BY A 
HORIZONT4L ROPE 30 FT LONG) 
TOK300 ( (TOK TOP) (LFRAMf NP)  ( D E T  DEF) (NBR NS)  
(SFRAME . LOCPART) (SEMOBJ LADDER291)  (RFNT LOC309) )  
T O K 3 0 1  ( ( T O K  LADDER) (LFRAME . NP)  [ L I L T  . D E F )  ( N R R  N S )  
(SFRAME , PHYSENT) ( H f N T  LADDER291 1 
T O K 3 0 2  ( (TOK SUPPORT) 4 (LFRAME , VP) ( M A I N V B  . SUPPORTED) 
( A U X  IS) (TRANS r 'T") (PASV . O f " )  ( O B J  . TOK300)  
[ M O D S  ( ,CASEARG F R O M  (WALL2941  1 ( ~ b ~ d  . TOK304)  1 
T O K 3 0 3  ( ( T O K  WALL) (LFRAME . N o )  (DET DEF). (NBR V S )  
(SFR4ME . PHYSENT) ( R F N t  W A L L 2 9 4 ) )  
TOK304 ( (TOK . ROPE) (LFRAME NP)  (DET . INDEF) (NR2 NS)  (MODS 
(ROTN 0) (LENGTH 30 F T I )  (SFRAME . PHYSENT) (RFNJ R O P E 3 0 5 ) )  
(THE LADDER I S  SO FT LONG r WEIGHS 1 0 0  LP WITH  I T S  CEdTER OF 
GRAVITY 20 F T  FROM THE FOOT AND A 1 5 0  LB MAN I S  1 0  FT 
FROM THE T O P )  
T O K 3 1 1  ( ( T O K  . LADDER) ( & F R A Y ?  NP) (DET . DEF) (NBQ NS) 
(SFRAME PHYSENT) (HFNT L A D Q E R 2 9 1 ) )  
TOK312 I(TOK BE)  (LFRAME V P )  (MAINVB I S )  ( INTRANS 
*Ta)  ( A C T  'T") (SUBJ . T O K 3 1 1 )  ( C O M P  LENGTH 50 F T )  
(VPCONJ TOK313) 
TOK313 ( ( T O K  WEIGH) (LFRAME VP)  ( M A I N V 8  , dEIGHY) 
( INTRANS UTU) ( A C T  f i T { ' )  (SURJ T O K 3 1 1 )  ( C O M P  . T O K 3 1 4 ) )  
TOK314 ( ( T O K  . L B )  (LFRAME . NP)  ( Q T Y  . 1 0 0 ) )  
TOK315 ( (TOK C O F G )  (LFHAME NP)  (NBR N S )  ( S F M A M E  0 
LOCPART) ( SEMOBJ LADDER291 1 (MODS (LOC AT (LOC317) 
TOK316 ( ( T O K  F O O T )  (LFHAME NP) ( O E T  DEF)  (NBR Y S )  
(SFRAME . LOCPART) (SEMOHJ L A D D E H Z o l )  (HFNT LOC297) 
TOK3lb ( ( T O K  PERSON) (LFRAME NP) (WORD MAN) (MOD5 
( R E S T R I C T  ( S E X  M A L E ) )  (RESTRICT ( A G E  A D U L T ) )  (NEIGH1 
150 L B ) )  ( D E T  . INDEF)  (NBH NS)  (SFHAME PHYSENT) 
(RFNT PERSON3191) 
TOK320 ( ( T O K  BE)  (LFHAME VP) (MAINVB 1 5 )  ( INTRANS . 
$T*)  ( A C T  * T * )  (SUBJ T O K 3 1 8 )  ( M O O S  (LOC A T  4 0 C 3 2 2 3 ) ) )  
TOK321 ( ( T O K  . TOP) (LFRAME . NP)  (DET . DEF)  (NBR NSI 
(SFRAME , L O C P A R T )  (SEMOBJ ~ a n n ~ ~ 2 9 1 )  (HFNT ~ 0 ~ 3 0 9 ) )  
(DETERMINE THE TENSION I N  THE ROPF)  
TOK324 ( ( T O K  DETERMINE) (LFRAME 9 VP) (MAI*NVB DETEHMINE) 
( T R A N S  *f*)  ( IMPERATIVE aTU)  ( A C T  . * T * )  ( O R 3  . T O K 3 ? 5 ) )  
TOK325 ( ( T O K  TENSION) ([..FRAME . NP) (DET . D E F )  (N8R NS)  
(SFRAME . ATTROF) (SEMORJ  R O P E 3 0 5 ) )  
TOK326  ( ( T O K  . ROPE) (LFRAME . N P )  (DET . DEF) (NHR Y S )  
(SFRAME . PHYSENT) (RFNT R O P E 3 0 5 ) )  
Initial Model After Reading Problem Statement 
LADDER291 ( ( T O K  . LADOER) ( E N T I T Y  PHYSENT) ( L O C S  LOC297 
LOC309 LOC317 LOC322) (ATTACH ATTACH298 ATTACt i299 
A T T A C H 3 4 0  ATTACH3231 (SUPPORTBY FLOOR296 WALL294 
ROPE3051 (COFG L O C 3 1 7 )  (LENGTH 50 F T )  (WEIGHT 1 0 0  L B ) )  
WALd2Y4 ( ( T O K  WALL) ( E N T I T Y  PHYSENT) (ROTIU 9 0 )  ( A T T A C H  
ATTACH299 ATTACH3081 (SUPPORT L A D D E R 2 9 1 ) )  
FLOOR296 ( ( T O K  FLOOR1 ( E N T I T Y  . P+iYSENT) ( R O T N  0) (ATTACH 
ATTACH2981 (SUPPORT L A D D E R L 9 1 ) )  
LOC297 ( (FRAME a LOCATION) ( E N T I T Y  LOCATION) (OBJECT 
LADDER2911 (LOCNAME . FOOT) (REFLOCS L O C 3 1 7 ) )  
A T T A C H 2 9 R  ( ( F R A M E  ATTACH) (TYPEATT a CONTACT) (LOCS 
(LADDER291 LOC297)  (FLOOR296 N I L ) ) )  
ATTACH299 ( (FRAME ATTACH)  (TYPEATT m CONTACT) (LOCS 
( L A D D E R 2 9 1  LOC297)  (WALL294 N I L ) ) )  
ROPE305 1 ( T O K  , ROPE) (ENTITY PHYSENT) lROTN 0,) (LENGTH 
30 FT)  ( L O C S  LOC306 LOC307) ( A T T A C H  ATTACH308 
ATTAcH310)  (SUPPORT LADDER291)  (UNKNOWNS TENSION327)  
(TENSION TENSION327 L R ) )  
L O C 3 0 6  ((FRAME * LOCATION) ( E N T I T Y  LOCATION) (OBJECT , 
ROPE305) (LOCNAME a E N D ) )  
LOG307 ( (FRAME LOCATION) ( E N T I T Y  LOCATION) (OBJECT 
ROPE305) (LOCNAME END) 1 
ATTACH308 ( (FRAME a ATTACH) (TYPEATT . P I N J O J N T )  (LOCS 
(WALL294 N I L )  (ROPE305 L O C 3 0 7 ) ) )  
LOC309 ((FRAME LOCATION) (ENTITY LOCATION) (OBJECT , 
LA DOER^^^) (LOCNAME . TOP) (REFLOCS LOC322))  
ATTACH310  ( ( F R A M E  . ATTACH) (TYPEATT . P I N J O I N T )  (LOCS 
(ROPE305 LOC306) (LADDER291 L O C 3 0 9 ) ) )  
LOC317 ((FRAME L O C A T I O N )  (ENT-ITY a LOCATION) (OBJECT 
LADDERZBI,) (LOCNAME FOOT) (REFLOC . LOC297)  IRELPOS 
F R O M L O C  ( 2 0  F T ) ) )  
PERSON314 ( ( T O K  PERSON) (WORD . M A N )  ( E N T I T Y  PHYSENT) 
(RESTRICT (SEX MALE)  (AGE ADULT) )  (WEIGHT 150 LB) 
(ATTACH A T T A C H 3 2 3 ) )  
L O C 3 2 2  ((FRAME a LOCATION) ( E N T I T Y  a L O C A T I O N )  (OBJECT 
LADDER291) (LOCNAME . TOP) (REFLOC LOC309)  iRELPOS 
FROMLOC (10 F T ) ) )  
ATTACH323 ( (FRAME . ATTACH) (TYPEATT CONTACT) (LOCS 
(PERSON319 N I L )  (LADDER291 L O C 3 2 2 ) ) )  
TENSION327 ( ( E N T I T Y  VAQIABLE)  ( S Y S T E M  ROPE305) (YEASURE 
. TENSION) ( U N I T S  L R ) )  
UNKNOWNS (TENS I O N 3 2 7  1 
OESUNKS ITENSION327)  
SYSREPLY ( ( P R T V A H  TENSION327 1 1 
S Y S U N I T S  ( ( F O R C E  . L B )  (LENGTH F T ) )  
Equations Generated By Problem Solver 
SOLVEQ (EQUALS 0 FORCE3281 
SOLVEQ (EQUALS 0 (PLUS FORCE329 FORCE3381 
SOLVEQ (EQUALS 0 (PLUS FORCE330 ( T I M E S  FORCE336 - 1 ) ) )  
SOLVEQ (EQUALS 0 FORCF331) 
SOLVEQ (EQUALS 0 (PLUS ( T I M E S  FORCE337 -1  TENSION327)  
SOLVEQ (EQUALS 0 0 )  
SOLVEQ (EQUALS 0 (PLUS ( T I M E S  TENSION327 -1 ,00000 )  F3HCE332)) 
SOLVEQ (EQUALS 0 FORCE3331 
SOLVEQ (EQUALS 0 FORCE3341 
SOLVEQ (EQUALS 0 (PLUS -150 FOHCE335)) 
SOLVEQ (EQUALS 0 (PLUS 250 (MINUS FORCE338) ' ) )  
SOLVEQ (EQUALS 0 (PLU5 FORCE332 FORCE33611 
SOLYEQ (EQlUALS 0 (PLUS (PLUS (PLUS (DIFFERENCE ( T I M E S  
FORCE332 8 o 0 0 0 0 0 )  ( T I M E S  FORCE333 6 , 0 0 0 0 0 ) )  ( (1IFFERENCE 
( T I M E S  FORCE330-32*80000)  ( T I M E S  FOHCE331 - 2 4 , 0 0 0 0 0 ) ) )  
(DIFFERENCE ( T I M E S  FORCE328 -32 ,00000 )  ( T I M E S  FORCE329 
- 2 4 . 0 0 0 0 0 ) ) 1  1 2 0 0 . 0 0 0 0 0 ) )  
ANSWER: 1 2 0 0 0 0 0 0 0  LR 
Final Model of the Problem 
LADDER-291 ( ( T O K  . LADDER) ( E N T I T Y  , PHYSENT)  ( L O C S  L 3 C 2 9 7  
LOC309 LOC317 LOC322) ( A T T A C H  ATTACti298 ATTACtiL99 
ATTACH310  ATTACH3231 (SUPPOHTRY FLOOR296 WALL294 
ROPE305) rCOFG LOC317)  (LENGTH 50 FT )  ( W E I G H T  1 0 0  LY)  
(GSIZE 1.00000 0) (FRAME LEVER) (SUPPORT PERSON3141 
( G S T A R T  0 0) (ROTpiJ 5 3 , 1 3 0 1 0 )  (FOYCES ( ( 2 4 . 0 0 0 0 0  
32 .000001 (FORCE334 FORCE335) )  ( ( 3 0 , 0 0 0 0 0  4 0 , 0 0 0 0 0 )  
(FORCE332 FORCE3331 1 ((0 0 )  (FORCE330 FOHCE331)) ( ( 0  0 )  
(FORCE328 FORCE32911 ( ( 1 2 . 0 0 0 0 0  1 6 , 0 0 0 0 0 )  ( 0  1 0 0 ) ) )  
(UNKNOHNS FORCE328 FORCE329 FORCE330 FORCE331 FORCE332 
FORCE333 FORCE334 FORCE3351 (S IZEDET LENGTH , 5 0 )  
( P S I Z E  1.00000 1 . 0 0 0 0 0 )  (PSC4LE 1 . 0 0 0 0 0 )  (STVAL 0 0 )  
( IMLACITEM . ' + T * ) )  
WALL294 ( ( T O K  l WALL) ( E N T I T Y  PHYSENT) ( R O T N  - 9 0 )  (ATTACH 
ATTACH299 ATTACH3081  (SUPPORT LADDER2911 (G5IZE 0 0 )  
(FRAME . SUHFACE)(GSTART 0 0 )  (UVKNONNS FORCE336 
FORCE337) (FORCES ( ( 6 , 1 3 9 0 9 E - 1 2  40.00000) ( ( T I M E S  
FORCE337 - 1 )  6Tl ( ( 0  0) ( ( T I M E S  FORCE336 - 1 )  0 ) ) )  
(S IZEDET LENGTH l 4 0 , 0 0 0 0 0 )  ( P S I Z E  8 e 0 0 0 0 0 E - 1  
8 ,00000E-1)  (PSCALE 1,250001 (STVAL -8 ,00000E-1  
6 r 0 0 0 0 0 E - 1 )  ( I M L A C I T E M  . * T U ) )  
FLOOR296 I ( T Q K  FLOOR) ( E N T I T Y  PHYSENT) (HOTN 0) [ A T T A C H  
ATTACH2981 (SUPPORT LADDEREB1) (GSIZE 0 0 )  [ F R A M E  
SURFACE) (GSTART 0 0) (UNKNOWNS F O R C E 3 3 8 1  (FORCES ( ( 0  
0) (0 FORCE330) ) )  ( P S I Z E  1 1)  ( S T V A L  -8,000OOE-1 
6 ,00000E-1)  I I M L A C I T E M  " T ' ) )  
LOC297 ((FRAME , LOCATION) ( E N T I T Y  L O C A T I O N )  ( O B J E C T  
LADDER2911 (LOCNAME . F O O T )  (REFLOCS LOC317)  ( P O S I T I O N  0  0)) 
ATTACH298 ((FRAME ATTACH) tTYPEATT CONTACT) CLOCS 
( L A D D E R 2 9 1  L O C 2 9 7  (FORCE328 ~ 0 ~ 6 ~ 3 2 9 )  1FLOOR29b N I L  ( 0  
F O R C E ' ~ ~ B - )  1 ) (POSITION 0 0 1 
ATTACH299 ( (FRAME , ATTACH)  (TYPEATT , C O N T A C T )  (LOCS 
(LADDER291 L O C 2 9 7  ( ~ 0 ~ ~ ~ 3 3 6  FORCE331)) (WALL294 NIL 
( (TJMES FORGE336 -1) 0))) (POSITION 0 0 1 1  
ROPE305 1 ( T O K  r ROPE) ( E N T I T Y  PHYSENT) [RQTN 0 )  (LENGTH 
3 0  FT)  ( L O G S  LOC306 LOC307)  (ATTACH ATTACH308 
A T T A C Y 3 1 0 )  (SUPPORT L A O D E R Z 9 1 )  (UNKNOWNS TENSION327)  
(TENSION . T E ~ S I O N ~ ~ ~  l.0) (GSIZE 6.00000E-1  0) ( F R A M E  . 
ROPE) ( G S T A R T  6 ,13909E-32 4 0 , 0 0 0 0 0 )  ( F O R C E S ( ! 3 0 . 0 0 0 0 0 ~  
40.00000) ( ( T I M E S  TENSION327 -1.000QO) 0 ) )  
( ( 6 . 1 3 9 0 9 f - 1 2  k 0 . 0 0 0 0 0 )  (TENSION327 0 ) ) )  (S IZEDET 
LENGTH , 3 0 )  (PSIZE 6,0000OE-1 6,00000E-11 (PSCALE 
1.66667) ( S T V A L  -8 .00000E-1  4 0 , 3 0 0 0 0 )  ( IMLACITEM * T o ) )  
~ 0 ~ 3 0 6  ((FRAME . L O C A T I O N )  (ENTITY . LOCATION) (OBJECT 
ROPE305') (LOCNAME RIGHTEND] ( P O S I T I O N  3Tl.00000 0 ) )  
LOC307 ( (FRAME r LOCATION) ( E N T I T Y  . L O C A T I O N )  (OBJECT l 
ROPE305) (LQCNAME LEFTEND) (POSITION 6.13909E-12 
40.00008)l 
ATTACH308 ((FRAME ATTACH) (TYPEATT . P I N J O I N T )  ( L O C S  
(WALL294 N I L  ( ( T I M E S  FORCE337 -1) 0 ) )  (ROPE305 LOC307 
(TENSION327 0 1 ) )  ( P O S I T I O N  6,13909E-12 4 0 , 0 0 0 0 8 )  1 
LQC30? ( (FRAME r LOCATION) ( E N 1  I T Y  LOC4TION) (OBJECT 
LADDERZ91)  (LOCNAVE TOP) (REFLQCS L O C 3 2 2 )  ( P O S I T I O N  
30oOOOOO 4 0 , 0 0 0 0 0 ) )  
ATTACH310 ( ( F R A M E  4. A T T A C H )  (TYPEATT P I N J O I N T )  ( L O C S  
(ROPE305 LOC306 ( ( T I M E S  ~ ~ ~ ~ 1 0 ~ 3 2 7  -1 .00000)  0 1  
(LADDER291 Lot309 (FORCE332 F O R C E 3 3 3 ) ) )  (POSITIOY 
3o.ooooo 40.060oo13 
LOC317 ((FRAME , LOCATION) ( E N T I T Y  , L O C A T I O ~ J )  ( o ~ ~ f c f  , 
LADDER2911 (LOCNAME F O O T )  (REFLOC LOC297) (RELPOS 
FROMLOC ( 2 0  F T ) )  ( P O S I T I O N  12 ,00000  1 6 , 0 0 0 0 0 ) )  
PERSON319 ( ( T O K  . PERSON) (WORD , M A N )  ( E N T I T Y  , PHYSENT) 
( R E S T R I C T  (SEX MALE) ( A G E  A D U L T ) )  (WEIGHT 150 L R )  
(ATTACH ATTACH3231 (GSIZE 0 0 ) (SUPPORTBY ~ ~ 0 0 ~ ~ 2 9 1 )  
(FRAME . WEIGHT) ( G S T A R T  ~ 4 . o o o o o  32 .00000 )  ( R O T Y  o j  
(FORCES ( (24 .00000  32 .00000)  ( 4  -150)  1 )  (S IZEDET FORCE 
1 5 0 )  ( P S I Z E  6,00000E-1 6 a 0 0 0 0 0 E - 1 )  ( S T V A L  17.80000 
32.60000) ( ~ M L A C I T E M  . * T Q )  
LOC322 ( (FRAME LOCATION) (ENT ITY  LOCATION) (OBJECT 
LADDERZ91) (LOCNAME T O P )  (REFLoC LOC309)  (RELPOS 
FROMLOC ( 1 0  F T ) )  (POSITfON' 24m00000 3 2 a 0 0 0 0 0 ) )  
ATTACH323 ((FRAME . ATTACH1 ( T Y P E A T T  , C O N T A C T )  t L O C S  
( P U S O N 3 1 9  NIL ( 0  - 1 5 0 ) )  (LA0DER291 LOC322 (FORCE334 
FORCE335)) )  ( P O S I T I O N  24m00000  3 2 , 0 0 0 0 0 ) )  
TENSION327 ( ( E N T I T Y  . VARIABLE) ( S Y S T E M  ROPE305) (qEASURE 
TENSION) ( U N I T S  a L B )  (VALUE 1 2 0 e 0 0 0 0 0 ) )  
FQRCC328 ( ( E N T I T Y  . VARIABLE)  (SYSTEM , LADDER2911 (MEASURE 
a FORCE) (UN ITS  . LB) (VALUE 0 ) )  
FORCE329 ( ( E N T I T Y  a VARIABLE)  (SYSTEM kADDEH2Q1) (MEASURE 
. FORCE) ( U N I T S  L B )  (VALUE . - 2 5 0 ) )  
FORCE330 ( ( E N T I T Y  VARIABLE) ( S Y S T E M  LADDER2911 (MEASURE 
. FORCE) ( U N I T S  . L B )  (VALUE - 1 2 0 ~ 0 0 0 0 0 ) )  
FORCE331 ( ( E N T I T Y  a VARIABLE) ( S Y S T E M  LADDEH291) (YEASUWE 
1 FORCE) ( U N I T S  L B )  (VALUE . 0)) 
FORCE332 ( ( E N T I T Y  VARIABLE) (SYSTEM . LAODER291) (MEASURE 
r FORCE) (UN ITS  + LB) (VALUE , 1 2 0 , 0 0 0 0 0 ) )  
FORCE333 ( ( E N T I T Y  . VARIABLE) (SYSTEM LADDER2911 (YEASURE 
FORCE) ( U N I T S  . LR) (VALUE , 0 ) )  
FORCE334 ( ( E N T I T Y  . VARIABLE) (SYSTEM l LADDER291) (VEASURE 
FORCE) ( U N I T S  L B )  (VALUE 0 ) )  
FORCE335 (. (ENT ITY  VARIABLE) (SYSTEM . LADDER291 CAEASURE 
FORCE) ( U N I T S  L B )  (VALUE a 1 5 0 ) )  
FORCE336 ( ( E N T I T Y  a VARIABLE) (SYSTEM , WALL2941 (MEASURE 
FORCE)  (UN ITS  L B )  (VALUE - 1 2 0 . 0 0 0 0 0 ) )  
FORCE337 ( ( E N T I T Y . .  V A R I A B L E )  (SYSTEM , H A L L 2 9 4 )  (MEASURE 
FORCE) ( U N I T S  . L B )  (VALUE , 1 2 0 a 0 0 0 0 0 ) )  
FORCE338 ( (ENT ITY  VARIABLE)  (SYSTEM E'LOOR296) (MEASURE 
. FORCE) ( U N I T S  L B )  (VALUE 2 5 0 ) )  
Becker, Josep!~ D. "The Phrasal IJesicoll", pp. 6O-(il in TIleoretical issues in Nottr~*nl 
Language Pr.oressirg, prt~cecldings of n conference held at  M.I.T. OR +June 
10-13, 1975. 
Bobrow, Daniel G. "Naturul Language Input for a Coinguter Problem-Solving 
Systenl" , ill [hl insky 68). 
Bobrow. Dnniel and Collins. A411iul 1Kd.1. Rel~r*rserztntio~l nrttl Li~ciers/nric~i;!g NP\Y 
York: Aoudenric P~*ess, 197;i. 
Browi1, G. Spencer. Lows o f  F O I W ~ .  Xc\v York: R:inturn Hooks, 1972. 
Brown. John Sltely and Burton. Hicl~:~l~d K."hlultiplr Hrpresrntntions of Knc,wlcdxc 
for Tutorial Reasoning " In Hnbrow and Collins. 
Charniak, Eugene. "Computer Solutiotl of Calculus K u r d  Problems" Proc. 1st Intl 
Joint ConJ on Artificial Irltellige~ce, pp. 303-916. Boston: Mitre 
Corporation, 1969. 
. "CAKPS, a Program which Solves Calculus Word Problems." 3I.I.T. 
report MAC-TH-31, available frotn W " S  3 s  AD 673  ($70, .Jul? 19BS. 
. "Toward a Mndel of Children's Story Comprehensior~",', M.I.T. *I.I, Lab 
Report A1 TR-3Glj. Dec. l!)'i2. 
de Kleer, Johan. "Qualitative and Quantit at i ~ r  Knowlecige in Classical RIechnnics " 
M.I.T. A.I. L R ~  l3eport AI-TR-35'2, Ilccember 19'75. 
Dull, C.E., hletcolf'e, H.C., n l ~ d  'CVilli~ilns, .J.E. .lIoder.rl Physics, Ntw York: W o i t ,  
Rinehart  and \Vinstou, l9ti4. 
Gelb, Jxck P. "Esperinlents with a Nntul-nl Z,angutige Problenl-Solving Systunl' ' , Yr.oc. 
Brzd Intl. Joint Conf. O I Z  .41.tificinl Intelligence. pp. -135-462. LAondon: The  
British Cotrlputer Society, 197 1. 
Halliday, David and Resnick. Robert . 'Ph~sics \Parts  I and 11). Nex York: John UTile> $ 
Sons, 1967. 
* .  Heidorn, George E. "Natural Language Inputs to a Sirnulation Programming System. 
NPS-55HD72101X, Naval Postgraduate School. Monterrey, Califol-nla, 
1972. 
McCarthy, John, et al.  LISP 1.5 Programmer's illar~ual. Cambridge, Mass.: hI.1.T. 
Press, 1965. 
McDermott, D.V. and Sussnlar~, G.J. "The CONXIVER Reference M a n ~ ~ a l " ,  h1.I.T A.1. 
Lab Memo No. 259, 197'3. 
Minsky, Marvin. Senlantic Inforrrmtion Processing. Cambridge, Mass.: M.I.T. Press. 
1968. 
. "A Framework for Representing Knowledge". M.I.T. A.I. Memo No. 306. 
1971. Also appears in Wqinston (d.) 1975. 
Moses, Joel. "MACSJyMA-The Fifth Year." ACM SIGSAV Bttlletin. Vol. 8, No. 3 
(Aug. 1974), pp. 105-1 10. 
Papert, Seymour. "Teaching Children to be Mathematicians vs. Teaching About. 
Mathematics." h t .  J Math. Educ. in Science & Tech., New York: Wiley & 
Sons, 1972; M.I.T. A.I. Meluo No. 249, July 1971. 
Schank, Roger C. "Identification of Co~lceptualizatiolls Underlying Natural 
Language", in Schank and Colby (eds), 1973. 
. Conceptual Informfation Processing. New York: American Elsovier, 1975. 
Schank, Roger C. and Colby, K.M. (eds). Computer Models of Tllought and Language. 
San  Francisco: W.H. Freeman and Co., 1973. 
Schaum, Daniel; Theory and Problems of  College Physics, 6th ed. New York: McGraw- 
Hill, 1961. 
Simmons, R.F. "Natural Language Question Anstvering Systems: 1969," Corntn. ACM, 
vol, 13, no. 1 (January, 1970), yp. 15-30, 
. "Semantic Networks: Their Computatiotl and Use for Understanding 
English Sentences", in Schank and  Colby (eds.),'1979. 
Simmons, R.F. and Amsler, R.A. "Modeling Dictionary Data" Technical Report 
NL-25, Computer Science Dept., T h e  University of Texas a t  A.ustin. 1975. 
Simmons, R.F. ahd Bennett-Novak, G. "Semantically Analyzing an  English 5ubset for 
the Clowns Microworld", American Journal of Computational Linguistics, 
Microfiche 18, 1975. 
Simmons, R.F. a n d  Bruce, B. "Some Relations between Predicate Calculus and 
Semantic Net Representations of Discourse." Proc. 2nd in ternat io1~~2 Joint 
Conf. on Artificial Intelligence, London: British Computer Society, 19'7 1. 
Simmons, R.F. and Slocum, J. "Generating English Discobrse from Srtnantic 
Networks," Conzm. ACM, vol. lt5, no. 10 (October 1972), pp. 891-9115. 
Wilks, Yorick. "An Intelligent Analyzer. and Understandel of English" 
Communications of the ACiM, vol. 18. no. 5 (hIay 19751, pp. 26.4-274. 
Winograd, Terry. Understanding Natural Languczge.Nekr York: Acatie~nic Press. 1972. 
Winston, Patrick H. The Psychology of Cornputer Vision. New York: McGraw-Hill, 
1975. 
Woods, William A. "Transition Network Grammars for Natural Language Allalysis" 
Communications of the ACM, vol. 1 3 ,  no. 10 (October 1970). pp. 591-(506. 


AN INTERACTIVE P~0NOIEGICAL 
RULE TE3TING SYST~4 
Victoria A. Fromkin 
and 
D. Lloyd Rice 
Univers i ty  of Ca l i fo rn ia ,  Los Angeles 
September 1969 
One of the many ways the h igh-speed computer i s  use fu l  to  l ingu is t i c  
researchers  i s  fo r  the  eva luat ion  of generat ive  grammars. Severa l  p ro~-s~ing  
systems fo r  th i s  purpose have been descr ibed  in  the l i te ra ture .  1 ,2 ,3 ,~ 
A t rans format iona l  generat ive  grammar cons is ts  of a syntact i c  component, a
phono log ica l  component and a semant ic  component. This  paper  i s  concerned 
so le ly  wi th  the phono log ica l  component. While th i s  component i s  a dependent 
par t  of  the  ent i re  grammar, systems of phono log ica l  ru les  fo r  spec i f i c  lan -  
guages,  i.e, the phonological components of the graEmars of th~se languages, 
have been separately presented by Chomsk~ and Halle 5, Kuroda , Schaohter 
and Fromkin 7 and others. The Sound Pattern of English 5 (hereafter, ~PE) 
includes the 'formalism used for presenting phonological rules and the schemata 
that represent them, and the interpretation of this formaliam'? (p? 390) 
This formal description is taken as the basis for the rule structures d/a- 
cussed in this paper. 
Cho~sk~ and Halle state that 'The rules of the grammar operate in a 
mechanical fashion; one my think of them as instruc~ns that might be given 
to a mindless robot, incapable of exercising any ~udsment or imagiluation in 
their application. An~ ambiguity or inexplicitness in the statement of rules 
must in principle be eliminated, since the receiver of the instructions is 
asssmed to~he incapable of uain~ intelligence to fill in gaps or to correct. 
errors'? They find it 'a curious fact' however that 'this condition of pre- 
ciseness of formulation?..has led man~ lin6uists to conclude that the nctivation 
for such grammars must be.? . some.?use  of computers'? We also believe that 
there  are  more b~sic theoret i ca l  mot ives in  c la r i ty  and completeness;  we 
furthe.r  be l ieve  that  th i s  very exp l i c i tness  makes poss ib le  the  use of the  
computer fo r  tes t i~  such ru les .  
Furthermore,  the  complex i t ies  of  natura l  language are  re f lec ted  in  
the components phono log ica l  ru les .  Anyone who has at tempted to teach  a 
group of  g raduate  s tudents  the phonology o f  Eng l i sh ,  us ing  the  ru les  pre -  
sented  in  aPE can a t tes t  to the fac t  that  even a s ing le  ru le  schema presents  
end less  problems for  the br ightes t  of  s tudents  when he a t tempts  to expand 
the sche.~- and to apply th i s  se t  of  ru les  to  convert  an abst rac t  ~urface 
s t ruc ture  of  a sentence  in to  i t s  phonet ic  representat ion .  While the  l iDgu is t  
or  the  s tudent  m~y be possessed  wi th  greater  in te l l igence  than the mind less  
robot ,  he i s  a l so  possessed  with human fa l l ib i l i ty ,  and l im i ted  t ime and 
energy.  For these  reasons ,  the  mind less  robot  can perform far  more e f fec t ive ly  
than a Linded human. The conq~ater program which i s  descr ibed  in  ~ paper  
was wr i t ten  to a id  human phono log is ts  in  the  wr i t i~  of  ru les ,  the  tes t ing  
-2 -  
of ru les ,  and the teaching of phonology. The importance of such a computerized 
phonological  ru le  teeter  becomes very apparent when one se lec ts  at  r-n~om 
any twenty- f ive  Engl ish words, attempts to provide what one assumes to be the 
under ly ing phonological  representat ion ,  and then app l ies  the ru les  of  SPE 
as spec i f ied .  One of the authore of  th i s  paper made euch an attempt.  After  
more hours than she wishes to remember, and using every poss ib le  underly ing 
segment, she found that  eleven of  these randomly chosen words could not be 
cor rect ly  der ived.  Nor were these s t range fore ign loan words, un less  one 
be l ieves  the word 'America' to be an except ional  item in  the Engl ieh vocabu- 
lary?  
This example is not offered as a criticism of Sound Pattern of English, 
probably the most important published book on English phonology and phono- 
logical theory. Nor are we concerned here with any theoretical weaknesses 
which may or may not be present in this work. What is apparent is that had 
a phonologic~-I rule tester been used, prior to the publication of this set 
of rules, many of the problems in rule orderinE~ omitted contexts etc. could 
have easily been corrected~ and those rules which present problems and which 
cannot work would have at least been revealed. Furthermore, because of the 
speed of the computer, one could have tested not only twenty-five words, but 
hundreds -- determining the correct underlying forms of formatives, and there- 
by providing a lex lc~ @B ~ h  the Pnle, ,o~ operate? 
A ~er  ~t, ebl~s ~.~ed ~n ~ i ~  up ? p rod-as  ~or roach a tes ter  i s  
~h, J~$a$~.om~. oospro~se  ot~en n~esury  betveen the computer input  format 
the ru le  deeeript iom seh~su used by l ingu is te  to express the i r  phono- 
log ica l  ru les ,  The Phonological  Rule Teeter of Bobrow and Fraser  8 so lves  
th i s  problem by o f fe r in6  a var ie ty  of log ica l  combinator ia l  devices which may 
be used to group e i ther  segments wi th in  a ru le  or  complete ru les  fo r  d i s -  
junct ive  or  conjunct ive app l i ca t ion .  Such a system has very general  descr ip t ive  
capab i l i ty ,  but complex ru les  appear in  the computer input  form ra ther  d i f fe rent  
from the linguist' s format. 
In  cons iderat ion  of  the deecr ip t ive  powers of  euch systems, i t  appears 
that  the input format should be made as spec i f i c  as poss ib le  to the proposed 
theoret i ca l  s t ruc ture  s ince a more general  deecr ipt ive  scheme requ i ree  the 
ru le  wr i te r  to learn  n more powerful  meta-language than i s  needed. This 
para l le l s  the genera l  d i rec t ion  of  development of computer languages; from 
the genera l  machine-or iented coding to the spec i f i c  problem-or iented languages.  
This paper describes the translational core or compiler of a system which 
accepts phonological rules in a format very close to that formalized in The 
Sound Pat tern  of  Engl ish and produces as output the coding s imi la r  to phone'---tic 
segments necessary to evaluate the input ru les  in  a phonological  tes t ing  pro-  
gram. The input format of  th i s  system i s  espec ia l l y  appl icab le  to keyboard 
entry on a CRT graphic terminal such as the IBM 2260 and is planned for pos- 
sible use in an on-line classroom system for teaching the properties and 
operation of the phonological component, as well as for the writing and testing 
of phonological rules by the linguist. 
The rule testing program consists of an'input block, a sequence of phone- 
logical rules, and a printout block (see Figure i). The input block will ac- 
cept a string of characters from the operator's console representing the under- 
lying form of a word or phrase or an~ form assumed to occur in a derivati ?n 
-3- 
in the phonological component. This form is then tested against the environ- 
mental conditions specified by the stored rules and modified according to 
those rules whenever a match is found? The string of phonological units,i.e, 
segments and boundaries, and/or the binary matrix resulting from the applica- 
tion of any rule may be optionally displayed on the operator's console after 
the application of that rule. 
Rule Spec i f i ca t ions  I Compiler | 
input R1 R2 
form ---) 
E IPrintout 
A Block 
~3 
Figure 1: The Phonological Rule Tester  
The s t ruc ture  of  the program is  such that  any ru le  or  sequence of  ru les  
can be tes ted  using the same input and output blocks.  The ru les  in i t ia l l y  
coded for  tes t ing  and descr ibed in th i s  paper are taken from Cholu~y and Halle 
(1968)o The program however, is not limited to these particular rules, but 
can be used to test any set of rules comprising the phonological component of 
a generative grammar. 
The Input Format fo r  Rule Descr ipt ion 
The input to the phonological  component cons is ts  of a s t ruc tura l ly  
analyzed s t r ing  cons is t ing  of  syntact ic  brackets  (e .g .  Noun Phrase, Noun, 
Adjective, Verb e tc ) ,  segments, and boundaries.  The segments and boundaries 
are composite feature  bundles.  
The system used in  our Phonological  Rule Tester  spec i f ies  these un i ts  in  
any of severa l  ways: 
a. As a combination of upper-case alphabet ic  characters  represent ing  the  
var ious phonological  segments defined in the system; 
b. As a c lus ter  of  d i s t inc t ive  feature spec i f i ca t ions  enclosed in  angle 
brackets. These may be spaced horizontally or vertically, i.e. I 
<+voc - cons  - round)  
<?voc> 
<-cons> 
<-round>,  
but  a re  to  be cons idered  s imu l taneous ly  an a c lus ter  ra ther  than  con-  
Junct ive ly  as in  the square bracketed ser ies ;  
c. As a sequence of segments of specific predetermined types; 
'~"  ind icates  a~ vowel segment, i .e . ,  de f ined  as +voc 
'~"  ind icates  a~r non Vowel :seBlent ,  i ?e .  a t rue  consonant,  a 
l iqu id  or  a g l ide ,  i .e . ,  de f ined  as  e i ther  -voc or +cons , 
'~"  ~d icntes  a~ sequence of un i t s  not coatat~n~ the boundary 
un i t  #, 
i '~"  ind icates  a s t~ of a t  leas t  i consonants ,  
i , j  '~"  ind icates  a s t r in8  of  a t  leas t  i and not more than j consonants ,  
d.  As any of  severa l  boundary un i t s  #, +, or = , which Si~Dify themselves?  
e. as s combinat ion of  b rackets  and upper -case a lphabet ic  characters  
represent ing  the  ~tact i c  b rackets  de f ined  in  the system. 
Rules in  the  Phon~os ica l  Component a re  of  the  form 
A- -B /X - -Y  
where 'A and B are  s ing le  un i t s  or  the nu l l  e lement;  the  arrow stand~ for  
' i s  actuaiLized by ' ;  the  d ia~0n~ l ine  mean~ '~n the context ' ;  and I and Y 
represent  respect ive ly ,  the  le f t  and r~ht  hand environments in  ~nick A 
appears .  These ~r  a l so  be nu~,  or  may con~at  o f  un i t s  or  s t r~s  of  
un i t s  and inc lude  labe led  syntact i c  b rackets .  
Our ~yste l  accepts  ru les  wr i t ten  in  th~ format,  i .e .  
L~ -- I~3 / context  spec i f~nt ion .  
A ru le  i s  app l i cab le  i f  the  IN3 la tches  some un i t  ' i n  the tes t  s t r in8  
and any context  spec i f ied  in  the  ru le  i s  found to  ex is t  a t  or  ad jacent  to  the 
matched un i t ?  The context  spec i f i ca t ion  ma~ cons is t  of  an~ sequence of one 
or  more un i t s ,  and enmt inc lude  a marker - -  to  ind icate  where the  LHS f i t~  in -  
to  the  spec i f ied  context ,  or  more exact ly ,  how the  enwironment must be con- 
f igured  around the  matched un i t  in  o rder  fo r  the  ru~e to be app l ied?  
In  the  l~hon~Logkal Co l l~nent  of  a ~ran~r ,  two par t ia l~  ident ic~ 
ru les  mar be coa lesced  in to  a ~ e  ru le  ~aeq~_~y enc los~ .the cozTespo~l ing 
non- ident ica l  par ts  in  b races ,  i ?e .  A -- B /  - -~\ [ .  Schema UeLt~ m~h braces  
coa lesce  a con~unct ive  sex~es of  r~eso  The rg~e~ are ap~ed im order?  A 
con junct ive  ser ies  o f  un i t~ i s  wr i t ten  in  our program as a ver t i ca l  l i s t  
bounded le f t  and r~ht  by columns o f  le f t  and r ight  square brackets .  T~s  
cor responds  to  the  braces?  For example, g iven  the  phono lo~ca l  ru le  (1)  
(1) V -- V -- \[+S~aX\] 
has the interpre~atlon that the rule will be t~ed first with the context spsc- 
i f i ca t ion  ooas~t in~ of  the  ae~mnt  ~rmbo\].ized as  N ( i .e .  na~a l ) ,  and then with 
the  context  coas~t~ of  the  se/paent V. 
In  our system a ru le  c o ~  a ?on~u~t ive  ser ies  i s  matched aga ins t  
the  tes t  s t r i~  tak ing  each o f  the  con junct ive  i tem in  the  order  they appear  
in  the  ser~es ,  app~in@ the  ru le  ~ l led ia te ly  a I~ t ime the match~ s t r i~  in -  
c lud ing  the  cur rent  i tem matches the  appropr ia te  por t ion  of  the  tes t  s t r i=8o  
In  the  phono loE ica I  theory  ~der l~ ing  our 6ystem, ru les  la~ a lso  be 
d i s junct ive \ ]~ ordered.  Such ru les  a re  represe~ed in  schema by the use of  paren-  
theses  and anted  brackets .  
A d i s junct ion  i s  wr i t ten  as  a m~t  or  sequence o f  un i t s  enc losed in  
parenthes~s?  I t  d i f fe rs  from the  con junct ive  ser~es  in  the  sequence of  ap- 
p \ ] - i cab i l i ty  to  a par t i cu la r  tes t  s tz~J~.  A d~m~unction i s  matched ms~inst  he  
-5- 
tes t  s t r ing  by cons ider ing  f i r s t  the  conteXt inc lud ing  the d i s junct ive  i tem.  
I f  th i s  match i s  success fu l  the  ru le  i s  app l ied  and no fu r ther  match i~ i s  
a t tempted.  I f  the f i r s t  match i s  unsuccess fu l ,  then the aatch  i s  a t tempted 
omi t t ing  the  d i s junct ive  i tem, app ly ing  the ru le  i f  a match i s  found. 
C lear ly ,  the  conteXt must spec i fy  exact ly  one re la t ive  pos i t ion  of  
the LHS, marked by the double dash, - - .  Thus, the LKS pos i t ion  marker m~y be 
in  a con junct ive  ser ies  i f  i t  appears once in  each i tem of the  ser ies ,  but 
i t  may not occur ins ide  a d i s junct ion .  
The i tems of a con junct ive  ser ies  or  of a d i s junct ion  may in  tu rn  
inc lude  e i ther  con junct ive  ser ies  o r  d i s junct ions .  Conjunct ive  ser ies  must 
be wr i t ten  wi th  the bracket  columns eXtending below and not  above the l ine  
externa l  to the con junct ion .  Ext ra  spaces m~7 be inc luded  e i ther  hor i zonta l ly  
or  ver t i ca l l y  for  c la r i ty  and in  some eases  may be needed fo r  d i sambiguat ion .  
Rule (12) from SPE would be expressed as follows in this system: 
\ [~  - -  Ere \] \] 
# ~ w / \[ \ [ ( J r \ ] )  \] \] 
\[ \[ \[Zm\] #\]  \] 
\[ \] 
\[ (*round -VOC +cons> -- \] 
A context specification may conoist of stacked contexts according to 
the convention that 
A- -B /D- -  E /  C - -  F 
i s  in terpreted  as 
A- -B /  C D- -  EF .  
System St ructure  
The ru le  tes t ing  program proper  cons is ts  of  4 sect ions .  They are :  
1. the system s torage  de f in i t ions  which inc lude  de f in i t ion  of  the  feature  
set  used, 2. the  mechanics necessary  to  accept  an input  form and set  up the  
tes t  mat r ix  w i th  the  features  of  the  input  form, 3. a ru le  tes t  loop which 
cont ro l s  cyc l i c  o rder ing ,  and 4. the  rout ines  to pr in t  out the  resu l t s ,  e i ther  
in segment string or in binary matrix form, following the application of at~ 
rule. The rules are then included as blocks of coding inserted an desired in 
the test loop. 
Initially, four values are defined which determine the size of the 
var ious  tab les  and matr i ces  in  the  system. 
DECLARE L (6O) CHAR (2 ) ;  
DECLARE F (60,20), M (50,20) BIT (I); 
DECLARE s (5o) F~;  
The amount of  memory reserved  may be eas i ly  changed by a l te r i~  only  
the l ines  de f in ing  the  s i ze  l im i ts .  
An ar ray  L of  CHARACTER STRING var iab les  i s  dec la red  to have length  
60 and a log ica l  mat r ix  F i s  dec la red  to have a length  of 60 coluwns, each column 
having 20 e lements  or  b i t s .  Immediately a f te r  program execut ion  has beEun, in -  
put of  the feature  set  i s  requested .  The feature  spec i f i ca t ion  cons is ts  o f  the  
-6- 
character  representat ion  fo r  each phono log ica l  un i t  fo l~ded by a t  leas t  1 
space fo l lowed by an ordered s t r ing  of  ? ' s  and - ' s  cor respond ing  to the 
feature  va lue ass ignment .  The order ing  i s  a6 in  Table 2 below. The 
character  representat ion  of  the  n th  un i t  entered  i s  s to red  in  the  nth  
e lement of the  s t r ing  ar ray  L and the  feature  va luea  are  s to red  as  l ' s  and 
O 's  in  the nth  column of  the feature  re fere~e matr ix  F (n 60) .  I f  
l ess  than 20 b inary  va lues  are  spec i f ied  fo r  a~ un i t  the  remainder  of  the  
column i s  f i l l ed  w i th  O 's  ( i .e .  - ' s ) .  Table 1 i s  a l i s t ing  of  the  un i t s  
and feature  va lues  used fo r  tes t ing  the  ru les  of  Eng l iah  in  the  present  
study (from Cho~asky and Halle, 1968). 
-7 -  
Symbol  
bZ  
I I  
UU 
EE  
O0 
AA 
OE 
%% 
I 
U 
E 
& 
&& 
0 
Y 
W 
? 
R 
L 
P 
B 
F 
V 
X 
T 
D 
Phonemic  
Un i t  Symbol  
++-++ . . . .  + (T) TH 
++-+ . . . . .  + (T) DH 
++-++- - -++ (~) 
++ . . . . . . .  + (~) S 
++--+-- -+4-  - (~) z 
4-4----4----4- (~) C 
4-+--4-4----+ (Z) t it  
?4-- - -+--++ (~)  a 
++--++--4-+ (~) SH 
++-4- . . . . . .  ( i )  ZH 
++-4-+-- -+- (u)  
++ . . . . . . . .  (e )  C 
4-+--4- . . . . .  (A) X 
++- -+ . . . .  + (7 )  ~:C 
+4-- -+-- -+-  (o)  H 
+4----+ . . . .  (~) k'w 
++- -++- -+-  (=) ~,.~ 
4---+ . . . . . .  (y )  ~,~ 
+--4-+-- -+-  (~) + 
+ . . . . . . . . .  (~) 
++- -++ . . . .  (o )  # 
+4-+ . . . .  4 - - -++- -  ( r )  \[ 
+++-- -++- -++- -  (I) \] 
+-+- - -+  . . . . . . .  (~) b 
+-+- - -4 - - - -+- - -  (o )  \]A 
+-?- - -+ . . . .  ?-+ ( f ) \] V 
+-+- - -+- - -++-+ (v )  !:; 
+-+- - -+- - -+-+-  ( '~ ) i~' 
+-+- - -+4-  . . . . . .  ( t )  , :  
4--4----??--?--- (~) 
+--+----.++------+---- 
+--+------++----++---- 
+--+--.--++----+--?-- 
+--+---.?+------+--+ 
+--?----.++----?+--+ 
+--+------++ . . . . .  + 
+ -++------+ . . . . .  ? 
+-4-+------+----+----+ 
4---4-4-------+------+-+ 
+--4-4-------+----4-+--+ 
+-+++ . . . . . . . . .  
4---++4- . . . . .  +------ 
+-++4-  . . . . . .  +--_ 
+ -4-4-4- . . . . .  +--+ -- 
4- . . . .  4- . . . . .  +---- 
4--+++------+ . . . . .  
+-4-4-+------+--+------ 
4---4-4-+------+----+---- 
-+-- 
----4- 
----+4- 
----+++ 
---4-+++ 
- -+++- -+ 
----+4+----+ 
---4-++------+ 
- -++4- . . . .  + 
Phonemic  
Un i t  
(e) 
(5) 
(n) 
(s) 
(z) 
(c) 
(~) 
(7) 
(~) 
(k) 
(g) 
(x) 
(rj) 
(h) 
(kW) 
(x") 
T~DIe  i: Un i t  Feature  Va lues  
-8 -  
In  order  to generate  computer ins t ruc t ions  as necessary  to man- 
ipu la te  the  va lues  in  the b inary  matr ix ,  the  ru les  as spec i f ied  above must 
be made compat ib le  wi th  the  requ i rements  of the  in terna l  log ica l  s t ruc ture  
of the  computer. This  i s  accompl ished through a compi la t ion  process  on 
the above ru les .  
A log ica l  mat r ix  M i s  de lcared  to have a length  of 50 columns, each 
column hav ing 20 e lements .  The J th  feature  in  the  I th  column i s  re fe r red  to 
wi th  the  notat ion  M( I , J ) .  The va lue  of each M( I , J )  may be e i ther  O or  1, 
represent ing  log ica l  Fa l se  or True ( the  feature  va lue - or  +) respectv ie ly .  
The input  s t r ing  ( the  form to be tes ted)  i s  then  s tored  as a pat tern  of 
features  in  the  tes t  mat r ix  M such that  each un i t  occup ies  one column of the 
matr ix ,  a l low ing  the ent ry  of a~7 s t r ing  of segments and boundar ies  up to 
length  50. The features  fo r  each un i t  are  s to red  in  the  cor respond ing  column 
of M by t rans fer r ing  the  va lues  from the appropr ia te  column of the prev ious ly  
de f ined  feature  matr ix  F. 
Symbols were chosen to have mnemonic va lue  re la t ing  to the features  
used. These symbols are  ass igned  va lues  corresponding to the row in  the matr ix  
F hav ing that  feature  va lue .  
Value Symbol Feature  Represented 
1 SEG segment 
2 VOC voca l i c  
3 CONS consonanta l  
4 ~ ~GH high 
5 ~CK hack 
6 LOW low 
7 ANT anterior 
8 COR corona l  
9 ROUND round 
I0 TENSE tease 
ii VOICE voice 
12 CONT cont inuant  
13 N1 NASAL nasa l  
14 STRID strident 
Table 2: Feature  Values in  Matr ix  Rows 
Severa l  more rows o f  the  matr ix  M are  de lcard  so that  they are  a-  
va i lab le  for  spec i f i ca t ion  of  d iacr i t i c  in fo rmat ion  about each un i t .  The 
number of  such spaces  i s  determined by the  dec la red  s i ze  of  20, the  column 
he ight .  Table 3 de f ines  s ix  addi~donal mat r ix  rows. 
Value Symbol D iacr i t i c  Represented 
15 FLAG 20 Rule 20 
16 FLAG 30 Rule 30 
17 FLAG 32 ' Rule 32 
18 FLAG ~ ~ule 
19 DMSR D (see Main Stress Rule) 
20 FVSR F (see Vowel Shift Rule) 
Table 3: Diacritic Feature Value in Matrix Rows 
-9 -  
A~ add i t iona l  row assoc ia ted  wi th  M i s  de lcared  to have length  ~0 
and e lements  which sa~ have ae~ in teger  va lue  (up to the computer word s i ze ) .  
This row has the  ~jmbol S and i s  used to s to re  the s t ress  va lue  ass igned  to 
each un i t .  The s t ress  on the I th  un i t  i s  re ferenced by the notat ion  S ( I ) .  
The va lue  O i s  in i t ia l l y  s to red  in  the  ar ray  S fo r  a l l  un i t s  entered ,  which 
represents  f - s t ress \ ]  fo r  a l l  un i t s .  This  i s  very convenient  from the po in t  
of  view of  the  programming language as an in teger  va lue  O i s  a l so  log ica l  0 
whi le  any in teger  va lue  greater  than zero i s  read as log ica l  1. I t  i s  p lan -  
ned a t  a la ter  date  to be ab le  to enter  a non-zero s t ress  va lue  fo r  any un i t  
in  the input  s t r ing .  
A w~7 was needed to store the information in the matrix representin 6 
boundary units and the syntactic bracketing of the input string. Because the 
previously described distinctive feature set has the common feature \[?segment\] 
it is clear thnt the positions in a column of the matrix representing this 
feature set need only be so defined when the first position has the value 
~?seEment\]. When the first element in a column has the value I-segment\] the 
next 13 spaces are in effect free to be defined so as to represent the boundary 
unit information. Thus a duplicate set of values are defined on the matrix 
as in Table 4. 
Value Symbol Feature Represented 
1 SEG segment 
2 FB formative boundary (i~) 
3 WB word boundary (WB) 
4 BRAC 10~e~ket 
5 HBRAC right bracket 
6 NBRAC noun bracket  
7 ABRAC adjective bracket 
8 VBRAC verb bracket 
9 SBRAC stem bracket 
i0 PBRAC pre f ix  b racket  
Table 4: Boundary Unit  Feature  Values i~  Matr ix  Rows 
Positions 4 through IO representing bracketin~ informatio~ are de- 
f ined  only in  case the feature  set  Fseg l  occurs  in  posi~on8 1 through 3- 
| -~  ~ - 
L+WB J 
Presence of bracketing4~(I,BRAo)-l)then implies occurrence of the word boundary 
#. At present, 4 spaces remain in the matrix column for addition of syntactic 
marker8 other than those defined here. 
When ent ry  of the segmental  form to be tes ted  i s  complete and be- 
fore  the  tes t  cyc le  i s  begun, the matr ix  pos i t ions  cor respond in  E to  the  
diacritics Rule n (FLAG 20 through FLAG 34) are set to i. 
At a po in t  w i th in  the tes t  sequence when the adjustment  ru les  have 
been applied, the test string is scanned and the bracketing is located. A 
pair of pointers, LEFT and RIGHT, are set to the left and right innermost 
brackets. If no brackets are specified in the input form, brackets are added 
- lO- 
to the le f t  and r ight  ends of the form as re ferents  fo r  these po in ters .  Cor- 
responding to the cyc l ic  order of  app l i ca t ion~ the phonological  ru les ,  
a l l  ru les  begin with environmental sc ratch  at  I~  and cont inue r ight  to 
RIGHT. This i s  accomplished in  the progr~ lance  ~th  n DO-E~ s ta te -  
ment pa i r  as fo l lows:  
DO I= LE~ TO RIQRT; 
? ~s  block of  cod~ i s  executed repeatedly  
? with I= LEFT, LEFT ?l, ~ +2, .... l~(~r; 
AD~ reference to I ~th in  the DO-loop range uses  the cur rent  value 
of  the var iab le  ~ for  that  repet i t ion  of  the loop. 
Because severa l  of  the ru les  needed for  the phonet ic  spec i f i ca t ions  
in  a ~mEunge requ i re  ~er t ion  or  de le t ion  of phonological  un i t s  in  the a t r ing ,  
i t  i s  des i rab le  to be able to pr in t  out the resu l t s  o f  the app l i ca t ion  of  an~ 
ru le  a f te r  that  ru le  has been appl ied to the s t r~.  Tl~a ab i l i ty  has been 
provided in  the present  program with the character~t ic  that  the resu l t s  ma~ 
be opt iona l ly  p r in ted  a f te r  the app l i ca t ion  of o~ ru le  in  the tes t  sequence. 
Rule Codin~ 
We m~ now conmider the codin K fo r  one of  the ru les  to be proKro~ed?  
In  ru le  32, Glide Voca~izat io~ we have the spec i f i ca t ion ;  
F i r s t )  the I th  un i t  must be checked to  see i f  i t  has the feature  
\ [4~e~ent \ ] ?  I f not ,  the scan i s  continued to the next tmit ?  I f  i t  does, 
a l so  cont inue the scan.  ~tL%s ~ represented by the fo~o~J J~ co~?  
DO I . LEFTTORI~ 
IF 7 M ( I ,Sg)  then go to  end 32 
IF M ( I ,C1) |7  M (IoB~) then go to end 32 
oeo  
end 32: end; 
(PL/1 uses the synbol  7 fo r  'I~OT" and 1 fo r  'DR") 
The ne~ step  i s  to determ~ the ~cur rence  of  the environment 
Y 
- l l -  
vent ion  that  any ru le  be in terpreted  as app l i cab le  in  the presence  of  the  
format ive  boundary +, which has the featuresF~ g l  in  any case  in  wh~h the 
L 
ru le  i s  o ther  ~8e app~ab le .  That i s ,  no ru le  should be b locked by the  pre -  
sence of + in  an7 context  where that  + i s  unmarked in  the  env i ronmenta l  con- 
d i t ions .  On the  o ther  hand, i f  the  + i s  marked in  the env i ronmenta l  spec i f i ca t in  
i t  must be present  in  the  s t r i~  before  that  ru le  i s  app l i cab le .  
From the preced~ d iscuss ion  we see that  the environment fo r  th i s  
ru le  must be in terpreted  as 
To re ference  an~ un i t  a f i xed  d i s tance  to the le f t  or  NOt  o f  the 
cur rent ly  scanned un i t  I ,  i t  would be poss ib le  to add or  subt rac t  a constant  
to the column po in ter  I .  That i s ,  M( I -1 , J )  would re ference  the  un i t  i lnned ia te ly  
to the le f t  of  l .  In  th i s  case ,  however, the  un i t  in  quest ion  may be e i ther  
1 or  2 spaces  to  the le f t  of  I ,  depending on whether the un i t  a t  I -1  has the 
features  ~-  seg 1 . Ac tua l ly ,  i t  i s  necessary  to check only  the f i r s t  2 features  
\ [~  ~, \ ]~-2t~e set ~ , \ ] .  is not defied i~ the , t  ?ocabu~Lr7 I~ Id ,  
be assumed not to oc?ur. A act of pointers is available to indicate the d~ 
tance Of the  des i red  un i t  f ron  the  cur rent ly  scanned un i t , L1  throughL9 fo r  
d i s tance  to the  le f t  andre  through I~ for  d i s tance  to the  r ight .  These po in ters ,  
when used in  a ru le ,  a re  in i t ia l l y  se t  to  1 a t  the  beEinning of  the  env i romlent~ 
search  in  each ~at r ix  pos i t ion?  With th i s  convent ion t T-L1 in i t ia l l y  re fe~l  to 
the un i t  immediate ly  to  the  le f t  of  the I th  un i t .  I f  the un i t  I -1  i s  found to  
have the features  o f  the  format ive  boundary + then L1 i s  8e~ equal  to  20 I - L  
now re fers  cor rec t ly  to  the  segment o be checked for  the env i ronmenta l  con- 
d i t ion  spec i f ied .  
DO I .  LEFT~O ~TC~T 
L1 - 1; 
IF  ~M(I,SE~) the  Eo to end 32; 
1F M(I,COL~ ~M(I,BACK) then end 32; 
IF  M(I -1,SEG) and M(I-1,FB) the  L1.2; 
-12- 
If M(I-LI,RODND)IZM(I-LI,HIGH) the go to end32; 
IV\] i s  def ined to be the coincidence of  the features  \ [+ vocal ic  1 
L- consoasntalJ 
which may be checked simply in  one statement,  while app l i ca t ion  of  t~is 
ru le  spec i f ies  the value assignment M(I ,voc)=l.  Fol lowing app l i ca t ion  
of the ru le  the pr in tout  opt ion f lags  are checked and i f  e i ther  i s  se t  
the corresponding pr in t  subrout ine i s  executed. The coding for  the ru le  
may now be completed. 
DO I:LEFT TO RIGNT; De6cr ipt ion 
Units to he scanned s tar t  
at  le f t -most  un i t ,  I=LEFT 
and include success ive 
units I=LEFT+I, I:LEFT+2, 
to right-most unit I=RIGHT 
L l - l ;  Set the po in ter  equal to 
1, at  un i t  to immediate 
le f t  of  I .  
IF'bM(I,SEG) the go to end32; I f  the cur rent ly  scanned 
un i t ,  I ,  i s  spec i f ied  as 
\[-segment\] o to next I 
(i.e. Ln+l). 
IF M(I,CONS) I~M(I,BACK) then go to 
end32; 
If scanned unit, I, is 
either \[+coasonantal\] or 
\[-backs ( i .e .  does not 
match the ru le  cond i t ion) ,  
go to the next un i t .  
IF~M(I-I,SEG) and M(I-I,FB) the LI~2; If the unit immediately to 
the left of I is specified 
as \[-segment\] and \[?FB\], 
then set  the po in ter  to 2 
( i .e .  I -L1 w i l l  re fe r  to 
two un i ts  to the le f t  of I ) .  
IFNIM(I-LI,SEG) the end32; I f  I-L1 i s  a \[-segment\] go 
to next un i t .  
IF M(I-LI,ROUND) ,=M(I-LI,HIGH) then 
go to end32; 
I f  the un i t  in  the le f t  en- 
vironment does not have the 
same feature  values fo r  
roundness and highness ( i .e .  
does not meet the rule 
condition, round, high), 
go to the next un i t .  
IF IM(I-LI,VOC ~M(I-LI,CO~) 
then go to end32; 
M(l, VOC)=I; 
PUT LIST ('RULE 32, At',I); 
PRINT '~32,AT" :I 
IF P(32,1) THEN CALL ST~OUT; 
IF P(32,2) THE~CALLMATOUT; 
E~D32: ~D;  
-13- 
I f  the  un i t  in  the  le f t -  
moat env i ronment  i s  e i ther  
I-vocalic3 or \[?consonantalJ 
(i.e. not a true vowel), 
go to the next unit. 
Al l  the  conditions have 
been satisfied; change 
the va lue  o f  the  feature  
\ [voca l i c~ from - to  + 
(i.e. apply Rule 32). 
I ns t ruct ion  to  pr in t  the 
rule number (R32) and 
state the matrix feature 
column to which it has 
been applied, i.e.I. 
If a display of the string, 
resulting from application 
of Rule 32 is desired, go 
to subroutine $TROUT. 
I f  a diapls~7 o f  the  matr ix  
resu l t in  E from app l i ca t ion  
o f  Rule 32  i s  des i red ,  go 
to  subrout ine  MATOUT. 
Scan un i t  Ln+l ,  where 
Lu = prev ious ly  scanned I .  
Co~i le r  Code Generat ion 
To i l l us t ra te ,  the  output  coding to  eva luate  a s imple r ight -  
handed context  of  the  form 
A -~B / - -  context  
w i l l  be eXa~nedo I t  w i l l  be seen that  th i s  cod i~ can be genera l i zed  to 
eva luate  a le f t -handed context  as  we l l .  I f  the  context  matching process  
i s  cons idered  to  be anchored a t  the  po in t  between the LH~ pos i t ion  marker 
and the  context  bo~y, then  con junct ive  and d i s junct ive  i tems fa r ther  to the 
r ight  in  the  context  m~y be t r ied  ~thout  rematch in  E i tems to  the i r  le f t  
in  the  context  s t r~.  This  would be t rue  even a f te r  the ru le  has been 
app l ied  to the carrent \ ] ,y  matched un i t  prov ided that  the matched un i t  i s  
aga in  tes ted  aga ins t  the  L~ a f te r  app l i ca t ion  of the ~ to that  un i t  and 
be fore  the  context  match cont inues .  
The run- t ime environment in  the  ob jec t  machine requ i res  a s ing le  
push-down s tack  and a few s imple  var iab le  s to r~e locat ions .  A tes t  s t r in~ 
i s  assumed to  be s tored  in  the  ob jec t  machine which ~a~ have been entered  
pr io r  to execut ion  of  the  ru le  match or  may be the resu l t  of  app l i ca t ion  of 
a p r io r  ru le  in  the  sys te .  
Th~ semant ic  fo r  match~n~ par t i cu la~ un i ts  in  the  tes t  s t r ing  ~1. l  
not be descr ibed~ but  w i l l  be abbrev ia ted  in  the  output  cod~ as 
~ A T C ~  ; EL~SGOTO ; 
which i s  taken  to  mean that  a Jump to  the ELSE ~O TO labe l  occurs i f  the 
spec i f ied  un i t  was not  success fu l l y  matched. Fur ther  abbrev ia t ions  in  the  
output  eod i~ are  in  the  app l i ca t ion  of  the  ~ of a r~e,  ~d~cated  by 
DO RULE; 
and in  the  dec la ra t ion  of  program b lock  and procedure s t ruc tures .  Other~se ,  
the  coding presented  const i tu tes  a va l id  PL/ I  program segment. 
~"~-~ the  cod i~ necessary  to eva luate  s imple  contextua l  ex- 
p ress ions  iuc lud~ an un-nested  i s junct ion  t i t  m~y be seen that  no loop-  
in~ back to  prev ious ly  matched un i t s  i s  necessary .  When the  le f t  paren-  
thes i s  i s  encountered the cur rent  locat ion  of  the  match po in ter ,  s to red  in  
the  var iab le  P, i s  saved.  I f  a~y subsequent  i tem match fa i l s  before  the  
r~ht  parenthes is  i s  encountered the po in ter  locat ion  i s  reset  to  the  saved 
va lue  and the  matching process  resunes  w i th  the  next  un i t  outs ide  the paren-  
thes i s .  The saved po in ter  locat ion  i s  e rased when the r iEht  parenthes is  
i s  encountered whether or  not the  d i s junct ive  i tem was success fu l l y  mat- 
ched. This  ~heme ach ieves  the  des i red  d i s junct iv i ty  qu i te  s imply in  that  
only one match i s  a t tempted .  I f  the  match of  un i t s  ins ide  the d i s junct ion  
succeeds ,  the  matching process  cont inues  normal ly .  I f  i t  fa i l s ,  the  en- 
c losed  s t r~ i s  e f fec t ive ly  ignored  and the ,match in  E process  cont inues  as 
be fore .  Th is  p rocess  lmy be made recurs ive  to any leve l  by sav ing  the 
po in ter  locat ion  in  s push-down s tack ,  f ree ing  the  top s tack  i tem when a 
-15- 
r iEht  parenthes is  i s  encountered. Such a stack ~ eas i ly  he implemented 
in  PL/ I  by us ing the CORTROLL~ form of dyna~? storage a l locat ion  for  a 
var iab le  -~  A new leve l  in  the stack i s  secured with the statement 
ALLOCATE STK;, sav i~ all previous values. The top level is erased with 
the statement FR~ STK;t br ingin 6 the previous value into. access ib i l i ty .  
In  the coding examples presented below, two var iab les ,  LEFT -nd 
RIGHt, are assumed to conta in the cur rent ly  appl icable le f t  and r ight  l im i t~ 
for  matching the tes t  s t r ing .  These wi l l  he set  by scanning the tes t  s t r ing  
to locate  the innermost syntact ic  brackets or  other  such tes t  S~r i~ de l imi ters .  
The index var iab le  N w i l l  be used to ind icate the le f t -most  end of the match- 
ing process ;  in  th i s  case, the anchoring po int  fo l lowing the LHS pos i t ion  
marker. The statement MATCH UNIT __; EI~E GO TO __; is assumed to in- 
crement the current match pointer P and fail at any time the value of P 
eXceeds the right delimiter value, stored in RIGHT? 
The codil~ to evaluate a context of the form 
RULEN: A - ,B / - -  C D (E (Y G ) HJ) K 
would have the  fo l lowing appearance. 
tulLE: DO I-.LEFT TO HIGHT; 
P=-I; 
IF  MATCH UNIT A; ELSE GO TO NEXT; 
IF MATCH UNIT C; EI~E GO TO NEXT; 
IF  MATCH UNIT D; ELSE GO TO NEXT; 
ALLOCATE STK; 
STK-p; 
IF MA~H UNIT E; ELSE GO TO PN1; 
AMECATE STK; 
~K- ;  
IF MATCH UNIT F; ~SEGO TO PN2; 
IF MATCH UNIT G; ~ GO TO PN2; 
GOTO SK2; 
PN2: paSTE; 
SK2: FREE STK; 
IF  MATCH UNIT H; ~E GO TO PN1; 
IF MATCH UNIT I ;  ELSE GO TO PN1; 
GO TO SK1; 
PNI: P=STE; 
SKI: FREE STE; 
IF MATCH UNIT J~ ELSE GO TO HEXT; 
DO RULE; 
m~T: ~D ~LEN; 
The attempt to formulate the coding to evaluate a context  iac lud i~ 
a conjunct ive ser ies  br i~  to l iEht  a d i f fe rent  type of  problem. I t  i s  not 
poss ib le  &o re tch  un i ts  from le f t  to r ight  in  an order ly  fash ion as fox 
simple or  d i s junct ive  contexts .  Once a match for  the ent i re  s t~ ing  has been 
attempted t t s i~  the f i r s t  item of  the conjunct ive ser ies ,  i t  i s  necessary,  
5,  
-16- 
whether the ru le  was app l ied  or  not ,  to  reset  the  cur rent  match po in ter  to 
i t s  va lue  at  the t ime the le f t  b racket  was encountered,  and then cont inue 
the matching process  us ing  the un i t s  of the  second con junct ive  i tem as the  
matching pat terns .  In  order  to loop back in  th i s  manner, i t  i s  necessary  
to save three  va lues  dur ing  a matching pass  over the  st~ng;  1) The bracket -  
pa i r  number, 2) The po in ter  va lue  a t  the  t ime the le f t  b racket  i s  encountered,  
and 3) The i tem number w i th in  the  bracket  pa i r .  These three  va lues  are 
saved in  the push-down s tack  in  the  order  l i s ted  when the con junct ive  ser ies  
match i s  begun. I t  i s  conven ient  in  the  PL/ I  ~ e  to  accompl ish the 
branching by using the stacked values as subscript values in an assiEned- 
label GD TO statement. The labels ITS4(1,1):, ITEM(I,2):, IT~4(1,3):, .... 
are attached to the statements in the coding which perform the pointer 
reset following matching of the corresponding conjunctive items. BranchinE 
is accomplished with the statement GO TO IT~(I,J); following the proper 
assignment of values to the variables I and Jo 
An initial value of zero is put in the stack prior to rule evaluation. 
The stack is then checked for a non-zero top item before it is unstacked 
for label assignment and an empty stack indicates that all conjunctive items 
in the rule have been used in the matching process. If the stack is not 
empty, the top two items are unstacked and stored as the variables J and P 
respect ive ly .  The remain ing top s tack  i tem i s  accessed and the va lue s tored  
in  the var iab le  I~ but  i t  i s  not f reed  from the  s tack .  The va lue  of  P must 
then  be res tored  to the  s tack  ~o i t  w i l l  be handled proper ly  by the end- o f -  
i tem cod ing.  The deta i l s  of th i s  scheme may be seen in  the  fo l low i~ example, 
coded to eva luate  a context  of  the  form 
~LE J: A -)B / -- c ~ j  
RULE J: 
D~GLARE IT~4(I,3) LABEL; 
ALLOCATE S~;  
STK=O; 
DO N-_LEFT TO EIGEr; 
P-_N; 
IF MATCH UNIT A; ELSE GO TO NEXT; 
IF MATCH UNIT C; ELSE GO TO NEXT; 
AIJ~OCATE ~TK; 
~TK=I; 
ALLOCATE STK; 
STK.P; 
ALLOCATE STK; 
3TK:I; 
IF MATCH UNIT D; ELSE TO TO B l l ;  
IF MATCH UNIT E~ ELSE GO TO BII| 
GO TO BRI; 
BII: J-STK; 
FREE STK; 
P=STK; 
ITEM(I,1): ALIECATE STK; 
STK~J + i; 
IF MATCH UNIT F; ~ GO TO BI2; 
IF MATCH UNIT @; ELSE GO TO \]@12; 
-17- 
IF MATCH UNIT H;ELSE GO TO BI2; 
GO TO BRI; 
BI2: J=STK; 
FREE STK; 
P-_STK; 
ITEM(I,2): ALLOCATE STK; 
STK--J + i; 
IF MAT~ UNIT Xl ~ GO TO B1.31 
aO TO BEI.i 
~1.~1 ~ STK I 
i I IEil STK I 
eO TO NEXT I 
BBI: IF ~TCH UNIT J; ELSE GO TO NE~T; 
DO RULE; 
h~T:  IF STK.OTHEN GO TO SCAN; 
J=STK; 
FREE STK; 
P=3TK; 
FREE STK; 
I=STK; 
ALLOCATE STK; 
STK-_p; 
GO TO ITE~(I,J); 
SCAN: E~D RULEJ; 
A further complication arises when a conjunctive series is embedded 
inside of a disjunction. Specifically, the pointer location should not be 
reset to the value stored in the stack for a~y failure to match the internal 
sequence of units, but onl~ if the match fails for all items in the embedded 
con junct ive  ser ies .  Because the las t  con junct ive  i tem may fa i l  to  match, 
whi le  a p rev ious ly  tes ted  i tem matched success fu l l y ,  i t  i s  necessary  to use 
a '~ l le  app l ied"  f lag ,  which i s  c leared  ( reset )  wbe,- enter ing  the match of  
a d i s junct ion  and set  by any app l i ca t ion  of the  ru le .  The set t ing  of  th i s  
f lag  determines  the ac t ion  taken concern ing the po in ter  se t t ing  on ex i t  from 
the d i s junct ion ,  when a l l  con junct ive  i tems have been t r ied .  
The Compilim~ Process 
It m~y be seen from the coding examples given that the output from 
the coeq~iler occurs essentially in ~he same order as the symhols in the 
linear input form, suggesting that a preliminary stage of syntactic analysis 
is unnecessary. It is only necessary to save the ~ specification in the 
compiler from the time it is input u~til it is output in coded form at the 
end of the context coding. Observing the three different types of failure- 
to-match ex i t  branches,  i t  appears that  the  most d i rec t  so lu t ion  i s  a th ree-  
s ta te  tab le  dr iven  t rans la tor  used in  con junct ion  wi th  a number of  ind ices  
de f ined  dur ing  the  compi l ing operat ion  fo r  the purpose of  count ing  brackets  
and parenthes is ,  8enerat ing  sequent ia l  abe ls ,  e tc .  Ent r ies  in  the  tab le  
ind icate  fo r  each of  the three  s ta tes  what output  coding should  be generated  
and what compi le r  index operat ions  should be car r ied  out as a resu l t  of  each 
possible input symbol. 
The table and listing of compiler actions shown below specifies a 
compiler system capable of producing PL/l coding such as shown in the 
examples.  Notat ions  used in  the  compi ler  tab le  and act ion  spec i f i ca t ions  
-18-  
are  exp la ined  br ie f ly .  
1. Upper-case le t te rs  in  the output  are output  as shown. 
2. Lower-case le t te rs  in  the output  represent  compi ler  var iab les  
~for  which the cur rent ly  ass igned  va lue  i s  output .  
3- Abbreviated output  coding has the  meaning d i scussed  above, for  
example, DO RULE expressed the codin~ necessary  to incorporate  
in to  the marked un i t  in  the  tes t  s t r ing  the  character i s t i cs  or 
features  g iven  as the  ~ of  the  ru le .  
4. The s ta te  t rans fer  from s ta te  2 on input  of  a r ight  parenthes is  
i s  a cond i t iona l  t rans fer ,  depending on the va lue  of the  com- 
p i le r  var iab le  mo The tes t  i s  shown as a four th  pseudo-s ta te .  
5- Compiler in i t ia l i za t ion ,  ahown as s ta te  O, mast be accompl ished 
a t  the beg inn ing  of compi la t ion  fo r  each ru le .  
6. Three of the  input  ac t ions  are  ident ica l  fo r  a l l  s ta tes ,  in -  
d ica t ing  that  i t  i s  unnecessary  to s to re  those ac t ions  in  the 
s ta te  tab le .  
7. No ac t ion  i s  spec i f ied  fo r  e r ro r  inputs .  I t  i s  assumed that  
the  compi ler  would respond wi th  some ind icat ion  of  the  t roub le ,  
fo r  example, a comma input  when in  s ta te  2 could cause the 
reply '~omma illegal inside parenthesis"? 
The compi ler  uses  seven var iab les ,  four  of  them, i , j , k  and 1, as 
push-down s tacks  wi th  the  CONTHOLT.E~ at t r ibute ,  and three ,  m,n and o as 
simple variables. 
Compiler State Tabl e 
State  
E~OF 
- -  uni__! ___E _~ ~ C__ ___~ LU~ 
O. Action: Allocate i; i=I; n.O; o~0; 
Next S ta te :  1 
i. Act ion:  1 4 5 6 7 9 i0 
Next State: 1 3 3 1 2 1 0 
2. Action: 2 4 error error 7 8 iO 
Next State: 2 3 2 4 0 
3- Action: 3 4 5 6 7 error i0 
Next State: 3 3 3 1 2 0 
4. Action: 
Next S ta te :  
Cond i t iona l  t rans fer  s ta te ,  no input ;  
I f  m_-O then go to  s ta te  1 . ,  e l se  go to  s ta te  2. 
-19- 
Compiler Actions 
Action Compiler 
number Operat ions 
1. Output " 
2. Output " 
3. Output " 
4. n=n*l 
Allocate i; 
i=n; 
Allocate j ; 
j=i; 
l=l?l; 
m=O; 
Output 
Output 
Output 
5- Output 
Output 
Output 
j=j+l; 
6. l=l-1; 
Output 
Output 
Output 
If I)O then go to 6a. 
Output " 
Output " 
6a. Output " 
Output '~Ri: " 
FREE i ;  
FREE j ;  
7. o=o,i; 
Al locate k; 
k=o; 
Al locate 1; 
i=O; 
m=m+l; 
Output " 
Output 
8. Free I; 
m-m-l; 
Output " 
Output '?Nk: 
Output '~Kk: 
Free k; 
Output Code 
IF MATCH UNIT __; ELSE GO TO NE~T; " 
IF MATCH UNIT __; ELSE GO TO PNk; " 
IF MATCH UNIT  __; ELSE GO TO Bij ; " 
ALLOCATE STK~ STK=i; " 
ALLOCATE STK; STK_-P; " 
"ALLOCATE STK~ STK=I; " 
" GO TO BRi;" 
'Bij : J=STK; FREE STK~ P:STK; " 
'~TEM(i,J ): ALLOCATE ST\](; STK=~+l; " 
" GO TO BRi; " 
'BiJ : FREE STK; 
'~TEM(i,j): FREE STK; FREE STK;" 
IF FLAG_-O THEN GO TO PNk;" 
FREE STK; " 
GD TO NEXT;" 
ALLOCATE STK; STK_-O; ' ?  
FLAG=o; " 
GO TO SKk; " 
P=STK; " 
FREE STK; " 
-20- 
9. 
i0. 
Free 1; 
Output " GO TO SKk;" 
Output '~Nk: p-ST~; FREE STK;" 
Output  '~k :  " 
Free k; 
Free 1; 
Output " DO RULE;FLAG=l; " 
Output 'REXT: IF  STK_-O THEN GO TO SCAN; " 
Output " J=STK;FREE STK; " 
output  " P=-~TK;FREE STK; " 
output  " I~STK;ALLOCATE STK;STK~P; " 
Output " GO TO ITEM(I , J ) ;  " 
Output 'BCAN: ~D RULE; " 
The Genera l i t~  of  the  Process  
The only  re ferences  to le f t - r ight  d i rec t iona l i ty  in  the matching 
scheme descr ibed  are  in  the  le f t  to  r ight  scan of  the cur rent  L~ marker 
in  a t tempt ing  to f i t  the tes t  s t r ing  and in  the  assumption that  the  coding 
fo r  matching par t i cu la r  un i t s  ~ncluded an ins t ruc t ion  to increment he 
matching locat ion  po in ter ,P .  A le f t -handed context  m~7 be eva luated  by 
s imi la r  coding by le t t ing  the  pat tern  match move from the L~ outward, 
i .e . ,  to the  le f t .  The same compi l ing  system can be used by revers ing  
the symbols of  the  le f t -hand  context  dur ing the  in i t ia l  l i near i za t ion ,  
subst i tu t ing  le f t  fo r  r ight  and r ight  fo r  le f t  b rackets  and parenthes is .  
Thus, a ru le  of  the  form 
A- ,B  / EF(G)H --I ~ 
L~J  
would appear in the linear format as 
A - ,B  / H(G)FE -- I\[J,K\]+ 
An additional dimension would be added to the compiler state table t 
providing for the productio= of unit match coding which would decrement 
instead of incrementing the current matching pointer. The L~S marker would 
s t i l l  scan the tes t  s t r ing  from le f t  to  r ight .  I f  the L~ marker occurred 
w i th in  the i tems of a co .unct ion ,  separate  coding would have to be pro-  
duced fo r  the le f t  and r ight  par ts  of  each i tem.  The deta i l s  of  the  match- 
ing  process  fo r  th i s  case  have not  been worked out,  but do not appear to 
p resent  any major d i f f i cu l t ies  fo r  the  system presented  here .  
-21- 
? Bibliograpb,y 
1? 
2e 
3. 
B la i r ,  F. ,  Programming of the Grsmsar Tester in  Spec i f icat ion  and 
Ut i l i za t ion  of a Transferaat ional  G ~ ,  Sci .  Rep? 1, IBM Corp? 
Iorktown Hts. New York, 1966 
Friedman, Joyce, A Co~uter  System for TransforNational Grammar. 
Cos~uter Sci.  Rep. CS-~ AF-21, Stanford, Ca., Jan. 1968 
Gross, L.N., On-Line Prograe~ng System User 's  Manual MTP-~, The 
MITRE Corp., Bedford, Mass., March 1967 
4. Londe, D. and Schoene, We, TGT, Transformational Grammar Tester,  
~4-3759/0OO/00, System Development Corpo. Santa N~nica, Ca., 1967 
5- Ch~,  Noam, The Sound Pattern of English, Harper and Row, N.Y., 1968 
6. Kurd ,  S.-Y., Yawe l~ Phonolo~, MIT Press,  Cambridge, 1967 
7- Schachter, Paul and Fromkin, Victor ia,  A Phonolo~ of Akan: Akuapem, 
Asante and Fante, Workin~ Papers in Phonetics No. 9, UCLA, August 1968 
8. Bobrow, D.G. and Fraser,  Brice, The Phonological Rule Tester ,  Cos?  ACM, 
Tel 11, no 11, November 1968 
9. Ri?e, D. Lloyd, and Hofshi, Reuben, An In teract ive  Phonological /bale 
Tester,  WorkinK Papers in Phonetics m No. 10, UC~, Dec. 1968 
I0. ~ ,  Roam. Some General Properties of Phonological Rules, LanEu~e 
.oi b3 no 1, March 1967 
11. K~I ,  J . P . ,  Conjunctive Stacks and Dis junct ive Sequences in  Ls~e 
Ch~,  ~mu~terly Prog. Rep. Research Lab? of E lectron ics ,  No? 88, 
Mmm. Im~t. of Technology. Jan.  1968 

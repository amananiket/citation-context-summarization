Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, pages 352?361,
Singapore, 6-7 August 2009.
c
?2009 ACL and AFNLP
A Bayesian Model of Syntax-Directed Tree to String Grammar Induction
Trevor Cohn and Phil Blunsom
School of Informatics
University of Edinburgh
10 Crichton Street, Edinburgh EH8 9AB
Scotland, United Kingdom
{tcohn,pblunsom}@inf.ed.ac.uk
Abstract
Tree based translation models are a com-
pelling means of integrating linguistic in-
formation into machine translation. Syn-
tax can inform lexical selection and re-
ordering choices and thereby improve
translation quality. Research to date has
focussed primarily on decoding with such
models, but less on the difficult problem of
inducing the bilingual grammar from data.
We propose a generative Bayesian model
of tree-to-string translation which induces
grammars that are both smaller and pro-
duce better translations than the previous
heuristic two-stage approach which em-
ploys a separate word alignment step.
1 Introduction
Many recent advances in statistical machine trans-
lation (SMT) are a result of the incorporation of
syntactic knowledge into the translation process
(Marcu et al, 2006; Zollmann and Venugopal,
2006). This has been facilitated by the use of syn-
chronous grammars to model translation as a gen-
erative process over pairs of strings in two lan-
guages. Such models are particularly attractive
for translating between languages with divergent
word orders, such as Chinese and English, where
syntax-inspired translation rules can succinctly de-
scribe the requisite reordering operations. In con-
trast, standard phrase-based models (Koehn et al,
2003) assume a mostly monotone mapping be-
tween source and target, and therefore cannot
adequately model these phenomena. Currently
the most successful paradigm for the use of syn-
chronous grammars in translation is that of string-
to-tree transduction (Galley et al, 2004; Zollmann
and Venugopal, 2006; Galley et al, 2006; Marcu
et al, 2006). In this case a grammar is extracted
from a parallel corpus, with strings on its source
side and syntax trees on its target side, which is
then used to translate novel sentences by perform-
ing inference over the space of target syntax trees
licensed by the grammar.
To date grammar-based translation models have
relied on heuristics to extract a grammar from a
word-aligned parallel corpus. These heuristics are
extensions of those developed for phrase-based
models (Koehn et al, 2003), and involve sym-
metrising two directional word alignments fol-
lowed by a projection step which uses the align-
ments to find a mapping between source words and
nodes in the target parse trees (Galley et al, 2004).
However, such approaches leave much to be de-
sired. Word-alignments rarely factorise cleanly
with parse trees (i.e., alignment points cross con-
stituent structures), resulting in large and implau-
sible translation rules which generalise poorly to
unseen data (Fossum et al, 2008). The principal
reason for employing a grammar based formal-
ism is to induce rules which capture long-range
reorderings between source and target. However
if the grammar itself is extracted using word-
alignments induced with models that are unable
to capture such reorderings, it is unlikely that the
grammar will live up to expectations.
In this work we draw on recent advances in
Bayesian modelling of grammar induction (John-
son et al, 2007; Cohn et al, 2009) to propose a
non-parametric model of synchronous tree substi-
tution grammar (STSG), continuing a recent trend
in SMT to seek principled probabilistic formula-
tions for heuristic translation models (Zhang et al,
2008; DeNero et al, 2008; Blunsom et al, 2009b;
Blunsom et al, 2009a). This model leverages a
hierarchical Bayesian prior to induce a compact
translation grammar directly from a parsed paral-
lel corpus, unconstrained by word-alignments. We
show that the induced grammars are more plausi-
ble and improve translation output.
This paper is structured as follows: In Section
352
2 we introduce the STSG formalism and describe
current heuristic approaches to grammar induc-
tion. We define a principled Bayesian model of
string-to-tree translation in Section 3, and describe
an inference technique using Gibbs sampling in
Section 4. In Section 5 we analyse an induced
grammar on a corpus of Chinese?English trans-
lation, comparing them with a heuristic grammar
in terms of grammar size and translation quality.
2 Background
Current tree-to-string translation models are a
form of Synchronous Tree Substitution Grammar
(STSG; Eisner (2003)). Formally, a STSG is a
5-tuple, G = (T, T
?
, N, S,R), where T and T
?
are sets of terminal symbols in the target and
source languages respectively, N is a set of non-
terminal symbols, S ? N is the distinguished
root non-terminal and R is a set of productions
(a.k.a. rules). Each production is a tuple compris-
ing an elementary tree and a string, the former
referring to a tree fragment of depth ? 1 where
each internal node is labelled with a non-terminal
and each leaf is labelled with either a terminal or
a non-terminal. The string part of the rule de-
scribes the lexical component of the rule in the
source language and includes a special variable for
each frontier non-terminal in the elementary tree.
These variables describe the reordering and form
the recursion sites in the generative process of cre-
ating tree and string pairs with the grammar. For
example, the rule
?(NP NP 1 (PP (IN of) NP 2 )), 2 ? 1 ? (1)
rewrites a noun-phrase (NP) as a NP and prepo-
sitional phrase (PP) headed by ?of? in the target
language. The rule generates the token ??? in
the source and reverses the order of the two child
noun-phrases, indicated by the numbering of the
variables in the string part.
A derivation creates a (tree, string) pair by start-
ing with the root non-terminal and an empty string,
then choosing a rule to rewrite (substitute) the non-
terminal and expand the string. This process re-
peats by rewriting all frontier non-terminals until
there are none remaining. A Probabilistic STSG
assigns a probability to each rule in the grammar.
The probability of a derivation is the product of
the probabilities of its component rules, and the
probability of a (tree, string) pair is the sum of the
probabilities over all its derivations.
2.1 Heuristic Grammar Induction
Grammar based SMT models almost exclusively
follow the same two-stage approach to gram-
mar induction developed for phrase-based meth-
ods (Koehn et al, 2003). In this approach they
induce a finite-state grammar with phrase-pairs as
rules by taking a sentence aligned parallel cor-
pus and 1) predicting word alignments before 2)
extracting transduction rules that are ?consistent?
with the word aligned data. Although empiri-
cally effective, this two stage approach is less than
ideal due to the disconnect between the word-
based models used for alignment and the phrase-
based translation model. This is problematic as the
word-based model cannot recognise phrase-based
phenomena. Moreover, it raises the problem of
identifying and weighting the rules from the word
alignment.
The same criticisms levied at the phrase-based
models apply equally to the two-stage technique
used for synchronous grammar induction (Galley
et al, 2004; Zollmann and Venugopal, 2006; Gal-
ley et al, 2006; Marcu et al, 2006). Namely that
the word alignment models typically do not use
any syntax and therefore will not be able to model,
e.g., consistent syntactic reordering effects, or the
impact of the syntactic category on phrase transla-
tions. The identification and estimation of gram-
mar rules from word aligned data is also non-
trivial. Galley et al (2004) describe an algorithm
for inducing a string-to-tree grammar using a par-
allel corpus with syntax trees on target side. Their
method projects the source strings onto nodes of
the target tree using the word alignment, and then
extracts the minimal transduction rules as well as
rules composed of adjacent minimal units. The
production weights are estimated either by heuris-
tic counting (Koehn et al, 2003) or using the EM
algorithm. Both estimation techniques are flawed.
The heuristic method is inconsistent in the limit
(Johnson, 2002) while EM is degenerate, placing
disproportionate probability mass on the largest
rules in order to describe the data with as few a
rules as possible (DeNero et al, 2006). With no
limit on rule size this method will learn a single
rule for every training instance, and therefore will
not generalise to unseen sentences. These prob-
lems can be ameliorated by imposing limits on
rule size or early stopping of EM training, how-
ever neither of these techniques addresses the un-
derlying problems.
353
In contrast, our model is trained in a single step,
i.e., the alignment model is the translation model.
This allows syntax to directly inform the align-
ments. We infer a grammar without resorting to
word alignment constraints or limits on rule size.
The model uses a prior to bias towards a compact
grammar with small rules, thus solving the degen-
eracy problem.
3 Model
Our training data comprises parallel target trees
and source strings and our aim is to induce a STSG
that best describes this data. This is achieved
by inferring a distribution over the derivations for
each training instance, where the set of derivations
collectively specify the grammar. In the follow-
ing, we denote the source trees as t, target strings
s, and derivations r which are sequences of gram-
mar rules, r.
As described in section 2.1, previous methods
for estimating a STSG have suffered from degen-
eracy. A principled way to correct for such degen-
erated behaviour is to use a prior over rules which
biases towards small rules. This matches our intu-
ition: we expect good translation rules to be small,
with few internal nodes, frontier non-terminals
and terminal strings. However, we recognise that
on occasion larger rules will be necessary; we al-
low such rules when there is sufficient support in
the data.
We model the grammar as a set of distributions,
G
c
, over the productions for each non-terminal
symbol, c. We adopt a non-parametric Bayesian
approach by treating eachG
c
as a random variable
with a Dirichlet process (DP) prior,
r|c ? G
c
G
c
|?
c
, P
0
? DP(?
c
, P
0
(?|c)) ,
where P
0
(?|c) (the base distribution) is a distribu-
tion over the infinite space of trees rooted with c,
and ?
c
(the concentration parameter) controls the
model?s tendency towards either reusing existing
rules or creating novel ones as each training in-
stance is encountered (and consequently, the ten-
dency to infer larger or smaller grammars). We
discuss the base distribution in more detail below.
Rather than representing the distribution G
c
ex-
plicitly, we integrate over all possible values ofG
c
.
This leads to the following predictive distribution
for the rule r
i
given the previously observed rules
r
?i
= r
1
. . . r
i?1
,
p(r
i
|r
?i
, c, ?
c
, P
0
) =
n
?i
r
i
+ ?
c
P
0
(r
i
|c)
n
?i
c
+ ?
c
, (2)
where n
?i
r
i
is the number number of times
r
i
has been used to rewrite c in r
?i
, and
n
?i
c
=
?
r,R(r)=c
n
?i
r
is the total count of rewrit-
ing c (hereR(r) is the root non-terminal of r). The
distribution is exchangeable, meaning that all per-
mutations of the input sequence are assigned the
same probability. This allows us to treat any item
as being the last, which is fundamental for efficient
Gibbs sampling. Henceforth we adopt the notation
r
?
and n
?
to refer to the rules and counts for the
whole data set excluding the current rules under
consideration, irrespective of their location in the
corpus.
The base distribution, P
0
, assigns a prior prob-
ability to an infinite number of rules, where each
rule is an (elementary tree, source string) pair de-
noted r = (e,w). While there are a myriad of
possible distributions, we developed a very sim-
ple one. We decompose the probability into two
factors,
P
0
(e,w|c) = P (e|c)P (w|e) , (3)
the probability of the target elementary tree
and the probability of the source string, where
c = R(r).
The tree probability, P (e|c) in (3), is modelled
using generative process whereby the root cate-
gory c is expanded into a sequence of child non-
terminals, then each of these are either expanded
or left as-is. This process continues until there
are no unprocessed children. The number of child
nodes for each expansion is drawn from a geo-
metric prior with parameter p
child
, except in the
case of pre-terminals where the number of chil-
dren is always one. The binary expansion deci-
sions are drawn from a Bernoulli prior with pa-
rameter p
expand
, and non-terminals and terminals
are drawn uniformly from N and T respectively.
For example, the source side of rule (1) was gen-
erated as follows: 1) the NP was rewritten as two
children; 2) an NP; and 4) a PP; 5) the NP child
was not expanded; 6) the PP child was expanded;
7) as an IN; and 8) a NP; 9) the IN was expanded to
the terminal ?of?; and 10) the final NP was not ex-
panded. Each of these steps is a draw from the rel-
evant distribution, and the total probability is the
product of the probabilities for each step.
354
Hong/NNP Kong/NNP
?? ? ? ? ? ?? ? ?? ? ?? ?
S
NP
VP ./.
NP PP
Every/DT corner/NN of/IN NP
is/VBZ VP
filled/VBN PP
with/IN NP
fun/NN
0 1 2 3 4 5 6 7 8 109 11
[2,3)
[2,6)
[3,6) [0,1)
[0,2)
[0,11)
[10,11)[6,10)
[6,10)
[7,9) [9,10)
[9,10)
?
?
? ? ? ?
?
Figure 1: Example derivation. Each node is annotated with their span in the target string (aligned nodes are shaded). The dotted
edges show the implied alignments. Preterminals are displayed with their child terminal in the leaf nodes.
The second factor in (3) is P (w|e), the prob-
ability of the source string (a sequence of source
terminals and variables). We assume that the el-
ementary tree is generated first, and condition the
string probability on l = F (e), its number of fron-
tier nodes (i.e., variables). The string is then cre-
ated by choosing a number of terminals from a ge-
ometric prior with parameter p
term
then drawing
each terminal from a uniform distribution over T
?
.
Finally each of the l variables are inserted into the
string one at a time using a uniform distribution
over the possible placements. For the example rule
in (1) the generative process corresponds to 1) de-
ciding to create one terminal; 2) with value ?; 3)
inserting the first variable after the terminal; and
4) inserting the second variable before the termi-
nal. Again, the probability of the string is simply
the product of the probabilities for each step.
Together both the factors in the base distribu-
tion penalise large trees with many nodes and long
strings with many terminals and variables. P
0
de-
creases exponentially with rule size, thus discour-
aging the model from using larger rules; for this
to occur the rules must significantly increase the
likelihood.
4 Training
To train our model we use Gibbs sampling (Geman
and Geman, 1984), a Markov chain Monte Carlo
method (Gilks et al, 1996) in which variables are
repeatedly sampled conditioned on the values of
all other variables in the model.
1
After a period of
burn-in, each sampler state (set of variable assign-
ments) is a sample from the posterior distribution
of the model. In our case, we wish to sample from
the posterior over the grammar, P (r|t, s, ?).
To simplify matters we associate an alignment
variable, a, with every internal node of the trees
in the training set. This variable specifies the span
of source tokens to which node is aligned. Alter-
natively, the node can be unaligned, which is en-
coded as an empty span. I.e. a ? (J ? J) ? ?
where J is the set of target word indices. Spans
are written [i, j): inclusive of i and exclusive of
j. Each aligned node (a 6= ?) forms the root
of a rule as well as being a frontier non-terminal
of an ancestor rule, while unaligned nodes form
part of an ancestor rule.
2
The set of valid align-
ments are constrained by the tree in a number of
ways. Child nodes can be aligned only to sub-
spans of their ancestor nodes? alignments and no
two nodes? alignments can overlap. Finally, the
root node of the tree must be aligned to the full
1
Previous approaches to bilingual grammar induction
have used variational inference to optimise a bound on the
data log-likelihood (Zhang et al, 2008; Blunsom et al,
2009b). Both these approaches truncated the grammar a pri-
ori in order to permit tractable inference. In contrast our
Gibbs sampler can perform inference over the full space of
grammars. See also Blunsom et al (2009a) where we present
a Gibbs sampler for inducing SCFGs without truncation.
2
The Gibbs sampler is an extension of our sampler for
monolingual tree-substitution grammar (Cohn et al, 2009),
which used a binary substitution variable at each node to en-
code the segmentation of a training tree into elementary trees.
355
?(S (NP NP 1 PP 2 ) VP 3 . 4 ), 2 1 3 4 ?
?(NP DT 1 NN 2 ), 1 2 ?
?(DT Every),??
?(NN corner),?????
?(PP (IN of) NP 1 ), 1 ??
?(NP (NNP Hong) (NNP Kong)),???
?(VP (VBZ is) VP 1 ), 1 ?
?(VP VBN 1 PP 2 ),? 1 2 ?
?(VBN filled),???
?(PP (IN with) (NP NN 1 )), 1 ?
?(NN fun),??
?(. .),??
Table 1: Grammar rules specified by the derivation in Fig-
ure 1. Each rule is shown as a tuple comprising a tar-
get elementary tree and a source string. Boxed numbers
show the alignment between string variables and frontier non-
terminals.
span of source words.
Collectively, the training trees and alignment
variables specify the sequence of rules r, which
in turn specify the grammar. Figure 1 shows an
example derivation with alignment variables. The
corresponding STSG rules are shown in Table 1.
4.1 Gibbs operators
The Gibbs sampler works by sampling new val-
ues of the alignment variables, using two differ-
ent Gibbs operators to make the updates. The first
operator, EXPAND, takes a tree node, v, and sam-
ples a new alignment, a
v
, given the alignments of
all other nodes in the same tree and all other trees
in the corpus, denoted a
?
. The set of valid la-
bels is constrained by the other alignments in the
tree, specifically that of the node?s closest aligned
ancestor, a
p
, its closest aligned descendants, a
d
,
and its aligned siblings, a
s
(the aligned descen-
dants of a). The alignment variable may be empty,
a
v
= ?, while non-empty values must obey the
tree constraints. Specifically the span must be a
subspan of its ancestor, a
v
? a
p
, subsume its de-
scendants, a
v
?
?
a
d
, and not overlap its siblings,
j 6?
?
a
s
,?j ? a
v
. Figure 2 shows an exam-
ple with the range of valid values for corner/NN?s
alignment variable and the corresponding align-
ments that these encode.
Each alignment in the set of valid outcomes de-
fines a set of grammar rules. The non-aligned out-
come results in a single rule r
p
rooted at ancestor
node p. While the various aligned outcomes re-
? ? ? ??
NP
Every/DT corner/NN
2 3 4 5
[2,3)
[2,6)
[3,6)
? ? ? ??
NP
Every/DT corner/NN
2 3 4 5
[2,3)
[2,6)
[4,6)
? ? ? ??
NP
Every/DT corner/NN
2 3 4 5
[2,3)
[2,6)
[5,6)
? ? ? ??
NP
Every/DT corner/NN
2 3 4 5
[2,3)
[2,6)
? ? ? ??
NP
Every/DT corner/NN
2 3 4 5
[2,3)
[2,6)
[4,5)
? ? ? ??
NP
Every/DT corner/NN
2 3 4 5
[2,3)
[2,6)
[3,4)
6 6
6
6
6 6
?
Figure 2: Possible state updates for the (NN corner) node us-
ing the EXPAND operator.
sult in a pair of rules, r
p
?
and r
v
, rooted at p and v
respectively. In the example in Figure 2, the top-
right outcome has a
v
= ? and
r
p
= ?(NP DT 1 (NN corner)), 1 ????? .
The bottom-right outcome, a
v
= [4, 5), describes
the pair of rules:
r
p
?
= ?(NP DT 1 NN 2 ), 1 ? 2 ??? and
r
v
= ?(NN corner),?? .
The set of valid options are then scored according
to the probability of their rules as follows:
P (r
p
|r
?
) =
n
?
r
p
+ ?P
0
(r
p
|c
p
)
n
?
c
p
+ ?
(4)
P (r
p
?
, r
v
|r
?
) = P (r
p
?
|r
?
)P (r
v
|r
?
, r
p
?
)
=
n
?
r
p
?
+ ?P
0
(r
p
?
|c
p
)
n
?
c
p
+ ?
? (5)
n
?
r
v
+ ?(r
p
?
, r
v
) + ?P
0
(r
v
|c
v
)
n
?
c
v
+ ?(c
p
, c
v
) + ?
where c
p
is the non-terminal at node p (simi-
larly for c
v
), n
?
denote counts of trees (e.g., n
?
r
p
)
or the sum over all trees expanding a non-
terminal (e.g., n
?
c
v
) in the conditioning context,
r
?
, and ?(?, ?) is the Kronecker delta function,
which returns 1 when its arguments are identi-
cal and 0 otherwise. For clarity, we have omit-
ted some items from the conditioning context
356
in (4) and (5), namely t, s and hyper-parameters
?, p
child
, p
expand
, p
term
. The ? terms in the sec-
ond factor of (5) account for the changes to n
?
that would occur after observing r
p
?
, which forms
part of the conditioning context for r
v
. If the rules
r
p
?
and r
v
are identical, then the count n
?
r
v
would
increase by one, and if the rules expand the same
root non-terminal, then n
?
c
v
would increase by one.
Equation (4) is evaluated once for the unaligned
outcome, a
v
= ?, and (5) is evaluated for each
valid alignment. The probabilities are normalised
and an outcome sampled.
The EXPAND operator is sufficient to move
from one derivation to any other valid derivation,
however it may take many steps to do so. These
intermediate steps may require the sampler to pass
through highly improbable regions of the state
space, and consequently such moves are unlikely.
The second operator, SWAP, is designed to help
address this problem by increasing the mobility of
the sampler, allowing it to mix more quickly. The
operator considers pairs of nodes, v, w, in one tree
and attempts to swap their alignment values.
3
This
is illustrated in the example in Figure 3. There are
two options being compared: preserving the align-
ments (left) or swapping them (right). This can
change three rules implied by the derivation: that
rooted at the nodes? common aligned ancestor, p,
and those rooted at v and w. For the example, the
left option implies rules
{r
p
= ?(NP DT 1 NN 2 ), 1 2 ?,
r
v
= ?(DT Every),??,
r
w
= ?(NN corner),?????} ,
and the right option implies rules
{r
p
= ?(NP DT 1 NN 2 ), 2 1 ?,
r
v
= ?(DT Every),?????,
r
w
= ?(NN corner),??} .
We simply evaluate the probability of
both triples of rules under our model,
P (r
p
, r
v
, r
w
|r
?
) = P (r
p
|r
?
)P (r
v
|r
?
, r
p
)
P (r
w
|r
?
, r
p
, r
v
), where the additional rules in
the conditioning context signify their inclusion
in the counts r
?
before applying (2) to evaluate
the probability (much the same as in (5) where
3
We rarely need to consider the full quadratic space of
node pairs, as the validity constraints mean that the only
candidates for swapping are siblings (i.e., share the closest
aligned ancestor) which do not have any aligned descendants.
? ? ? ??
NP
Every/DT corner/NN
2 3 4 5
[2,3)
[2,6)
[3,6)
? ? ? ??
NP
Every/DT corner/NN
2 3 4 5
[3,6)
[2,6)
6 6
[2,3)
Figure 3: Possible state updates for the pair of nodes
(DT every) and (NN corner) using the SWAP operator.
English? Chinese
Sentences 300k
Words or Segments 11.0M 8.6M
Avg. Sent. Length 36 28
Longest Sent. 80 80
Table 2: NIST Chinese-English corpora statistics
(LDC2003E14, LDC2005E47).
the ? functions encode the changes to the counts).
An outcome is then sampled according to the
normalised probabilities of the preserve vs. swap
rules.
The Gibbs sampler makes use of both operators.
The algorithm visits each (tree, string) pair in the
training set in random order and applies the EX-
PAND operator to every node in the tree. After the
tree has been processed, the SWAP operator is ap-
plied to all candidate pairs of nodes. Visiting all
sentence pairs in this way constitutes a single sam-
ple from the Gibbs sampler.
5 Experiments
We evaluate our non-parametric model of gram-
mar induction on a subset of the NIST Chinese-
English translation evaluation, representing a real-
istic SMT experiment with millions of words and
long sentences. The Chinese-English training data
consists of the FBIS corpus (LDC2003E14) and
the first 100k sentence pairs from the Sinorama
corpus (LDC2005E47). The Chinese text was seg-
mented with a CRF-based Chinese segmenter op-
timized for MT (Chang et al, 2008), and the En-
glish text was parsed using the Stanford parser
(Klein and Manning, 2003).
As a baseline we implemented the heuristic
grammar extraction technique of Galley et al
(2004) (henceforth GHKM). This method finds
the minimum sized translation rules which are
consistent with a word-aligned sentence pair, as
357
described in section 2.1. The rules are then
treated as events in a relative frequency esti-
mate.
4
We used Giza++ Model 4 to obtain
word alignments (Och and Ney, 2003), using
the grow-diag-final-and heuristic to sym-
metrise the two directional predictions (Koehn et
al., 2003).
The model was sampled for 300 iterations to
?burn-in?, where in each iteration we applied both
sampling operators to all nodes (or node pairs)
of all training instances. We initialised the sam-
pler using the GHKM derivation of the training
data (the baseline system). The final state of the
sampler was used to extract the grammar. The
hyperparameters were set by hand to ? = 10
6
,
p
child
= 0.5, p
expand
= 0.5, and p
term
= 0.5.
5
Overall the model took on average 2,218s per full
iteration of Gibbs sampling and 1 week in total
to train, using a single core of a 2.3Ghz AMD
Opteron machine.
5.1 Grammar Analysis
The resulting grammar had 1.62M rules, al-
most identical to the GHKM grammar which had
1.63M. Despite their similarity in size the gram-
mars were quite different, as illustrated in Fig-
ure 4, which shows histograms over various mea-
sures of rule size for the two grammars. Under
each measure the sampled grammar finds many
more simple rules ? shallower with fewer internal
nodes, fewer variables and fewer terminals ? than
the GHKM method. This demonstrates that the
prior is effective in shifting mass away from com-
plex rules. To show how the rules themselves dif-
fer, Table 3 lists rules in the sampled grammar that
are not in the GHKM grammar. Note that many of
these rules are highly plausible, describing regular
tree structures and lexicalisation. These rules have
not been specified to the same extent in the GHKM
grammar. For example the first rule incorporates
4
Our implementation of the GHKM algorithm attaches
unaligned source words to the highest possible node in the
source tree, rather than allowing all attachment points as in
the original presentation (Galley et al, 2004). Allowing all
attachments made no difference to translation performance,
but did make the grammar considerably larger. We imple-
mented only the minimal rule extraction, i.e., with no rule
composition (Galley et al, 2006). Consequently there is no
derivational ambiguity, obviating the need for expectation
maximisation or similar for rule estimation.
5
Note that although ? seems large, it still encourages
sparse distributions as the P
0
values are typically much
smaller than its reciprocal, 10
?6
, especially if the rule is
large. ?P
0
< 1 implies a sparse Dirichlet prior.
1 2 3 4 5 6 7 8 9 10 11
GKHMGibbs
maximum tree depth
num
ber o
f rule
s
0
20k
40k
60k
80k
0 1 2 3 4 5 6 7 8 9 10
variables
num
ber o
f rule
s
0
20k
40k
60k
80k
0 1 2 3 4 5 6 7 8 9 10
source terminals
num
ber o
f rule
s
0
20k
40k
60k
80k
0 1 2 3 4 5 6 7 8 9 10
target terminals
num
ber o
f rule
s
0
25k
50k
75k
100k
Figure 4: Histograms over rule statistics comparing the
heuristic grammar (GHKM) and learnt grammar (Gibbs).
the TOP symbol, while the GHKM grammar in-
stead relies on the rule ?(TOP S 1 ), 1 ? to produce
the same fragment. The model has learnt to dis-
tinguish between sentence-spanning and subsen-
tential S constituents, which typically do not in-
clude final punctuation. The third and ninth (last)
rule are particularly interesting. These rules en-
code reordering effects relating to noun phrases
and subordinate prepositional phrases, in partic-
ular that Chinese prepositional modifiers precede
the nouns they modify. Differences in word or-
der such as these are quite common in Chinese-
English corpora, so it is imperative that they are
modelled accurately.
The rules in the GHKM grammar that do not
appear in the sampled grammar are shown in
Table 4. In contrast to the rules only present in
the sampled grammar, these have much lower
counts, i.e., are less probable. Each of these rules
has been specified further by the Bayesian model.
358
?(TOP (S NP 1 VP 2 . 3 )), 1 2 3 ?
?(S (VP (TO to) VP 1 )), 1 ?
?(NP NP 1 (PP (IN of) NP 2 )), 2 1 ?
?(PP (IN in) NP 1 ), ? 1 ?
?(NP NP 1 (PP (IN of) NP 2 )), 1 2 ?
?(NP (DT the) NN 1 ), ? 1 ?
?(S (VP TO 1 VP 2 )), 1 2 ?
?(VP (VBZ is) NP 1 ), ? 1 ?
?(NP (NP (DT the) NN 1 ) (PP (IN of) NP 2 )), 2 1 ?
Table 3: Top ten rules in the sampled grammar that do not
appear in the GHKM grammar. All the above rules are quite
high probability, with counts between 37,118 and 7,275 from
first to last.
?(PP (IN at) (NP DT 1 (NNS levels))), 1 ??
?(NP NP 1 , 2 NP 3 (, ,) CC 4 NP 5 ), 1 2 3 4 5 ?
?(NP NP 1 , 2 NP 3 , 4 NP 5 (, ,) (CC and) NP 6 ), 1 2 3 4 5 , 6 ?
?(S S 1 (NP (PRP They)) VP 2 . 3 ), 1 2 3 ?
?(S PP 1 , 2 NP 3 VP 4 . 5 ? 6 ), 1 2 3 4 6 5 ?
?(S PP 1 , 2 NP 3 VP 4 . 5 ), 1 ? 2 3 4 5 ?
?(NP (NNP Foreign) (NNP Ministry) NN 1 (NNP Zhu) (NNP Bangzao)),
??? 1 ????
?(S S 1 S 2 ), 1 2 ?
?(S S 1 (NP (PRP We)) VP 2 . 3 ), 1 2 3 ?
?(NP (DT the) (NNS people) POS 1 ), ?? 1 ?
Table 4: Top ten rules in the GHKM grammar that do not ap-
pear in the sampled grammar. These are quite low probability
rules: their counts range from 1,137 to 103.
For example, every instance of the first rule
had the same determiner and target translation,
?(PP (IN at) (NP (DT all) (NNS levels))),???,
and therefore the model specified the determiner,
resulting in a single rule. The model has correctly
learnt that other translations for (DT all) are
not appropriate in this context (e.g., ?, ??
or ??). In a number of the remaining rules
the commas were lexicalised, or S rules were
extended to include the TOP symbol.
To further illustrate the differences between the
grammars, Table 5 shows the rules which include
the possessive particle, ?, and at least one vari-
able. In both grammars there are many fully lex-
icalised rules which translate the token to, e.g., a
determiner or a preposition. The grammars differ
on the complex rules which combine lexicalisa-
tion and frontier non-terminals. The GHKM rules
are all very simple depth-1 SCFG rules, contain-
ing minimal information. In contrast, the sampled
rules are more lexicalised, licensing the insertion
of various English tokens and tree substructure.
Note particularly the second and forth rule which
succinctly describe the reordering of prepositional
Sampled Grammar
?(NP (DT the) NN 1 ),? 1 ?
?(NP (NP (DT the) NN 1 ) (PP (IN of) NP 2 )), 2 ? 1 ?
?(NP (DT the) NN 1 ), 1 ??
?(NP (NP (DT the) JJ 1 NN 2 ) (PP (IN of) NP 3 )), 3 ? 1 2 ?
?(PP (IN of) NP 1 ), 1 ??
GHKM Grammar
?(NP JJ 1 NNS 2 ), 1 ? 2 ?
?(NP JJ 1 NN 2 ), 1 ? 2 ?
?(NP DT 1 JJ 2 NN 3 ), 1 2 ? 3 ?
?(NP PRP$ 1 NN 2 ), 1 ? 2 ?
?(NP NP 1 PP 2 ), 2 ? 1 ?
Table 5: Top five rules which include the possessive particle
? and at least one variable.
phrases with an noun phrase.
5.2 Translation
In order to test the translation performance of
the grammars induced by our model and the
GHKM method
6
we report BLEU (Papineni et
al., 2002) scores on sentences of up to twenty
words in length from the MT03 NIST evaluation.
We built a synchronous beam search decoder to
find the maximum scoring derivation, based on
the CYK+ chart parsing algorithm and the cube-
pruning method of Chiang (2007). Parse edges for
all constituents spanning a given chart cell were
cube-pruned together using a beam of width 1000,
and only edges from the top ten constituents in
each cell were retained. No artificial glue-rules or
rule span limits were employed.
7
The parameters
of the translation system were trained to maximize
BLEU on the MT02 test set (Och, 2003). Decoding
took roughly 10s per sentence for both grammars,
using a 8-core 2.6Ghz Intel Xeon machine.
Table 6 shows the BLEU scores for the baseline
using the GHKM rule induction algorithm, and
our non-parametric Bayesian grammar induction
method. We see a small increase in generalisation
performance from our model. Our previous anal-
6
Our decoder was unable to process unary rules (those
which consume nothing in the source). Monolingual pars-
ing with unary productions is fairly straightforward (Stolcke,
1995), however in the transductive setting these rules can li-
cence infinite insertions in the target string. This is further
complicated by the language model integration. Therefore
we composed each unary rule instance with its descendant
rule(s) to create a non-unary rule.
7
Our decoder lacks certain features shown to be beneficial
to synchronous grammar decoding, in particular rule binari-
sation (Zhang et al, 2006). As such the reported results for
MT03 lag the state-of-the-art: the Moses phrase-based de-
coder (Koehn et al, 2007) achieves 26.8. We believe that im-
provements from a better decoder implementation would be
orthogonal to the improvements presented here (and would
allow us to relax the length restriction on the test set).
359
Model BLEU score
GHKM 26.0
Our model 26.6
Table 6: Translation results on the NIST test set MT03 for
sentences of length ? 20.
ysis (Section 5.1) of the grammars produced by
the two approaches showed our method produced
better lexicalised rules than those induced by the
GHKM algorithm. Galley et al (2006) noted that
the GHKM algorithm often over generalised and
proposed combining minimal rules to form com-
posed rules as a solution. Although composing
rules was effective at improving BLEU scores, the
result was a massive expansion in the size of the
grammar. By learning the appropriate level of lex-
icalisation we believe that our inference algorithm
is having a similar effect as composing rules (Gal-
ley et al, 2006), however the resulting grammar
remains compact, a significant advantage of our
approach.
6 Conclusion
In this paper we have presented a method for in-
ducing a tree-to-string grammar which removes
the need for various heuristics and constraints
from models of word alignment. Instead the model
is capable of directly inferring a grammar in one
step, using the syntactic fragments that it has learnt
to better align the source and target data. Using a
prior which favours sparse distributions and sim-
pler rules, we demonstrate that the model finds
a more parsimonious grammar than the heuristic
technique. Moreover, this grammar results in im-
proved translations on a standard evaluation set.
We expect that various extensions to the model
would improve its performance. One avenue is to
develop a more sophisticated prior over rules, e.g.,
one that recognises common types of rule via the
shape of the tree and ordering pattern in the tar-
get. A second avenue is to develop better means
of inference under the grammar, in order to ensure
faster mixing and a means to escape from local
optima. Finally, we wish to develop a method for
decoding under the full Bayesian model, instead of
the current beam search. With these extensions we
expect that our model of grammar induction has
the potential to greatly improve translation output.
Acknowledgements
The authors acknowledge the support of the EP-
SRC (grants GR/T04557/01 and EP/D074959/1).
This work has made use of the resources pro-
vided by the Edinburgh Compute and Data Facility
(ECDF). The ECDF is partially supported by the
eDIKT initiative.
References
P. Blunsom, T. Cohn, C. Dyer, M. Osborne. 2009a.
A Gibbs sampler for phrasal synchronous grammar
induction. In Proceedings of the Joint conference
of the 47th Annual Meeting of the Association for
Computational Linguistics and the 4th International
Joint Conference on Natural Language Processing
of the Asian Federation of Natural Language Pro-
cessing, Singapore. To appear.
P. Blunsom, T. Cohn, M. Osborne. 2009b. Bayesian
synchronous grammar induction. In D. Koller,
D. Schuurmans, Y. Bengio, L. Bottou, eds., Ad-
vances in Neural Information Processing Systems
21, 161?168. MIT Press, Cambridge, MA.
P.-C. Chang, M. Galley, C. D. Manning. 2008. Op-
timizing Chinese word segmentation for machine
translation performance. In Proceedings of the
Third Workshop on Statistical Machine Translation,
224?232, Columbus, Ohio.
D. Chiang. 2007. Hierarchical phrase-based transla-
tion. Computational Linguistics, 33(2):201?228.
T. Cohn, S. Goldwater, P. Blunsom. 2009. Inducing
compact but accurate tree-substitution grammars.
In Proceedings of Human Language Technologies:
The 2009 Annual Conference of the North American
Chapter of the Association for Computational Lin-
guistics, 548?556, Boulder, Colorado.
J. DeNero, D. Gillick, J. Zhang, D. Klein. 2006.
Why generative phrase models underperform sur-
face heuristics. In Proceedings on the Workshop on
Statistical Machine Translation, 31?38, New York
City, NY.
J. DeNero, A. Bouchard-C?ot?e, D. Klein. 2008. Sam-
pling alignment structure under a Bayesian transla-
tion model. In Proceedings of the 2008 Conference
on Empirical Methods in Natural Language Pro-
cessing, 314?323, Honolulu, Hawaii.
J. Eisner. 2003. Learning non-isomorphic tree map-
pings for machine translation. In The Companion
Volume to the Proceedings of 41st Annual Meeting of
the Association for Computational Linguistics, 205?
208, Sapporo, Japan.
V. Fossum, K. Knight, S. Abney. 2008. Using syn-
tax to improve word alignment precision for syntax-
based machine translation. In Proceedings of the
360
Third Workshop on Statistical Machine Translation,
44?52, Columbus, Ohio.
M. Galley, M. Hopkins, K. Knight, D. Marcu. 2004.
What?s in a translation rule? In Proceedings of the
2004 Human Language Technology Conference of
the North American Chapter of the Association for
Computational Linguistics, 273?280, Boston, MA.
M. Galley, J. Graehl, K. Knight, D. Marcu, S. DeNeefe,
W. Wang, I. Thayer. 2006. Scalable inference and
training of context-rich syntactic translation mod-
els. In Proceedings of the 21st International Con-
ference on Computational Linguistics and 44th An-
nual Meeting of the Association for Computational
Linguistics, 961?968, Sydney, Australia.
S. Geman, D. Geman. 1984. Stochastic relaxation,
Gibbs distributions and the Bayesian restoration of
images. IEEE Transactions on Pattern Analysis and
Machine Intelligence, 6:721?741.
W. Gilks, S. Richardson, D. J. Spiegelhalter, eds. 1996.
Markov Chain Monte Carlo in Practice. Chapman
and Hall, Suffolk.
M. Johnson, T. L. Griffiths, S. Goldwater. 2007.
Adaptor grammars: A framework for specifying
compositional nonparametric Bayesian models. In
B. Sch?olkopf, J. Platt, T. Hoffman, eds., Advances
in Neural Information Processing Systems 19, 641?
648. MIT Press, Cambridge, MA.
M. Johnson. 2002. The DOP estimation method is
biased and inconsistent. Computational Lingusitics,
28(1):71?76.
D. Klein, C. D. Manning. 2003. Fast exact inference
with a factored model for natural language parsing.
In In Advances in Neural Information Processing
Systems 15, 3?10. MIT Press.
P. Koehn, F. J. Och, D. Marcu. 2003. Statisti-
cal phrase-based translation. In Proceedings of
the 2003 Human Language Technology Conference
of the North American Chapter of the Association
for Computational Linguistics, 48?54, Edmonton,
Canada.
P. Koehn, H. Hoang, A. Birch, C. Callison-Burch,
M. Federico, N. Bertoldi, B. Cowan, W. Shen,
C. Moran, R. Zens, C. Dyer, O. Bojar, A. Con-
stantin, E. Herbst. 2007. Moses: Open source
toolkit for statistical machine translation. In Pro-
ceedings of the 45th Annual Meeting of the Associa-
tion for Computational Linguistics Companion Vol-
ume Proceedings of the Demo and Poster Sessions,
177?180, Prague, Czech Republic.
D. Marcu, W. Wang, A. Echihabi, K. Knight. 2006.
SPMT: Statistical machine translation with syntact-
ified target language phrases. In Proceedings of the
2006 Conference on Empirical Methods in Natural
Language Processing, 44?52, Sydney, Australia.
F. J. Och, H. Ney. 2003. A systematic comparison of
various statistical alignment models. Computational
Linguistics, 29(1):19?51.
F. J. Och. 2003. Minimum error rate training in sta-
tistical machine translation. In Proceedings of the
41st Annual Meeting of the Association for Compu-
tational Linguistics, 160?167, Sapporo, Japan.
K. Papineni, S. Roukos, T. Ward, W.-J. Zhu. 2002.
BLEU: a method for automatic evaluation of ma-
chine translation. In Proceedings of the 40th Annual
Meeting of the Association for Computational Lin-
guistics, 311?318, Philadelphia, PA.
A. Stolcke. 1995. An efficient probabilistic context-
free parsing algorithm that computes prefix proba-
bilities. Computational Linguistics, 21(2).
H. Zhang, L. Huang, D. Gildea, K. Knight. 2006. Syn-
chronous binarization for machine translation. In
Proceedings of the 2006 Human Language Technol-
ogy Conference of the North American Chapter of
the Association for Computational Linguistics, 256?
263.
H. Zhang, C. Quirk, R. C. Moore, D. Gildea. 2008.
Bayesian learning of non-compositional phrases
with synchronous parsing. In Proceedings of ACL-
08: HLT, 97?105, Columbus, Ohio.
A. Zollmann, A. Venugopal. 2006. Syntax augmented
machine translation via chart parsing. In Proceed-
ings of the 2006 Human Language Technology Con-
ference of the North American Chapter of the As-
sociation for Computational Linguistics, 138?141,
New York City, NY.
361

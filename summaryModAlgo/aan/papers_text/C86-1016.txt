D-PATR:  A Deve lopment  Env i ronment  
fo r  Un i f i ca t ion -Based  Grammars  
Lauri Karttunen 
Artificial Intelligence Center 
SRI International 
333 Ravenswood Avenue 
Menlo Park, CA 94025 USA 
and 
Center for the Study of Language and Information 
Stanford University 
1 Introduction 
I)-PATR is a development environment for 
unification-based grammars on Xerox l i00 series work 
stations. It is based on the PATR formalism developed at 
SRI International. This formalism is suitable for encoding 
a wide variety of grammars. At one end of this range are 
simple phrase-structure grammars with no feature 
augmentations. The PATR formalism can also be used to 
encode grammars that are based on a number of current 
linguistic theories, such as lexical-functional grammar 
(Bresnan and Kaplan), head-driven phrase structure 
grammar (Pollard and Sag), and functional unification 
grammar (Kay). At the other end of the range covered by 
D-PATR are unification-based categorial grammars 
(Klein, Steedman, Uszkoreit, Wittenburg) in which all 
the syntactic information is incorporated in the lexicon 
and the remaining few combinatorial rules that build 
phrases are function application and composition. 
Definite-clause grammars (Pereira and Warren) can also 
be encoded in the PATR formalism. 
What these approaches have in common is that 
syntactic rules and lexieal entries can be written down as 
sets of attribute-value pairs. Moreover, because a value at 
the end of one path of attributes can be shared by another 
path, the structures that are generated by such grammars 
can be thought of as directed graphs Cdags"). Unification 
is the key operation for building these structures. 
Because unification is associative and commutative, 
statements in a unification-based grammar formalism are 
order-independent and bidirectional with respect to 
parsing and generation. For a comprehensive 
introduction tounification-based approaches togrammar, 
see Shieber 1986 (forthcoming). 
The idea that led to the present version of D-PATR was 
to produce a simple compact system for experimenting 
with unification-based grammars that would run on 
machines maller than the Symbolics 3600 for which the 
original t'ATI~ implementation at SRI had been created. 
The first version of I)-PATR, initially called }lUG, was 
written at the Scandinavian Summer Workshop for 
Computational Linguistics in Helsinki, Finland, at the 
end of August 1985. Although the actual notation for 
writing rules in D-PATR in some respects differs from the 
notation in the original PATI? system, essentially both 
systems implement the samegrammar formalism. To 
emphasize this point, the two implementations are now 
called Z-PATR (Zeta-LiSP PATR) and D PATR (Interlisp-D 
PATR). A number of innovations that came in with 
l) PATR (HUG) have since migrated to Z-PATR. A case in 
point is the method for minimizing copying in unification 
that is discussed in the section on parsing and unification. 
Other implementation differences remain--for example, 
in the parsing algorithm and in the treatment of 
gaps--but grammars written for D-PATR are convertible 
into Z-PATR format, and vice versa. 
D-PATR consists of four basic parts: 
? A unification package 
? Interpreter for rules and lexical items 
? Input output routines for directed graphs 
? An Earley style chart parser. 
These packages are written in simple Interlisp-D for 
transportability o other dialects of LISP. They do not 
depend on the features of any particular machine. The 
only part of D-PATR that is specific to Xerox 1100 series 
work stations is its user interface. This last set of 
routines takes full advantage of the graphic capabilities 
74 
of D-machines. It  provides good facil it ies for wr i t ing and 
edit ing grammars  as well as many debugging tools for the 
, ~rammar  writer.  
2 Grammar  Formal i sm 
2.1 Rules 
A rule in I\]-PATR is a l ist of atomic eot~stituent labels 
that  may be followed by speczfications. Specif ications are 
constra ints  upon one or more const i tuents  of the rule. in 
the s implest  case, there are no specif ications and the 
labels correspond to symbols in an ordinary phrase 
structure rule. For example, the rule 
S + NP VP 
in I) PATR notat ion is wr i t ten as 
(S NP VP) 
Before a rule is used by the parser, I)-PATI{ compiles it 
to a feature set. A feature set can be displayed in di\[ferent 
ways-- for  example, as a matr i? or as a directed graph. \[n 
this paper, we usual ly represent feature sets as graphs 
but the matr ix  notat ion will also be used occasionally. \[n 
these graphs, the const i tuents  of the rule are represented 
by labeled arcs, called attributes. The nodes in the graph 
are values. A value can be atomic or complex; a complex 
wfiue is another  set of at t r ibute-va lue pairs. By 
convention, the symbol on the left-hand side of a phrase 
structure rule is represented by the numer ic  at t r ibute  0. 
Const i tuents  on the r ight -hand side of the rule are 
numbered left-to-right, s tar t ing with 1. The above rule 
D PATR represents  as the following feature set, shown 
here first as a graph and then as the equiva lent  matr ix.  
O-- - -cat - -S  0 \ [cat  S\] -  
i . . . . .  ca t - -NP  1 \ [cat  < 
2 . . . .  ca t - -VP  2 \ [cat  VF;\]I 
a r i ty - -2  ar  i t,y 2 I 
t 
l abe ls  I I - -NP  labe ls  NP 
- -2 - -VP  V 
specification is a two-item list of the form 
( { a t t r ibute  I path \] \[ path  \[ va lue  } ). 
Here attribute is an atom, path is a list, and value is 
e i ther  an atomic symbol, a l ist of specifications, or an 
abbreviat ion tbr such a list. The last case is 
d ist inguished from the first by pref ixing the value symbol 
with (,~) when it has an abbreviatory role. Ignoring the 
(?L>cases, this gives four dif ferent k inds of specifications: 
(attribute vahte), (path value), (attribute path), and (path 
path). The same feature set can often be specified in 
several  different ways; in choosing one, we general ly try 
to minimize the number  of parentheses.  
Below is a simple example of a phrase structure rule 
augmented  with specifications. 
(S NP VP 
((0 f se t ) (2  f se t ) )  
((1 f set )  (2 f se t  sub ject ) )  
((2 f se t  form) f in i te ) )  
The first specit~cation is an analogue of an I.F'~; T = 
annotat ion;  the S node inher i ts  its feature set from the VP. 
In addition, N\[' is VP's subject and vp's feature set 
contains the feature \[form: finite\]. I) I'ATI{ compiles this 
rule to the following graph. (From now on, we shal l  omit 
the two non-const i tuent  a tr ibutes,  arity and labels, fi-om 
our display.) 
~cat - -S  
O--  - . f se t  
2- -Q  . / / fo r i~f in i te  
fset  ~C.suba~ct"-~ \[ 1 
As the graph shows, the feature set of the S-node is the 
same as VP'S feature set. The NP const i tuent  has been 
unified with the subject in the feature set of the S and the 
vp. 
2.2 Specif icat ions 
In the above rule, the cat feature is interpreted by 
\[) PATR as a const ra int  on the manner  in which the 
const i tuent  can be instant iated.  More constra ints  can be 
added by annotat ing  the rule with specifications. A 
It is permissible in D p,.\'rR to write rules that  do not 
assign their  const i tuents  to any specific syntactic 
category, such as S, NP, \'P. and the like. The default  
assumption is that  the const i tuent  \[abels also serve as 
values of cat. By declar ing them to be DummyCategories, 
the grammar  writer  can override this convention. The 
75 
default  dummy symbols are x, Y, and z. instead of (S NP 
VP), one could just  as well write 
(xYz 
((0 cat) S) 
(( I  cat) NP) 
((2 cat) VP) 
\[t is also legal to leave cat entirely unspecified. This 
option is useful for expressing rules of function 
application and composit ion in lexically-based categorial  
grammars .  
2.3 Words  and  Stems 
In its present  form, D-PATR does not have a 
morphological analyzer  to relate inflected or derived 
forms of words to entr ies in a morpheme lexicon. All 
lexcmes must  be entered individually, in ant ic ipat ion of 
hav ing a better  solution avai lable in the future, D-PATR 
presently splits the lexicon into two parts: words and 
stems. The format of the two lexicons is the same, but 
entr ies  in the word lexicon may contain a reference to an 
entry in the stem lexicon. For example, the entr ies for 
am, are. ts, was, were, etc. in the word lexicon can refer to 
the entry for be in the stem lexicon. Consequently,  what  
is common to all forms of the auxi l iary can be stated in a 
single place. 
A \[exical entry  is a l ist consist ing of a form and a list of 
subentrtes. Each subentry  in turn is a list headed by a 
morphological category and any number  of specifications. 
A specification can be a two-item list of the type discussed 
in the previous section or a template. A template is an 
abbreviat ion fo ra  l istofspeci f icat ions.  For example, the 
entry for kisses in the word lexicon might  look as follows: 
(kisses (g kiss PresTense Sg3) 
(N kiss PI)). 
I Iere N and V are used as names of morphological 
categories; kiss refers to an entry in the stem lexicon; 
PresTense, S t3  and PI are templates.  The fact that  kiss is 
a stem and St3  a template is not marked; it is ra ther  
determined by where the i r  definit ions are found. The 
entry for kiss in the stem lexicon could be, for example, 
(kiss (V VMain TakesNP Dyadic) 
(N)). 
When the def init ions for kisses and kiss are 
76 
interpreted,  the templates and other specif ications that  
occur in the i r  subentr ies  are processed sequent ia l ly  from 
left to r ight.  Each i tem is compiled to a directed graph 
and superimposed on the graph previously compiled. This 
overwr i t ing operat ion differs fl'om standard unif ication in 
that  it never fails; if two specif ications give confl ict ing 
values to some path, the later specif ication overrules the 
earl ier one. The lexicon writer  can take advantage of this 
convent ion to set up a hierarchical  feature system in 
which init ia l  default  ass ignments  can be overr idden by 
later specifications. 
2.4 Templates  
Definit ions for templates  have the same format as the 
entr ies  in the word and stem lexicons except that  there 
are no mult ip le subentr ies;  templates are assumed to be 
unambiguous.  A template definit ion is simply a List 
consist ing of a template name and a number  of 
specifications. For example, the template names that  
appear in the entr ies  for kiss might  be expanded as 
follows: (Note that  a specification may be e i ther  a 
two-item list of the form discussed in section 2.2 or a name 
of another  template,) 
(V OneBar) 
(OneBar (barlevel one)) 
(VMain Predicate ( invert ible false)) 
(Predicate ((trans pred) (sense))) 
(TakesNP ((syncat f i r s t  cat) NP) 
((syncat rest f i r s t  cat) NP) 
((syncat rest rest)(syncat ta i l ) ) )  
(Dyadic ((trans argl) 
(syncat f i r s t  trans)) 
((trans arg2) 
(syncat rest f i r s t  trans))) 
With these definit ions, the verb entry  for kiss in the 
stem lexicon compiles to the graph shown below. 
barl evel -- one 
cat--V 
invertible--false 
lex~ 
sense ~- - . -~  
/pred~kiss 
t rans - -~arg1~ 
arg2"~~a NP 
syncat--L ~ / f i r s t - -<~ 
\ - res t - -<  k t rans  
\t il- --r st\II 
The role of the template TakesNP in this entry is to 
state that  the verb kiss requires two NP's as its syntactic 
arguments .  The f irst e lement  of the list is the value of the 
path <syncat f i r s t>,  the second is <syncat res t  f i r s t>.  
The template Dyadic l inks the two arguments  in the 
semant ic  t rans lat ion  of kiss to the t rans lat ions  of its 
syntact ic arguments .  
2.5 l ,ex iea l  Ru les  
The expansion of morpheme def init ions by means of 
templates is a s t ra ight forward matter:  an init ia l  graph 
acquires addit ional  features and, perhaps, new values for 
features it a l ready has. I)-\['A'I'I{ also allows a more radical 
t ransformat ion by means of lexical titles. A lexical rule is 
a special kind of template with two attr ibutes:  m and out. 
\[n applying a lexical rule to a graph, the latter  is J\]rst 
unified with the value of in. If the operat ion succeeds, the 
value of out is passed on as the result.  Because the values 
under out cart be l inked selectively to the corresponding 
values under  in, the usual result  of applying a \[exical rule 
is a metamorphos is  of the input graph. As an example. 
let us consider the graph corresponding to a possible 
lexieal rule for Passive in Engi ish. To make it easier to 
see the effect of the rule, the graph is turned aroud so that  
the out values are opposite to the corresponding Ln values; 
the indeterminates  in the middle are unif ied with their  
counterparts  in the word to which the rule is applied. 
i n - 
cat l/ c(~t\ 
le_~ \[ / - t,_.x~ 
....... ~ntics--relatior,-fl- ,',d,dion\ \ 
SOMEBODY- -arR!  7 sem(lnticsl-out 
/ 
The effect of the rule is to make a transi t ive verb lose 
the object slot in its syntact ic frame, even though 
semant ica l ly  it remains  a two-place predicate. The 
semant ic  effect of the rule is to unify arg2 with the 
subject's semant ics  and to assign to argl the value 
SOMEI}OI)Y. This is s imi lar  to the analysis  of passives in 
some LI,'G grammars .  
2.6 F i l lers  and  Gaps  
Constructh)ns such as the fb\[lowing contain 
const i tuents  that,  semant ical ly  and syntactical ly,  fill a 
vacant  s lot - -a  gap--somewhere in the adjacent structure.  
That paper \[ don't  intend to read - - .  
Good aw)cados are hard to find - - .  
The neighbor whose car you asked to borrow - -  called. 
Is this the company the ht.stogr'am of whose productmrt 
she wants  to display - - ?  
From a parser's point of view, there are two main 
problems to be solved. For the parse to succeed, the filler 
needs to be avai lable when the incomplete structure is 
encountered. There must  also be a way to et l sure  Chat a 
designated fil ler will be consumed by a gap somewhere. A 
th i rd problem is that,  in relat ive clauses, the filler must  
contain a relat ive pronoun. 
Many solut ions to these problems have been proposed 
and could be implemented in D PATR. As  a convenience, 
D PAI'It also makes avai lable to the grammar  writer a 
bui lt - in default  mechanism for d is t r ibut ing the 
information about fillers, gaps, and relat ive pronouns in 
an appropr iate way. The or iginal  idea, conceived by 
Fernando Pereira,  was implemented for gaps in z PATR 
by Stuar t  Shieber. The scheme in I)-t)A'I'R is an 
improvement  in that  it also handles sentences with 
nested fi l ler-gap dependencies. 
77 
The default  mechan ism uses four special features: gapln, 
gapOut, relIn and relOut. These features need to be 
ment ioned explicit ly only in rules that  introduce fillers, 
such as the relat ive-clause rule, and in the lexical entr ies 
of relat ive and interrogat ive pronouns. Other  rules are 
automat ica l ly  augmented  by I)-PAI'R in the appropr iate 
manner  when they are compiled to feature sets used by 
the parser. By deact ivat ing this facility, the grammar  
writer can also take care of fi l lers and gaps in a manner  of 
his own choosing. 
3 Pars ing  and  Un i f i ca t ion  
D PATR uses an active chart  parser that  proceeds in a 
top-down, breadth-f i rst  manner .  Because the 
const i tuents  in a rule are feature sets ra ther  than atomic 
symbols, the task is a bit  more complicated than in 
s tandard implementat ions  of Earley's a lgor i thm. We 
consider two cases here. 
Let us assume that  the parser is in the process of 
t ry ing to build an instance of the rule A ~ I~ C and that  it 
has successfully instant ia ted B as B'. At this point, it will 
enter  a part ial  instant iat ion  of the rule on the chart.  We 
designate this active edge as A'(B'): C'. Here the colon 
marks  the line between daughter  const i tuents  that  have 
been found and daughters  that  sti l l  need to be 
instant iated.  When an active edge is added to the chart,  
the parser needs to find all the rules that  match the first 
un instant ia ted  const i tuent  to the r ight  of the colon. In 
the case at hand, it needs to match C' aga inst  he left-hand 
sides of all rules to determine what  rules it should now try 
to instant iate.  For example, if there is a rule C ~ D in the 
grammar  and C is compatible with C', a looping C: I) or C': 
I)' edge should be added to the chart.  
In the case of an ordinary phrase-structure grammar ,  
this match ing  task is simple because const i tuents  are 
represented by atomic category labels. Fur thermore,  A = 
A', B = B', and C = C'. For D PATR, the s i tuat ion is more 
78 
complicated. F i rst  of all, the const i tuents  are feature sets; 
second, the const i tuents  in a part ia l ly  \ [nstant iated rule 
are general ly  not equal to the corresponding const i tuents  
in an un ins tant ia ted  rule. Because of the l inks among 
const i tuents  in a unif icat ion-based grammar ,  
ins tant ia t ing  B as B' in the rule A -, B C may also have an 
effect on the feature sets of A and C. This  is why we label 
the resul t ing edge A'{13'): C'. Using the feature set C' to 
find the rules that  could instant iate  it is no more difficult 
than using the or iginal  C, but  it is iess efficient because 
the result  cannot  be saved and reused when another  
instance of C must  be bui l t  later. 
l.) PATR so lves  this problem by carry ing the or iginal  
rule along with its part ia l ly  instant iated form on active 
edges. The match ing  task for the prediction step of 
Ear ley's  a lgor i thm is performed using the const i tuent  
from the original rule ra ther  than its current  instance. 
A s imi lar  problem arises when an inactive edge is 
entered on the chart.  When the parser has instant ia ted C 
as c:" and entered it on the chart,  it has to find all the 
incoming active edges at the start ing vertex of C" that  
could be extended with the newly found const i tuent.  If('" 
were :m atomic symbol, this task would be simple because 
it would involve only simple equal ity checks: because C" is 
a feature set, we would have to use unif ication, which is a 
more t ime-consuming operation. I) PATR avoids the 
problem ent irely by keeping track, as part  of the 
prediction step, of what  edges C" could be used to extend. 
When an active edge is entered on the chart ,  one piece of 
information in the edge label is a pointer to the edges that  
could be extended with it. Init ial ly, the list contains only 
the edge that  generated the new edge; other  edges may be 
added later. This information is passed along on 
whenever  an exist ing edge is extended to a new one. At  
the point at which C" is added to the chart,  no checks are 
necessary because the new edge already has a pointer to 
every incoming edge at the s tar t ing vertex that  can now 
perhaps be extended. 
Let us now consider a situation, in which the chart  
contains two adjacent edges A'(B'):C' and C". 
In the course of trying to extend the the active edge 
with C" to build A", the parser has to unify it with the C" 
constituent of the active edge. The nature of chart 
parsing is :inch Chat, whether or not this unificat, ion 
succeeds, it must not alter the contents of the two operand 
edges. Both A'IB'):C' and C" must remain on l, he chart 
because they may be needed later on for some other 
unification. 
Because unificaLion is a destructive operation, some of 
the earl ier implementations of unification-based chart 
parsing, e.g. Z-PATR, never apply it directly, instead, the 
feature sets are first copied and unil ication is then applied 
to the copies. In this way, the operands are left 
untouched, us the parsing algorithm requires, but t.he 
method is computationally inefficient because it involves 
a great deal of copying. 1) PATI{ solves the problem in a 
novel way. In \[)-PATR, unification is implemented so that 
the original state of the input structures can be restored 
after the operation has been completed. Whenever a 
destructive change is about to be nmde in the value of an 
attribute, the eell and its contents are saved in an array. 
After unification, all the effects of the operation can be 
undone by restoring the saved values. I) PATI{ takes 
advantage of this option in the following way. 
When the. parser tries to extend A'(B'): C' to A" by 
unifying C' with C", the operation is applied directly to the 
two feature sets without them being copied in advance. If 
the unification fails, its effects are simply cancelled by 
restoring the original feature sets from the save array. If 
the operation succeeds, the result ing structure is copied 
and then the original feature sets are then restored. The 
copied result remains of course unaffected by the 
cancellation. The following sketch summarizes the 
difference between I) PATI{ and earl ier versions of Z.PATR 
with respect to copying and unification. Here X and v 
stand for the original feature sets, z for the result, and the 
copied structures are identified with primes. 
Z-PATR (OLD) 
? -~-~ x' 
Y {opt> ?' 
D-PATR 
x 
restore X 
un i fy  ~> Z copy -~, Z' 
y restore Y 
As the i l lustration shows, the new me~,hod entails 
making only one copy, not two, when the operation 
succeeds. In the event of failure, 1) I'ATR simply restores 
the original structures without copying anything; the old 
method always copies both input structures. 
In the case of Z-PATR, the new method has shortened 
parsing times by a factor of three. It is expected that this 
technique can be further improved by hnplcmenting some 
fmm of structure sharing \[Karttunen :~nd Kay 1985; 
Pereira 1.9851 to minimize the need for copying. 
4 Conch ls ion  
Unlike some other grammar development 
systems--for example, Ronald Kaplan's IA,'(~ Grammar 
Writer's Workbench \[Kiparsky 84\]--I)-PATR \[S not an 
implementation of a particular linguistic theory. It is 
designed to be an efficient generic tool for expJoring a 
,'ange of grammar formalisms in which unit~cation plays 
a central role. Because of its fl'iendly interface and 
display facilities, I)-PA'rR can also be used for educational 
purposes, in partieular, to demonstrate chart parsing and 
unification. 
I)-PATR is not a commercial product. It is made 
available to users outside SRI who might wish to develop 
unification-based grammars. I)-I'ATR is currently being 
used for grammar development at s\['d International.  ('5LI. 
and Xerox I'AIIC. For a more comprehensive discussion of 
I) PATI{ and its features, see Karttunen (forthcoming). 
79 
Acknowledgments 
I)-PATR is  a close relative of Z-PATR, the first I'ATR 
implementation, whose main architect is Stuart Shieber. 
Many of the ideas in D-PATR come from the work of Ronald 
Kaplan, Martin Kay, and Fernando Pereira. The matrix 
display package for feature sets in D-PATR was written by 
Per-Kristian Halvorsen. I would also like to thank Annie 
Zaenen and Hans Uszkoreit for their help in designing 
the system. 
This research, made possible in part by a gift from the 
System Development Foundation, was also supported by 
the Defense Advanced Research Projects Agency under 
Contract N00039-84-C-0524 with the Naval Electronics 
Systems Command. 
References 
Kaplan, R. and J. Bresnan, "I,exical-functional grammar: 
A Formal System for Grammatical Representation," 
The Mental Representation f Grammatical Relations, 
J. Bresnan, ed., MIT Press, Cambdridge, 
Massachusetts, 1983. 
Karttunen, L. and M. Kay, "Structure Sharing with 
Binary Trees," Proceedings of the 23rd Annual 
Meeting of the ACL, Association for Computational 
Linguistics, 1985. 
Karttunen, L. D-PATR: A Development Environment for 
Unification-Based Grammars, CSLI Report, Center for 
the Study of Language and Information, Stanford, 
California (forthcoming in 1986). 
Kay, M., "Parsing in Functional Unification Grammar," 
Natural Language Parsing, D. Dowty, L. Karttunen, 
and A. Zwieky, eds., Cambridge University Press, 
Cambridge, England, 1985. 
Kiparsky, C. "LFG Manual," manuscript, Xerox Palo Alto 
Research Center, Palo Alto, California (1985). 
Pereira, F. C. N., "A Structure-Sharing Representation 
for Unification-Based Grammar Formalisms," 
Proceedings of the 23rd Annual Meeting of the ACL, 
Association for Computational Linguistics, 1985. 
Pereira, F. C. N. and D. H. D. Warren, "Definite-Clause 
Grammars for Language Analysis--a Survey of the 
Formalism and a Comparison with Augmented 
Transition Networks," Artificial Intelligence, 
13:231-278, 1980. 
Pollard, C., Generalized Phrase Structure Grammars. 
Head Grammars, and Natural Languages, Ph.D. 
dissertation, Stanford University, Stanford, California 
(1984). 
Pollard, C., Lecture notes on head-driven 
phrase-structure grammar, Center for the Study of 
Language and information, unpublished (February 
1985). 
Shieber, S. M., H. Uszkoreit, F. C. N. Pereira, J. J. 
Robinson, and M. Tyson, "The Formalism and 
Implementation of PATR lI," Research on Interactive 
Acquisition and Use of Knowledge, B. Grosz and M. 
Stickel, eds., Sill Final Report 1894, SRI International, 
Menlo Park, California, 1983. 
Shieber, S. M., L. Karttunen, and F. C. N. Pereira, Notes 
from the Unification Underground: A Compilation of 
Papers on Unification-Based Grammar Formalisms. 
Technical Report 327, Artificial Intelligence Center, 
SRI International, Menlo Park, California (June 
1984). 
Shieber, S. M., An Introductton to Untficatton-Based 
Approaches to Grammar, CSLI Lecture Notes Series, 
(University of Chicago Press, Chicago Illinois, 
forthcoming in 1986). 
Steedman, M., "Combinators, Categorial Grammars, and 
Parasitic Gaps," paper presented at the Tucson 
Conference on Categorial Grammar (June 1985). 
Uszkoreit, H., "On Categorial Unification Grammars," in 
this volume. 
Wittenburg, K., Some Properties of Combinatory 
Categorial Grammars of Relevance to Parsing. 
Technical Report HI-012-86, Microelectronics and 
Computer Technology Corporation, Austin, Texas, 
(January 1986). 
80 
